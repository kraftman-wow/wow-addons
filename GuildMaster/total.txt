--[[
====================================================================================
=========================== GUILD MASTER ============================================
====================================================================================

1. About
2. Changes
3. To do.

--========================== 1. About ===============================
	This module does some database management and handles loading all of the other modules.
	
	Aim of the addon:
	The key aims of this addon are to make guilds more streamlined: 
	Running a guild requires a fair emount of administration, so any way this can be made easier for the guild master is 
	obviously a bonus.
	
	
--========================== 2. Changes ==============================
1.7
	Started moving GM Stats into GMRoster
1.5
	More changes to the way modules are loaded, and the way that the guild frame is loaded.
	Moved some roster functionality over to GMRoster.
1.4+
	Modified some of the function calls to make each module properly modular
--========================== 3. To do ================================



--------------------------------

Each time the player logs in, broadcast some stats, eg:
resi
rating
itemlevel

Take a look at moving some of the savedvariables away from per character, 
eg the database and forum


Make all modules use the stored playername instead of UnitName("player")


current layout: 

GMLogs = {	} -- stores all of the stats per member

GMSettings = {
	Ranklist = {} stores the rank settings
	Debug = boolean -- wether to print debugging stuff or not
	Active -- wether to directly to record to the current table or not.
	LastLogout = number -- last date of the logout
	MOTD -- the guild message of the day, just in case it gets deleted.
	modules = {} --list of  addons, not quite sure what it does.
	Log = {} --list of all guild members with some stats for them.
	Version = number -- the version number of the guild
	EnableEvent = boolean -- wether to enable event insites or not.
	GMRecruit = {
							lastsent = number -- time of last message
							list == table -- list of all messages.
							}
	StartTime ==number when they first come online.
	lockout = boolean --locks the player out if the version number isnt newest
	
	
	
GMForum = {} -- list of all forum posts.

GMBanker = {} - Filters for bank tabs and 

addon 
String - Addon name to look up metadata for
field 
value = GetAddOnMetadata("addon", "field")
String - Field name. May be Title, Notes, Author, Version, or anything starting with X-
}
]]

--[[
	Standard checks to be carried out before release:
	
		-Check no guild info is wiped.
		-Check on multiple guilds
		-Check on character not in a guild.
		-Test upgrade from old svaedvars
		-Test upgrade from no savedvars.
		
	Module checks:
		-Load/Unload each module on demand.

--]]


local ADDON_VERSION

local runcount = 3 --records if the guild roster has updated for the first time.
local firstrun = true

GMaster = {} --stores info on which modules are loaded
GMaster.PlayerName = UnitName("player")
GMaster.QueueTable = {} -- set up the table
GMaster.TempTable = {}
GMaster.loaded = {}

GMaster.LoadOrder = {} --each module puts its name in here to indicate that it needs to be loaded
-- common events 
GMaster.PEW = {} --list of functions to run on PEW
GMaster.AL = {} --list of functions to run on Addon Loaded
GMaster.CMA = {} --list of functions to run on CHAT_MESSAGE_ADDON
GMaster.GFL = {} --guild frame loaded


GMaster.ModuleLoad = {} --stores all methods that load the module
GMaster.ModuleRemove = {} --stores all methods that remove the module
GMaster.ModuleSettings = {} --stores the settings page for each module

GMaster.GUILD_FRAME_LOADED = nil -- has the guild frame loaded yet.
GMaster.IS_GUILD_MASTER = nil

GMSettings = {} --saved vars, stores settings for all modules
GMRoster = {} -- saved vars, stores info for each player.

local SETTINGS_LOADED = nil

GMaster.Debug = function(self, ...) --global print used by all modules to debug
	if GMSettings.Debug then
		print(...)
	end
end

 

function GMaster.EventHandler(self, event, ...)
	if event == "ADDON_LOADED" then
		local addon = ...
		if addon == "GuildMaster" then --if this addon has loaded
			GMaster.OnLoad() --check settings etc
			for name, v in pairs(GMaster.LoadOrder) do
				if GMSettings.modules[name] and GMSettings.modules[name].active and GMaster.AL[name] then --if the module needs to be loaded, load it
					GMaster.AL[name]() --load the module
					GMaster.loaded[name]  = true --store that the module has loaded successfully
				end
			end
		elseif addon == "Blizzard_GuildUI" then
			GMaster.GUILD_FRAME_LOADED = true
			LoadAddOn("Blizzard_GuildControlUI")
			for name, func in pairs(GMaster.GFL) do
				if type(func) == "function" and GMSettings.modules[name] then
					func()
					GMaster.Debug("GFL, ",name, func)
				end
			end
		end
	elseif event == "PLAYER_ENTERING_WORLD" then 
			GMaster.IS_GUILD_MASTER = IsGuildLeader("player")
			for name, func in pairs(GMaster.PEW) do
				if type(func) == "function" then
					func()
				end
				GMaster.Debug("PEW, ",name, func)
			end
			if not SETTINGS_LOADED then
				if GMaster.GMSettings then --this needs to load after all the other modules
					GMaster.GMSettings()
					SETTINGS_LOADED = true
				end
			end		
	elseif event == "CHAT_MSG_ADDON" then
		if IsInGuild() then
			for name, func in pairs(GMaster.CMA) do --loop through all the functions that need th event
				if type(func) == "function" then
					func(...)
				end
			end				
		end
	elseif event == "GUILD_ROSTER_UPDATE" then
		if GMaster.RosterUpdate then
			GMaster.RosterUpdate(...)
		end	
	end
end

function GMaster.OnLoad() 
		ADDON_VERSION = tonumber(GetAddOnMetadata("GuildMaster", "Version"))
		GMaster.LastLogin = time()
		if not GMSettings.Version then
		
				GMSettings = {Version = ADDON_VERSION, StartTime = 0, LastLogout = 0, GMForum = {}, EnableEvent = true}
				GMSettings.modules = {}
				for name, k in pairs(GMaster.LoadOrder) do
					GMSettings.modules[name] = {}
					GMSettings.modules[name].active = true
				end
				GMSettings.RankList = {}
				GMaster.TempTable = {}
				GMSettings.Active = nil
				GMLogs = {}
				GMForum = {}
				
				if not GMRoster then
					GMRoster = {}
				end
		
		end
		
	
	if  GMSettings.Version <  ADDON_VERSION then --if they are using an old version of the addon, 
	
			GMSettings = {Version = ADDON_VERSION, StartTime = 0, LastLogout = 0, GMForum = {}, EnableEvent = true}
			GMSettings.modules = {}
			if not GMSettings.modules then
				GMSettings.modules = {}
			
			end
			for name, k in pairs(GMaster.LoadOrder) do
				GMSettings.modules[name] = {}
				GMSettings.modules[name].active = true
			end
			
			GMSettings.RankList = {}
			GMaster.TempTable = {}
			GMSettings.Active = nil
			GMLogs = {}
			GMForum = {}
			
			if not GMRoster then
				GMRoster = {}
			end
			
			if not GMSettings.RankList then
				GMSettings.RankList = {}
			end
			GMSettings.Version = ADDON_VERSION
	else
		GMSettings.lockout = false --innocent until proven guilty
	end
end



--[[	This big 'ol function needs to clean up our tables, which means
-remove any tables that are teeny tiny
-remove any tables that are empty
-merge tables that are old

--]]
function GMaster.CleanTables()
	
	local temptable = {}
				
	for dated, players in pairs(GMLogs) do --clears empty and small tables
		if not players.LastRecord then --if it hasnt recorded any values
			GMLogs[dated] = nil --remove it
		else
			local wipe = false
			if players.LastRecord - dated < 600 then --remove entries smaller than 10 minutes
				wipe = true
			end
			if wipe then
				GMLogs[dated] = nil --remove it
			else
				tinsert(temptable, {dated, players.LastRecord}) --add it into the temp table
			end
		end
	end
	
	table.sort(temptable, function(a, b) return a[1] > b[1] end)
			
	for i = 2, #temptable, 1 do -- this function should merge tabls that are close to each other
		local first = temptable[i]
		local second = temptable[i +1]
		if first and second then
		
			 --dont add the second to last table to the potentially current table
				if first[1] - second[2] < 600 and (first[1] - second[2] > 0) then
				
				GMLogs[second[1]].LastRecord = first[2]
				--check they are on the same day
					if date("%d", first[1]) == date("%d", second[2]) then 
						for name, info in pairs(GMLogs[first[1]]) do
							if name ~= "LastRecord" then
								if not GMLogs[second[1]][name] then
									GMLogs[second[1]][name] = {}
								end
								for k, v in pairs(info) do
									if not GMLogs[second[1]][name][k] then
										GMLogs[second[1]][name][k] = v
									else
										if k > 9 and k < 16 then
											if  GMLogs[second[1]][name][k] < v then
												GMLogs[second[1]][name][k] = v
											end
										else
											GMLogs[second[1]][name][k] = GMLogs[second[1]][name][k] + v
										end
									end
								end
							end
						end
					end
						GMLogs[first[1]] = nil
				end		
			end
		end
				
	for i = 2, #temptable do
		local first = temptable[i]
		for j = 2, #temptable do
			if i ~= j then
				local second = temptable[j]
				if first[1] > second[1] and first[2] > second[2] then --first was somehow recorded inside second
					GMLogs[first[1]] = nil -- remove it from the savedvars
				end
			
			end
		end
	end
	GMaster.CleanTables = nil
	--need to loop through all tables and merge some based on their dates
	--pull out the merge function from the above loop so it can be reused
end

	--[[
	Need to make this function delete any location data stored when they go offline.
	
	--]]


local Eventler = CreateFrame("Frame")
Eventler:RegisterEvent("PLAYER_ENTERING_WORLD")
Eventler:RegisterEvent("ADDON_LOADED")
Eventler:RegisterEvent("CHAT_MSG_ADDON")
Eventler:RegisterEvent("GUILD_ROSTER_UPDATE")
Eventler:SetScript("OnEvent", GMaster.EventHandler)--[[

1. About
2. Changes
3. To do.
 
--========================== 1. About ===============================
This module containers a timer which all of the modules use to schedule thier functions.
Since none of the modules need to check settings on every frame, this module reduces the number 
of function calls, and the number of frames needed to be created.

--========================== 2. Changes ==============================
2.0 
	-fixed an error preventing the timer repeating.
1.53
	New method for adding timers, makes things slightly neater
	some minor increases in efficiency
1.42
Moved the message queueing function from GMSync to here, which means other addons can still use it when 
GMSync is deactivated.

--========================== 3. To do ================================
Need to make the function that adds the queued stuff work faster.

Efficiency:
Need to have seperate tables for different jobs, 
eg some functions only need checking once a second, once a minute, once an hours

Make the timer more efficient:
only perform updates as fast as the fastest required update

]]

local SendAddonMessage = SendAddonMessage
local unpack = unpack
local tremove = tremove

local StopWatch = CreateFrame("Frame")
StopWatch.interval = 0.1
StopWatch.elapsed = 0
GMaster.Timers = {}

GMTimer = {}


local function StopWatcher(self, elapsed)
	StopWatch.elapsed = StopWatch.elapsed + elapsed
	if StopWatch.elapsed >= StopWatch.interval then
		for i = #GMaster.Timers , 1, -1 do
			local timer = GMaster.Timers[i]
			if timer then
				timer.elapsed = timer.elapsed + StopWatch.elapsed
				if timer.elapsed >= timer.interval then
					if timer.vars then
							timer.func(unpack(timer.vars))
					else
							timer.func()
					end
				
					if timer.dorepeat then
						timer.elapsed = 0
					else
						tremove(GMaster.Timers, i)
					end
				end
			end
		end
		StopWatch.elapsed = 0
	end
end

function GMTimer:NewTimer(interval, func, args, dorepeat)
	--print(interval, func, args, dorepeat)
	tinsert(GMaster.Timers, {dorepeat = dorepeat, interval = interval, elapsed = 0, func = func, vars = args})
end

StopWatch:SetScript("OnUpdate", StopWatcher)

local queue = GMaster.QueueTable

local function QueueIt()
	
	if #queue > 0 then
		local prefix, msg = unpack(tremove(queue, 1))
		if prefix and msg then
			if IsInGuild() then
				SendAddonMessage(prefix, msg, "GUILD")
			end
		end
	end
	if GMSettings.Active == true and not (GMSettings.StartTime == 0) then
		if #GMaster.TempTable > 0 then --if there are temporary values
			local a, b, i, v, l = unpack(tremove(GMaster.TempTable,1))
			GMaster:Debug("Adding queued info "..a..i..v)
			GMaster.AddInfo(a, b, i, v, l)
			--[[
			for i = 1, #GMaster.TempTable do
				local a, b, i, v, l = unpack(GMaster.TempTable[i])
				GMaster:Debug("Adding queued info "..a..i..v)
				GMaster.AddInfo(a, b, i, v, l)
			end
			GMaster.TempTable = {}
			--]]
			
		end
	end
end

GMTimer:NewTimer(0.3, QueueIt, nil, true)
--tinsert(GMaster.Timers, {runonce = false, interval = 0.3, elapsed = 0, func = QueueIt})

--Example:
-- old
--run a function without vars:
--	tinsert(GMaster.Timers, {runonce = true, interval = 3, elapsed = 0, func = AcceptGroup})
--run a function with vars:
--tinsert(GMaster.Timers, {runonce = true, interval = 5, elapsed = 0, func =  StaticPopup_Hide, vars = {"PARTY_INVITE"}})--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Records which alts are in the same guild, 
	and shares this info with other players.
--========================== 2. Details ===============================
	Upon logging in, the module checks to see if the player is in a guild:
	if they are, it creates a record and stores their name under their guild name.
	all alts in the current guild are then broadcast out for other players to receive.
	upon receiving a name from a player, the name is added to the addons roster under the players name.
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
2.1
	--removes alts no longer in the guild.

1.4
	Broadcasting alts now works.
	Recieving and recording alts now works.
--========================== 5. To do =================================
	Add method of removing alts if they changed guilds
	integrate the alts feature into all of the other modules that need it.
]]

GMaster.LoadOrder.GMAlts = true

function GMaster.AL.GMAlts() --load on ADDON_LOADED

	local name = GMaster.PlayerName
	local guild = GetGuildInfo("player")
	
	if not GMAlts then
		GMAlts = {}
	end
	
	if guild then
		if not GMAlts[guild] then
			GMAlts[guild] = {}
		end
		if not GMAlts[guild][name] then
			GMAlts[guild][name] = {}
		end
	end
	
	

	
	function GMaster.PEW.SendAlts()
				--check alts:
		for name, info in pairs(GMRoster) do
			if info.Alts then
				for alt in pairs(info.Alts) do
					if not GMRoster[alt] then
						GMRoster[name].Alts[alt] = nil
					end
				end
			end
		end	
	
	
		if GMaster.LastLogin < (time() - 3600) then
			if GMAlts[guild] then
				local msg = "|"
				for alt, v in pairs(GMAlts[guild]) do
					msg = msg..alt.."|"
				end
				
				GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMAlts", msg}
			end
			
		end
		GMaster.PEW.SendAlts = nil --remove itself once it has run
	end
	
	function GMaster.CMA.ReceiveAlts(prefix, msg, channel, player)
		if prefix == "GMAlts" then
			for alt in string.gmatch(msg, "(.-)|") do
				if not (alt == "") then
					if GMRoster[player] then
						if not GMRoster[player].Alts then
							GMRoster[player].Alts = {}
						end
						GMRoster[player].Alts[alt] = true
					end
				end
			end
		end
	end
end

function GMaster.ModuleSettings.GMAlts()
	local parent = CreateFrame("Frame")
			parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
			parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
			parent.titleText:SetJustifyH("LEFT")
			parent.titleText:SetJustifyV("TOP")
			parent.titleText:SetText("GM-Alts tracks alts of guild members and shares them with other members, allowing you to see who's who easily in the roster."..
																"\n There are currently no settings that can be changed for this module")
		return parent
end

function GMaster.ModuleLoad.GMAlts()
	--enable the module
		GMaster.AL.GMAlts()
	
	--create settings page
	
	
end

function GMaster.ModuleRemove.GMAlts()
	GMaster.CMA.ReceiveAlts = nil --prevent it from receiving alts, for what its worth
	return true
end


--[[
1. Summary 
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Adds filters to each bank tab allowing you to automatically sort items 
	depending on type, subtype, Quality, or auction value. (Requires auctioneer for auction value 
	to be determined
--========================== 2. Details ===============================
	The guild master can use the dropdown menu to add certain filters to a tab, for example
	only Blue items that are weapons, or green gems.
	The module then scans all of the items and find any which match all of the tabs filters,
	matching items are then moved to the desired tab.
	Any items which do not match any filter are auto sorted by subtype, and placed in any tabs that 
	have no filters.
	Tabs that have "Ignore" selected in the dropdown menu are treated like they do no exist.
	No items will be moved from them or placed into them.
	
	Each tab can also have a minimum value set. This pulls the item auction price from the Auctioneer database,
	and multiplies it by the number of items in the stack. If the value is above a tabs minimum value, the item
	will be moved to that tab. This is useful for creating Officer tabs which contain expensive items that
	general guild members cannot access.
	
	Due to the latency between the client and server, some items may not get properly moved between tabs.
	the module attempts to compensate for this by splitting movement of items that may conflict across multiple passes.
	If after sorting the bank it looks like it hasnt quite sorted all of the items, run the sort again and it should sort
	it out.
--========================== 3. Structure =============================
	Button - Auto sort. Requests tab data from the server and runs 
	AllocateItems - records the item in every tab
	SortItems - Works out where each item needs to go based on the filters, queues each item
	AllocateItems - sends the movement to the server
	
--========================== 4. Changes ===============================
2.1
	The guild bank frame should no longer overlap other frames when shown
	away from the guild bank.
	Added a last scanned time.

2.0
	Added button to the guildframe to enable toggling the guild bank
1.6
	Converted to new timer method
	fixed error on checking for auctioneer
	guild bank frame shows away from the guild bank.
1.52
	Created the module - Filters and sorting now work.
--========================== 5. To do =================================
	Show the last checked time.
	Auto bag greys.
	Change the pass system to recheck the location each time.
	
	Integrate settings and load/unload
	need to add an icon to the guild frame
]]

GMaster.LoadOrder.GMBanker = true --can change this to force disable the addon

local module = {}

function GMaster.AL.GMBanker()


end

GMBanker = {}
GMBanker.SaveList = {}




local SaveList = GMBanker.SaveList


local Filters = {}
local module = {}

local modes = {}
			modes["Quality"] = {r = 0.5, g = 0, b = 0}
			modes["Item Level"] = {r = 0, g = 0.5, b = 0}

local mode = "test"

local itemClasses = { GetAuctionItemClasses() };

local flatlist = {} --list of all items in the bank
local treelist = {}

local BagSpace = 0

local BANK_LOADED

local virtual


local AutoSort = CreateFrame("Button", nil, UIParent, "UIPanelButtonTemplate")
			AutoSort:SetSize(80, 25)
			AutoSort:SetText("Auto Sort")
			
			
local MoneyBox = CreateFrame("EditBox", "GMBankEB", UIParent, "InputBoxTemplate")
			MoneyBox:SetNumeric(true)
			MoneyBox:SetAutoFocus(false)
	MoneyBox:Hide()
	
	local moneytext = MoneyBox:CreateFontString(nil, "OVERLAY", "GameFontNormal")
		moneytext:SetSize(100, 20)
		moneytext:SetPoint("RIGHT", MoneyBox, "LEFT", -5, 0)
		moneytext:SetText("Min Value (g):")

local ModeDD = CreateFrame("Frame", "GMBankModeDD", UIParent, "UIDropDownMenuTemplate")


local loadBar = CreateFrame("StatusBar", "GMBankerTestBar", UIParent)

local BankTip = CreateFrame("GameTooltip","GMBankerTT", UIParent, "GameTooltipTemplate")

local function SetLabels(title, text)
	GuildBankMoneyLimitLabel:SetText(title)
	GuildBankMoneyUnlimitedLabel:SetText(text)
end

local function LoadBank()
	if not BANK_LOADED then
		LoadAddOn("Blizzard_GuildBankUI")
		BANK_LOADED = true
	else

	end

	if GuildBankFrame:IsShown() then
		GuildBankFrame:Hide()
	else
		virtual = true
		--GuildBankFrame:Show()
		ShowUIPanel(GuildBankFrame)
	end

end

local BankButton = CreateFrame("Button", nil, UIParent)

function GMaster.GFL.GMBanker()
	BankButton:SetParent(GuildFrame)
	BankButton:SetScript("OnClick", LoadBank) 
	BankButton.bg = BankButton:CreateTexture()
	BankButton.bg:SetTexture("Interface\\Minimap\\MiniMap-TrackingBorder.blp")
	BankButton.bg:SetAllPoints(BankButton)
	BankButton.bg:SetTexCoord(0, 0.5, 0, 0.5)
	BankButton.icon = BankButton:CreateTexture()
	BankButton.icon:SetTexture("Interface\\Minimap\\OBJECTICONS")
	BankButton.icon:SetPoint("TOPLEFT", 5, -5)
	BankButton.icon:SetPoint("BOTTOMRIGHT", -5, 5)
	BankButton.icon:SetTexCoord(0.125, 0.25, 0.5, 0.75)
	BankButton:SetSize(30,30)
	BankButton:SetPoint("CENTER", GuildFrame, "TOPLEFT")
	
end

local function GuildBank_OnHide()
	virtual = false
end

local function GuildBank_OnShow(force)
	if virtual then
		AutoSort:Hide()
		ModeDD:Hide()
		GuildBankFrameTab1:Hide()
		GuildBankFrameTab2:Hide()
		GuildBankFrameTab3:Hide()
		GuildBankFrameTab4:Hide()
	
		if GMBanker.lastcheck then
			SetLabels("Last Scanned:", date("%H:%M:%S %d/%m/%y", GMBanker.lastcheck)) 
		end
		
	else
		GuildBankFrameTab1:Show()
		GuildBankFrameTab2:Show()
		GuildBankFrameTab3:Show()
		GuildBankFrameTab4:Show()
		
		AutoSort:Show()
		ModeDD:Show()
		flatlist = {} --clear out the old lists
		treelist = {}
		wipe(SaveList)
		local dur = 0
		local tabmax = GetNumGuildBankTabs()
		GMBanker.LimitLabel = GuildBankMoneyLimitLabel:GetText() --store the old labels
		GMBanker.LimitText = GuildBankMoneyUnlimitedLabel:GetText() 
		GMBanker.lastcheck = time()
		for i = 1, tabmax do 
			dur = dur + 0.1
			if Filters[i].Ignore then
																			
			else
				GMTimer:NewTimer(dur, QueryGuildBankTab, {i})
				GMTimer:NewTimer(dur, SetLabels, {"Requesting: ", "Tab "..i})
				GMTimer:NewTimer(dur, function(arg1) loadBar:SetValue(arg1) end, {(100/tabmax)*i})
				GMTimer:NewTimer(dur+1, module.CheckTabs, {i})
				GMTimer:NewTimer(dur+1, SetLabels, {"Scanning: ", "Tab "..i})		
			end
		end
		GMTimer:NewTimer(dur+2, function() loadBar:Hide() SetLabels(GMBanker.LimitLabel, GMBanker.LimitText) end )

		return dur
	end
end


function testest1()
	if not GuildBankFrame then
		LoadAddOn("Blizzard_GuildBankUI")
	end
	virtual = true
	--GuildBankFrame:Show()
	ShowUIPanel(GuildBankFrame)
end

--========================= Frames ==============================

local function dropdown_OnClick(self, itype, isubtype)
	local tab = GetCurrentGuildBankTab() 
	
	if not Filters[tab] then
		Filters[tab] = {}
	end
	if not Filters[tab][itype] then
		Filters[tab][itype] = {}
	end
	
	if Filters[tab][itype][isubtype] then
		Filters[tab][itype][isubtype] = nil
		if not next(Filters[tab][itype]) then
			Filters[tab][itype] = nil
		end
	else
		Filters[tab][itype][isubtype] = true
	end
end

local function CheckFilter(itype,name)
	if not Filters[GetCurrentGuildBankTab()] then
		return nil
	elseif not Filters[GetCurrentGuildBankTab()][itype] then
		return nil
	elseif not Filters[GetCurrentGuildBankTab()][itype][name] then
		return nil
	end

	if Filters[GetCurrentGuildBankTab()][itype][name] then
		return true
	end
end



UIDropDownMenu_SetWidth(ModeDD, 110)
UIDropDownMenu_SetButtonWidth(ModeDD, 85)

local function ModeDD_Initialize(self, level) -- the menu items, needs a cleanup
		level = level or 1
	local info = UIDropDownMenu_CreateInfo()
	local value = UIDROPDOWNMENU_MENU_VALUE
	
	info.isNotRadio = true
	
	if level == 1 then
	
		info.notCheckable = true
		info.text = "Type"
		info.value = "weptype"
		info.hasArrow = true
		info.func = function()  end
		UIDropDownMenu_AddButton(info, level)
		
		info.text = "Quality"
		info.value = "Quality"
		info.hasArrow = true
		info.func = function(self)  end
		UIDropDownMenu_AddButton(info, level)
		
		info.text = "Ignore"
		info.value = "Ignore"
		info.hasArrow = false
		info.notCheckable = false
		info.checked = function() if not Filters[GetCurrentGuildBankTab()] then return nil elseif not Filters[GetCurrentGuildBankTab()].Ignore then return nil else return true end end
		info.func = function(self) if Filters[GetCurrentGuildBankTab()].Ignore then Filters[GetCurrentGuildBankTab()].Ignore = nil else Filters[GetCurrentGuildBankTab()].Ignore = true  end end
		UIDropDownMenu_AddButton(info, level)
	
	elseif level == 2 then 
		if value == "weptype" then
			for i, name in pairs(itemClasses) do
				info.text = name
				info.value = i
				info.arg1 = "itemType"
				info.arg2 = name
				info.checked = CheckFilter("itemType", name)
				info.func = dropdown_OnClick
				info.hasArrow = true
				info.keepShownOnClick = true
				UIDropDownMenu_AddButton(info, level)
			end
		elseif value == "Quality" then
			for i=0, getn(ITEM_QUALITY_COLORS)-2  do
				local name = _G["ITEM_QUALITY"..i.."_DESC"];
				info.text = name
				info.value = name
				info.arg1 = "itemRarity"
				info.arg2 = name
				info.func = dropdown_OnClick
				info.keepShownOnClick = true
				info.checked = CheckFilter("itemRarity", name)
				
				info.colorCode = select(4, GetItemQualityColor(i))
				UIDropDownMenu_AddButton(info, level);
			end
		end
	elseif level == 3 then
		local test = {GetAuctionItemSubClasses(value)}
		
		for i = 1, #test do
			info.text = test[i]
			info.value = i
			info.checked = CheckFilter("itemSubType", test[i])
			info.arg1 = "itemSubType"
			info.arg2 = test[i]
			info.func = dropdown_OnClick
			info.keepShownOnClick = true
			UIDropDownMenu_AddButton(info, level)
		end
	end
end

UIDropDownMenu_Initialize(ModeDD, ModeDD_Initialize)
UIDropDownMenu_SetText(ModeDD, "Select Filters")

		

	
	
	
local function moneyEnterPressed(self)
local tab = GetCurrentGuildBankTab()
local value = tonumber(self:GetText())
	if value == 0 then
		self:SetText("")
		Filters[tab].MinVal = nil
	elseif value and (value > 0) then
		Filters[tab].MinVal = value*10000
	end
end


	MoneyBox:SetScript("OnEnterPressed", moneyEnterPressed)


--=====================================================================

local function OnTabClick()
local tab = GetCurrentGuildBankTab()
	if Filters[tab].MinVal then
		MoneyBox:SetText(Filters[tab].MinVal/10000)
	else
		MoneyBox:SetText("")
	end

	if virtual then
		
			local button, index, column;
			local texture, itemCount, locked;
			for i=1, MAX_GUILDBANK_SLOTS_PER_TAB do
				index = mod(i, NUM_SLOTS_PER_GUILDBANK_GROUP);
				if ( index == 0 ) then
					index = NUM_SLOTS_PER_GUILDBANK_GROUP;
				end
				column = ceil((i-0.5)/NUM_SLOTS_PER_GUILDBANK_GROUP);
				button = _G["GuildBankColumn"..column.."Button"..index];
				button:SetScript("OnLeave", function(self) BankTip:Hide() end)
				button:SetID(i);
				if SaveList[tab] then
				--print(tab, "test", i, SaveList[tab][i], SaveList[tab][i].texture)
				local item = SaveList[tab][i]
					if item and item.texture then
						
						SetItemButtonTexture(button, item.texture);
						SetItemButtonCount(button, item.count);
						button.link = item.link
						button:SetScript("OnLeave", function(self) GameTooltip:Hide() end)
						
					else
						button.link = nil
					end
				end
			end
	end
	
end
													
													
local function GMBanker_OnLoad()
	
	if not GMBanker.Filters then
		GMBanker.Filters = {}
	end
	
	function GuildBankItemButton_OnEnter(self)
		if self.link then 
			BankTip:SetOwner(self, "ANCHOR_RIGHT")
			BankTip:SetHyperlink(self.link)
		else
			GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
			GameTooltip:SetGuildBankItem(GetCurrentGuildBankTab(), self:GetID())
		end
	end
	
	Filters = GMBanker.Filters
	
	SaveList = GMBanker.SaveList
	 
	for i = 1, GetNumGuildBankTabs() do
		if not Filters[i] then
			Filters[i] = {}
		end
	end
	

	hooksecurefunc(GuildBankFrame, "Show", GuildBank_OnShow)
	hooksecurefunc(GuildBankFrame, "Hide", GuildBank_OnHide)
	--if auctioneer is running, allow the price box
	--need to check and remove any previous price filters.
	if AucAdvanced and AucAdvanced.API and AucAdvanced.API.GetMarketValue then
		MoneyBox:SetParent(GuildBankFrame)
		MoneyBox:SetPoint("TOP", GuildBankFrame, "TOP", -130, -40)
		MoneyBox:SetSize(60, 20)
		MoneyBox:Show()
		MoneyBox:SetScript("OnEscapePressed", function(self) self:ClearFocus()  end)
		
		moneytext:Show()
		
		hooksecurefunc("GuildBankTab_OnClick", OnTabClick)
	end
	
	
	loadBar:SetParent(GuildBankFrame)
	loadBar:SetSize(410, 10)
	loadBar:SetPoint("BOTTOMLEFT", 210, 17)
	loadBar:SetMinMaxValues(0, 100)
	loadBar:SetValue(100)
	loadBar:SetStatusBarTexture("Interface\\Tooltips\\UI-Tooltip-Background")
	loadBar:SetStatusBarColor(0, 1, 0)
	
	AutoSort:SetParent(GuildBankFrame)
	AutoSort:SetPoint("TOPRIGHT", -14, -38)
	
	ModeDD:SetParent(GuildBankFrame)
	ModeDD:SetPoint("TOPRIGHT", -80, -37)
	
	if IsGuildLeader() then
		AutoSort:Show()
		ModeDD:Show()
		MoneyBox:Show()
		moneytext:Show()
		
	else
		AutoSort:Hide()
		ModeDD:Hide()
		MoneyBox:Hide()
		moneytext:Hide()
		
	end
end


local Eventler = CreateFrame("Frame")

Eventler:RegisterEvent("ADDON_LOADED")
Eventler:SetScript("OnEvent", function(self, event, addon)
																if addon == "Blizzard_GuildBankUI" then
																	GMBanker_OnLoad()
																	
																end
															end)


--========================= functional stuff =========================





local function GetAucValue(itemlink)
	--need to check auctioneer is loaded
	if AucAdvanced then
		local value, seen = AucAdvanced.API.GetMarketValue(AucAdvanced.SanitizeLink(select(2, GetItemInfo(itemlink))))
		return value, seen
	 end
end

--check the number of free bag slots
local function CheckBagSpace()
	bagspace = 0
	for bag = 0,4 do
		bagspace = bagspace + GetContainerNumFreeSlots(bag)
	end
	return bagspace
end



									 
local function AllocateItems(start, finish, pass)
	local igcount = 0
	local movcount = 0
	for i = start, finish do
		if not flatlist[i] then
			return
		end
		local item = flatlist[i]
		
		local link = GetGuildBankItemLink(item.totab, item.toslot)
		local count = select(2, GetGuildBankItemInfo(item.totab, item.toslot))
		if item.pass and (item.pass > pass) then
			return
		end
		if item.moved or link == item.link then
			
			igcount = igcount + 1
			item.moved = true
		else
			movcount = movcount + 1
			
			if treelist[item.totab][item.toslot] == "Empty" then
				--its moving to an empty slot
					PickupGuildBankItem(item.tab, item.slot) --pick it up
					PickupGuildBankItem(item.totab, item.toslot) --drop it in the empty slot
					treelist[item.tab][item.slot] = "Empty" --mark the old slot as empty
					treelist[item.totab][item.toslot] = item --mark the new slot as full 
					item.tab = item.totab
					item.slot = item.toslot
			else
				PickupGuildBankItem(item.tab, item.slot) --pick it up
				PickupGuildBankItem(item.totab, item.toslot) -- swap it with the other one
				
				for i = 1, #flatlist do --find the one thats been replaced
					if flatlist[i].tab == item.totab and flatlist[i].slot == item.toslot then
							flatlist[i].tab = item.tab
							flatlist[i].slot = item.slot
							flatlist[i].pass = pass+ 1
						if flatlist[i] == item then
							item.tab = item.totab
							item.slot = item.toslot
						end
					end					
				end
			end
			QueryGuildBankTab(item.tab)
		end
	end
	print("Moved: "..movcount..", ignored: "..igcount)
end
									 
local function SortItems()
	
	table.sort(flatlist, function(a, b) return a.SortBy < b.SortBy end) --sort by the necessary requirement


	local tabmax = GetNumGuildBankTabs()
	
	local bagsize = CheckBagSpace()
	local bagcount = 0
	
	local tabcount = {}
		for i = 1, tabmax do
			tabcount[i] = 1
		end
	
	for i, item in pairs(flatlist) do
		
		local found = nil
	
	
		for j = 1, tabmax do
			if Filters[j].Ignore then
			
			elseif Filters[j].MinVal and ((item.itemAuc*item.itemStackCount) > Filters[j].MinVal) then
				found = j
			else
				local loc = nil
				for filter, subfilter in pairs(Filters[j]) do
					if (filter ~= "MinVal") and (filter ~= "SortBy") then
						if item[filter] and subfilter[item[filter]] then
							loc = j
						else
							loc = nil
						end				
					end
				end	
				if loc then --it matches all filters
					found = loc
				end
			end
		end
		
		if found then
			if tabcount[found] < (7*14) then
				item.totab = found
				item.toslot = tabcount[found]
				tabcount[found] = tabcount[found] + 1
			else
				found = nil
			end
		end
		
		-- at this point anything that matches a filter has been allocated a slot, anything else 
		-- will be either put into a tab with no filters, or placed in the bag
		for i = 1, #flatlist do
			if baggreys and not found then
				if item.itemRarityIndex == 0 then
					if bagspace > 0 then
						AutoStoreGuildBankItem(item.tab, item.slot)
						item.moved = true --prevent the next function from messing around with it
						TreeList[item.tab][item.slot] = "Empty" --mark its slot as empty
					end
				end			
			end
		end
		
		if not found then
			local t = 1
			while (Filters[t] ~= {}) and (tabcount[t] >= 7*14) --[[or Filters[t].Ignore]]  do --needs testing
				t = t + 1
				if t > tabmax then
					break
				end
			end
			if t > tabmax then
				
				--it doesnt fit anywhere
				--bag it
				--return
			else
				item.totab = t
				item.toslot = tabcount[t]
				tabcount[t] = tabcount[t] + 1
			end
		end
	end

	
	local split = 20
	local interval = 0.5
	local passes = 2
	local passtime = interval * #flatlist + 10
	
	local tabmax = tabmax
	local itemcount = #flatlist
	
	for j = 0, passes-1 do
		for i = 0, floor((itemcount/split)+0.5) do
			GMTimer:NewTimer(i*interval + j*passtime, AllocateItems, {i*split + 1, i*split + split, j})
			
			for k = 1, tabmax do
				GMTimer:NewTimer((passtime*j)-2, QueryGuildBankTab, {k})
			end
				GMTimer:NewTimer(i*interval + j*passtime, SetLabels, {"Pass: "..(j+1),"Sorting items: "..(i*split + 1).." to "..(i*split + split)} )
				GMTimer:NewTimer(i*interval + j*passtime, function(arg1) loadBar:SetValue(arg1) end, {(j*itemcount + i*split)/(passes*itemcount)*100})
		end
	end
	GMTimer:NewTimer(((passes+1)*passtime)-5, SetLabels, {"Done!",""} )
	GMTimer:NewTimer((passes+1)*passtime, function() loadBar:Hide() SetLabels(GMBanker.LimitLabel, GMBanker.LimitText) end )

end

function module.CheckTabs(tab)
	 --GuildBankTab_OnClick(nil, nil, tab) --check if this is still needed or not
		--check docks, mmight need to manually switch tabs here
		if not treelist[tab] then
			treelist[tab] = {}
		end
		if not SaveList[tab] then
			SaveList[tab] = {}
		end
		
		for slot = 1, (14*7) do
			local link = GetGuildBankItemLink(tab, slot)
			local count = select(2, GetGuildBankItemInfo(tab, slot))
			
			loadBar:Show()
			
			if link then --if an item exists
				local usable = IsUsableItem(link)
				local itemName, itemLink, itemRarity, itemLevel, itemMinLevel, itemType, itemSubType, itemStackCount,
							itemEquipLoc, itemTexture, itemSellPrice = GetItemInfo(link)
							
					tinsert(flatlist, {
															link = link,
															tab = tab,
															slot = slot,
															itemName = itemName,
															itemLink = itemLink,
															itemRarity = _G["ITEM_QUALITY"..itemRarity.."_DESC"],
															itemRarityIndex = itemRarity,
															itemLevel = itemLevel,
															itemMinLevel = itemMinLevel, 
															itemType = itemType,
															itemSubType = itemSubType,
															itemStackCount = count,
															itemEquipLoc = itemEquipLoc,
															itemTexture = itemTexture,
															itemSellPrice = itemSellPrice,
															itemAuc = GetAucValue(itemLink) or 0,
															SortBy = itemSubType..itemName
															
														})
						treelist[tab][slot] = flatlist[#flatlist]
						SaveList[tab][slot] = {count = count, texture = itemTexture, link = itemLink}
						--print("tab: "..tab, "slot: "..slot, treelist[tab][slot].itemType)
			else
				treelist[tab][slot] = "Empty" --store location of empty places
				SaveList[tab][slot] = {}
			end
	end
end



AutoSort:SetScript("OnClick", function() 
																CheckBagSpace()
																local dur = GuildBank_OnShow() -- get most recent item data, and duration to wait (dependant on tab number)
																GMTimer:NewTimer(dur, SetLabels, {"Sorting..", ""})
																GMTimer:NewTimer(dur+3, SortItems)																		
															end)



															
															
															
															
--=================================================================================
--=================================================================================

function GMaster.ModuleSettings.GMBanker()
	local parent = CreateFrame("Frame")
			parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
			parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
			parent.titleText:SetJustifyH("LEFT")
			parent.titleText:SetJustifyV("TOP")
			parent.titleText:SetText("GM-Banker"..
																"\n ")
		return parent
end

function GMaster.ModuleLoad.GMBanker()
	GMaster.AL.GMBanker()
	GMBanker_OnLoad()
end

function GMaster.ModuleRemove.GMBanker()
	AutoSort:Hide()
	ModeDD:Hide()
	MoneyBox:Hide()
	BankButton:Hide()
	return false
end
--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Auto create guild events with filters for level, role, and gear.
--========================== 2. Details ===============================
	Adds a button to the guild frame which allows any guild member to create a custom event.
	Options for the name of the event, the roles required, a minimum level, resilience, or item level.
	Sends the invite to any player who matches the criteria, and isnt busy (raiding/arena/etc)
	
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================


1.47
	-Added option to select minimum resilience, level, and item level.
	-Added a status window showing which players have been invited, etc.
	-Declining an event will automatically decline all events for the next 15 minutes
--========================== 5. To do =================================
	Priority: Low
	Add broadcast event to record who started the event, and who joined it 
	check recording of event start and attendance.
	option to choose from previous event
	make the list of replies scrollable.
--]]


GMaster.LoadOrder.GMEvent = true

local module = {}

function GMaster.AL.GMEvent()
	local IsLeader = nil
	local tempdisable = false
	
	local Queue = {}

	local AskFrame = CreateFrame("Frame", nil, UIParent)
	AskFrame.page = 1



	local function PartyCheck() --check this bit
		if GetNumRaidMembers() < 1 and GetNumPartyMembers() < 1 then
			IsLeader = nil 
			AskFrame.event = nil
			AskFrame.numheal = nil
			AskFrame.numdps = nil
			AskFrame.numtank = nil
			AskFrame.healcount = 0
			AskFrame.dpscount = 0
			AskFrame.tankcount = 0
			AskFrame.minres = nil
			--reset and event stuff
		end
	end


	local test = CreateFrame("Frame")
	test:RegisterEvent("PARTY_MEMBERS_CHANGED")

	AskFrame:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background", 
												edgeFile = "Interface/Tooltips/UI-Tooltip-Border", 
												tile = true, tileSize = 16, edgeSize = 16, 
												insets = { left = 4, right = 4, top = 4, bottom = 4 }})
	AskFrame:SetBackdropColor(0,0,0,1);
	AskFrame:Hide()
	AskFrame.TitleText = AskFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	AskFrame.TitleText:CanWordWrap(true)
	AskFrame.TitleText:SetJustifyV("TOP")
	AskFrame.TitleText:SetPoint("LEFT", AskFrame, "LEFT", 40, 0)
	AskFrame.TitleText:SetPoint("RIGHT", AskFrame, "RIGHT", -40, 0)
	AskFrame.TitleText:SetHeight(50)
	AskFrame.TitleText:SetPoint("TOP", AskFrame, "TOP", 0, -20)
	AskFrame.TitleText:SetText("Would you like to queue for premades?")

	AskFrame.EditBox = CreateFrame("EditBox", "GMEventEB", AskFrame, "InputBoxTemplate")
	AskFrame.EditBox:SetWidth(350)
	AskFrame.EditBox:SetHeight(25)
	AskFrame.EditBox:SetScript("OnEscapePressed", function(self) AskFrame:Hide() SendAddonMessage("GMEventBusy", "Reason: Closed", "GUILD") end)


	AskFrame.LevelBox = CreateFrame("EditBox", "GMEventLevelB", AskFrame, "InputBoxTemplate")
	AskFrame.LevelBox:SetWidth(100)
	AskFrame.LevelBox:SetHeight(25)
	AskFrame.LevelBox:SetScript("OnEscapePressed", function(self) AskFrame:Hide() end)
	
	
	AskFrame.iLevelBox = CreateFrame("EditBox", "GMEventiLevelB", AskFrame, "InputBoxTemplate")
	AskFrame.iLevelBox:SetWidth(100)
	AskFrame.iLevelBox:SetHeight(25)
	AskFrame.iLevelBox:SetScript("OnEscapePressed", function(self) AskFrame:Hide() end)
	
	
	AskFrame.RessiBox = CreateFrame("EditBox", "GMEventRessiB", AskFrame, "InputBoxTemplate")
	AskFrame.RessiBox:SetWidth(100)
	AskFrame.RessiBox:SetHeight(25)
	AskFrame.RessiBox:SetScript("OnEscapePressed", function(self) AskFrame:Hide() end)
	

	AskFrame.Heal = CreateFrame("Button", nil, AskFrame)
	AskFrame.Heal:SetWidth(100)
	AskFrame.Heal:SetHeight(100)
	AskFrame.HealBg = AskFrame.Heal:CreateTexture()
	AskFrame.HealBg:SetTexture("Interface\\LFGFrame\\UI-LFG-ICONS-RoleBACKGROUNDS")
	AskFrame.HealBg:SetTexCoord(GetBackgroundTexCoordsForRole("HEALER"))
	AskFrame.HealBg:SetAllPoints(AskFrame.Heal)
	AskFrame.HealBg:SetDrawLayer("BACKGROUND")
	AskFrame.HealIcon = AskFrame.Heal:CreateTexture()
	AskFrame.HealIcon:SetTexture("Interface\\LFGFrame\\UI-LFG-ICON-RoleS")
	AskFrame.HealIcon:SetTexCoord(GetTexCoordsForRole("HEALER"))
	AskFrame.HealIcon:SetPoint("TOPLEFT", AskFrame.Heal, "TOPLEFT", 15, -15)
	AskFrame.HealIcon:SetPoint("BOTTOMRIGHT", AskFrame.Heal, "BOTTOMRIGHT", -15,15)
	AskFrame.Heal:Hide()

	AskFrame.Dps = CreateFrame("Button", nil, AskFrame)
	AskFrame.Dps:SetWidth(100)
	AskFrame.Dps:SetHeight(100)
	AskFrame.DpsBg = AskFrame.Dps:CreateTexture()
	AskFrame.DpsBg:SetTexture("Interface\\LFGFrame\\UI-LFG-ICONS-RoleBACKGROUNDS")
	AskFrame.DpsBg:SetTexCoord(GetBackgroundTexCoordsForRole("DAMAGER"))
	AskFrame.DpsBg:SetAllPoints(AskFrame.Dps)
	AskFrame.DpsBg:SetDrawLayer("BACKGROUND")
	AskFrame.DpsIcon = AskFrame.Dps:CreateTexture()
	AskFrame.DpsIcon:SetTexture("Interface\\LFGFrame\\UI-LFG-ICON-RoleS")
	AskFrame.DpsIcon:SetTexCoord(GetTexCoordsForRole("DAMAGER"))
	AskFrame.DpsIcon:SetPoint("TOPLEFT", AskFrame.Dps, "TOPLEFT", 15, -15)
	AskFrame.DpsIcon:SetPoint("BOTTOMRIGHT", AskFrame.Dps, "BOTTOMRIGHT", -15,15)
	AskFrame.Dps:Hide()

	AskFrame.Tank = CreateFrame("Button", nil, AskFrame)
	AskFrame.Tank:SetWidth(100)
	AskFrame.Tank:SetHeight(100)
	AskFrame.TankBg = AskFrame.Tank:CreateTexture()
	AskFrame.TankBg:SetTexture("Interface\\LFGFrame\\UI-LFG-ICONS-RoleBACKGROUNDS")
	AskFrame.TankBg:SetTexCoord(GetBackgroundTexCoordsForRole("TANK"))
	AskFrame.TankBg:SetAllPoints(AskFrame.Tank)
	AskFrame.TankBg:SetDrawLayer("BACKGROUND")
	AskFrame.TankIcon = AskFrame.Tank:CreateTexture()
	AskFrame.TankIcon:SetTexture("Interface\\LFGFrame\\UI-LFG-ICON-RoleS")
	AskFrame.TankIcon:SetTexCoord(GetTexCoordsForRole("TANK"))
	AskFrame.TankIcon:SetPoint("TOPLEFT", AskFrame.Tank, "TOPLEFT", 15, -15)
	AskFrame.TankIcon:SetPoint("BOTTOMRIGHT", AskFrame.Tank, "BOTTOMRIGHT", -15,15)
	AskFrame.Tank:Hide()

	AskFrame.YesButton = CreateFrame("Button", nil, AskFrame, "UIPanelButtonTemplate")
	AskFrame.YesButton:SetWidth(50)
	AskFrame.YesButton:SetHeight(30)
	AskFrame.YesButton:SetText("Yes")
	AskFrame.YesButton:SetPoint("BOTTOMLEFT", AskFrame, "BOTTOMLEFT", 60, 20)

	AskFrame.NoButton = CreateFrame("Button", nil, AskFrame, "UIPanelButtonTemplate")
	AskFrame.NoButton:SetWidth(50)
	AskFrame.NoButton:SetHeight(30)
	AskFrame.NoButton:SetText("No")

	AskFrame.DDHeal = CreateFrame("Frame", "GMEventHealDD", AskFrame, "UIDropDownMenuTemplate")
	AskFrame.DDHeal:SetPoint("BOTTOMLEFT", AskFrame, "BOTTOMLEFT", 60, 60)
	UIDropDownMenu_SetWidth(AskFrame.DDHeal, 60)
	UIDropDownMenu_SetButtonWidth(AskFrame.DDHeal, 50)

	AskFrame.CheckBox = CreateFrame("CheckButton", "GMEventCheckButton", AskFrame, "ChatConfigCheckButtonTemplate");
	AskFrame.CheckBox:SetSize(25, 25)

	AskFrame.ListFrame = CreateFrame("Frame", nil, AskFrame)
	AskFrame.ListFrame:SetAllPoints(AskFrame)
	AskFrame.List = {}
	
	local parent

	for i = 1, 10 do
		local button = CreateFrame("Button", "GMEventListbutton"..i, AskFrame.ListFrame, "WorldStateScoreTemplate")
		tinsert(AskFrame.List, button)
		button:SetPoint("LEFT", AskFrame.ListFrame, "LEFT", 15, 0)
		button:SetPoint("RIGHT", AskFrame.ListFrame, "RIGHT", -15, 0)
	
		if parent then
			parent = _G["GMEventListbutton"..(i-1)]
			button:SetPoint("TOP", parent, "BOTTOM", 0, -1)
		else
			button:SetPoint("TOP", AskFrame.ListFrame, "TOP", 0, -40)
			parent = button
		end
		local textureLeft = _G["GMEventListbutton"..i.."FactionLeft"]
		local textureRight = _G["GMEventListbutton"..i.."FactionRight"]
		textureLeft:SetAlpha(0.3)
		textureRight:SetAlpha(0.3)
		
		button.texts = {}
		button.texts[#button.texts+1] = button.name.text
		button.texts[#button.texts+1] = _G[button:GetName().."Column2Text"] 
		button.texts[#button.texts+1] = button.killlingBlows
		button.texts[#button.texts+1] = button.damage
		button.texts[#button.texts+1] = button.healing
		button.texts[#button.texts+1] = button.honorableKills
		button.texts[#button.texts+1] = _G[button:GetName().."Column1Text"]
		button.texts[#button.texts+1] = button.deaths
	
		button.texts[1]:SetText("Name "..i)
		--button:SetScript("OnMouseWheel", function(self, delta) delta = delta*16 Scroller:SetVerticalScroll(Scroller:GetVerticalScroll() + delta) GMInfoFrame_Update()  end)
			
		--button:SetScript("OnClick", function(self) if self:IsShown() then if GraphFrame:IsShown() then else GraphFrame:Show() GraphFrame.name = button.texts[1]:GetText() Graph_Update(GraphFrame.name) end end end)
				--button:Hide()
	end
	
	local offset = 0
	
	local function UpdateList()
		for i = 1, 10 do
			AskFrame.List[i]:Hide()
		end
		local j = 0
		for name, status in pairs(Queue) do
			j = j + 1
			local button = AskFrame.List[j]
			if button then
				button.texts[1]:SetText(name)
				button.texts[2]:SetText(status)
			
				button:Show()
			end

			if GMRoster[name] then
				local class = GMRoster[name].class
				local classColor = RAID_CLASS_COLORS[class];
				if classColor then
					button.texts[1]:SetTextColor(classColor.r, classColor.g, classColor.b);
				end
			end
			
			if status == "Pending" then
				button.texts[2]:SetTextColor(0, 0.7, 0)
			elseif status == "Invited" then
				button.texts[2]:SetTextColor(0, 1, 0)
			elseif status:find("^Decline") then
				button.texts[2]:SetTextColor(0.8, 0, 0)
			end
		end
	end
	
	
	
	local ListFrame = CreateFrame("Frame", nil, UIParent) --container for the list

	for i = 1, 6 do --create buttons for the ist frame


	end


	function AskFrame.DDHeal_Initialize(self, level)
		level = level or 1
		local info = UIDropDownMenu_CreateInfo()
		for i = 0, 10 do
			info = UIDropDownMenu_CreateInfo()
			info.notCheckable = true
			info.text = i
			info.value = i
			info.checked = nil
			info.func =  function(self) UIDropDownMenu_SetText(AskFrame.DDHeal, i)  end
			UIDropDownMenu_AddButton(info, level)
		end
	end

	UIDropDownMenu_Initialize(AskFrame.DDHeal, AskFrame.DDHeal_Initialize)
	UIDropDownMenu_SetText(AskFrame.DDHeal, 0, true)

	AskFrame.DDDps = CreateFrame("Frame", "GMEventDpsDD", AskFrame, "UIDropDownMenuTemplate")
	AskFrame.DDDps:SetPoint("TOPLEFT", AskFrame.DDHeal, "TOPRIGHT", 30, 0)
	UIDropDownMenu_SetWidth(AskFrame.DDDps, 60)
	UIDropDownMenu_SetButtonWidth(AskFrame.DDDps, 50)

	function AskFrame.DDDps_Initialize(self, level)
		level = 1
		local info = UIDropDownMenu_CreateInfo()
		for i = 0, 30 do
			info = UIDropDownMenu_CreateInfo()
			info.notCheckable = true
			info.text = i
			info.value = i
			info.checked = nil
			info.func =  function(self) UIDropDownMenu_SetText(AskFrame.DDDps, self.value, true)  end
			UIDropDownMenu_AddButton(info, level)
		end
	end
	UIDropDownMenu_Initialize(AskFrame.DDDps, AskFrame.DDDps_Initialize)
	UIDropDownMenu_SetText(AskFrame.DDDps, 0, true)

	AskFrame.DDTank = CreateFrame("Frame", "GMEventTankDD", AskFrame, "UIDropDownMenuTemplate")
	AskFrame.DDTank:SetPoint("TOPLEFT", AskFrame.DDDps, "TOPRIGHT", 30, 0)
	UIDropDownMenu_SetWidth(AskFrame.DDTank, 60)
	UIDropDownMenu_SetButtonWidth(AskFrame.DDTank, 50)

	function AskFrame.DDTank_Initialize()
		level = 1
		local info = UIDropDownMenu_CreateInfo()
		for i = 0, 5 do
			info = UIDropDownMenu_CreateInfo()
			info.notCheckable = true
			info.text = i
			info.value = i
			info.checked = nil
			info.func =  function(self) UIDropDownMenu_SetText(AskFrame.DDTank, self.value, true)  end
			UIDropDownMenu_AddButton(info, level)
		end
	end
	UIDropDownMenu_Initialize(AskFrame.DDTank, AskFrame.DDTank_Initialize)
	UIDropDownMenu_SetText(AskFrame.DDTank, 0, true)




	local function RoleButtonClick(self)
		if AskFrame.page == 1 then
			local value = UIDropDownMenu_GetText(AskFrame["DD"..self.name])
			UIDropDownMenu_SetText(AskFrame["DD"..self.name], value+1, true)
		elseif AskFrame.page == 2 then
			GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMEventAccept", "|ROLE|"..self.name}
			tinsert(GMaster.Timers, {runonce = true, interval = 5, elapsed = 0, func = AcceptGroup})
			tinsert(GMaster.Timers, {runonce = true, interval = 5.5, elapsed = 0, func = function() StaticPopup1:Hide() end})
			AskFrame:Hide()
		end
	end

	AskFrame.Heal.name = "Heal"
	AskFrame.Dps.name = "Dps"
	AskFrame.Tank.name = "Tank"



	local function SetAskFrame(page)
		if page == 1 then -- this is the page to create new events
			AskFrame.ListFrame:Hide()
		
			AskFrame:SetWidth(450)
			AskFrame:SetHeight(225)
			AskFrame:ClearAllPoints()
			AskFrame:SetPoint("CENTER")
			AskFrame.DDHeal:Show()
			AskFrame.DDDps:Show()
			AskFrame.DDTank:Show()
			-- if isingroup() then
			--	AskFrane.TitleText:SetText("You are currently grouped. To add more members, select the extra roles you need and click invite")
			--end
			AskFrame.TitleText:SetText("To create a new event, give it a meaningful name, choose the number of players required for each role, and press 'Invite.'")
			AskFrame.YesButton:SetText("Invite")
			AskFrame.YesButton:SetWidth(80)
			AskFrame.YesButton:SetPoint("BOTTOMLEFT", 140, 10)
			AskFrame.YesButton:Show()
			
			AskFrame.NoButton:Show()
			AskFrame.NoButton:SetText("Cancel")
			AskFrame.NoButton:ClearAllPoints()
			AskFrame.NoButton:SetPoint("TOPLEFT", AskFrame.YesButton, "TOPRIGHT", 5, 0)
			AskFrame.NoButton:SetWidth(80)
			
			AskFrame.EditBox:SetPoint("TOPLEFT", 55, -60)
			AskFrame.EditBox:Show()
			AskFrame.EditBox:SetText("[Type Event Name Here]")

			AskFrame.LevelBox:SetPoint("TOPLEFT", 30, -90)
			AskFrame.LevelBox:SetText("[Min Level]")
			AskFrame.LevelBox:Show()
			
			AskFrame.iLevelBox:SetPoint("TOPLEFT", 180, -90)
			AskFrame.iLevelBox:SetText("[Min item Lvl]")
			AskFrame.iLevelBox:Show()
			
			AskFrame.RessiBox:SetPoint("TOPLEFT", 320, -90)
			AskFrame.RessiBox:SetText("[Min Resi]")
			AskFrame.RessiBox:Show()
			
			AskFrame.Dps:SetSize(64, 64)
			AskFrame.Dps:ClearAllPoints()
			AskFrame.Dps:SetPoint("TOPRIGHT", AskFrame.DDDps, "TOPLEFT", 20, 20)
			AskFrame.DpsIcon:SetPoint("TOPLEFT", AskFrame.Dps, "TOPLEFT", 12, -12)
			AskFrame.DpsIcon:SetPoint("BOTTOMRIGHT", AskFrame.Dps, "BOTTOMRIGHT", -8,8)
			AskFrame.Dps:Show()
			
			AskFrame.Heal:SetSize(64, 64)
			AskFrame.Heal:ClearAllPoints()
			AskFrame.Heal:SetPoint("TOPRIGHT", AskFrame.DDHeal, "TOPLEFT", 20, 20)
			AskFrame.HealIcon:SetPoint("TOPLEFT", AskFrame.Heal, "TOPLEFT", 12, -12)
			AskFrame.HealIcon:SetPoint("BOTTOMRIGHT", AskFrame.Heal, "BOTTOMRIGHT", -8,8)
			AskFrame.Heal:Show()
			
			AskFrame.Tank:SetSize(64, 64)
			AskFrame.Tank:ClearAllPoints()
			AskFrame.Tank:SetPoint("TOPRIGHT", AskFrame.DDTank, "TOPLEFT", 20, 20)
			AskFrame.TankIcon:SetPoint("TOPLEFT", AskFrame.Tank, "TOPLEFT", 12, -12)
			AskFrame.TankIcon:SetPoint("BOTTOMRIGHT", AskFrame.Tank, "BOTTOMRIGHT", -8,8)
			AskFrame.Tank:Show()
		
			AskFrame.Heal:SetScript("OnClick", RoleButtonClick)
			AskFrame.Dps:SetScript("OnClick", RoleButtonClick)
			AskFrame.Tank:SetScript("OnClick", RoleButtonClick)
		
		elseif page == 2 then --this is the page to join new events
			AskFrame.ListFrame:Hide()
			AskFrame:SetSize(450, 200)
			AskFrame:ClearAllPoints()
			AskFrame:SetPoint("CENTER")
			AskFrame.TitleText:SetText((AskFrame.leader or "").." is starting an event: "..(AskFrame.event or "")..". \n Click your role or 'Decline' ")
			AskFrame.DDHeal:Hide()
			AskFrame.DDDps:Hide()
			AskFrame.DDTank:Hide()
			
			AskFrame.LevelBox:Hide()
			
			AskFrame.iLevelBox:Hide()
			
			AskFrame.RessiBox:Hide()
			
			
			AskFrame.Heal:SetScript("OnClick", RoleButtonClick)
			AskFrame.Dps:SetScript("OnClick", RoleButtonClick)
			AskFrame.Tank:SetScript("OnClick", RoleButtonClick)
			
			AskFrame.Heal:SetSize(64,64)
			AskFrame.Heal:ClearAllPoints()
			AskFrame.Heal:SetPoint("BOTTOMLEFT", AskFrame, "BOTTOMLEFT", 100, 80)
			AskFrame.Heal:Show()
			
			AskFrame.Dps:SetSize(64, 64)
			AskFrame.Dps:ClearAllPoints()
			AskFrame.Dps:SetPoint("TOPLEFT", AskFrame.Heal, "TOPRIGHT", 20, 0)
			AskFrame.Dps:Show()
			
			AskFrame.Tank:SetSize(64, 64)
			AskFrame.Tank:ClearAllPoints()
			AskFrame.Tank:SetPoint("TOPLEFT", AskFrame.Dps, "TOPRIGHT", 20, 0)
			AskFrame.Tank:Show()
			
			if AskFrame.numheal == 0 then
				AskFrame.Heal:Hide()
			end
			
			if AskFrame.numtank == 0 then
				AskFrame.Tank:Hide()
			end
			
			if AskFrame.numdps == 0 then
				AskFrame.Dps:Hide()
			end
			
			AskFrame.EditBox:ClearAllPoints()
			AskFrame.EditBox:SetPoint("CENTER", 0, -40)
			AskFrame.EditBox:Show()
			AskFrame.EditBox:SetText("[Insert optional decline reason here]")
			AskFrame.YesButton:Hide()
			AskFrame.NoButton:ClearAllPoints()
			AskFrame.NoButton:SetWidth(80)
			AskFrame.NoButton:SetPoint("BOTTOM", AskFrame, "BOTTOM", 0, 10)
			AskFrame.NoButton:SetText("Decline")
			AskFrame.NoButton:Show()
		elseif page == 3 then -- this page need to show the number of accepts/declines as they come in.
			AskFrame.ListFrame:Show()
		
			AskFrame:SetSize(450, 300)
			
			AskFrame.TitleText:SetText("Waiting for players")
			AskFrame.DDHeal:Hide()
			AskFrame.DDDps:Hide()
			AskFrame.DDTank:Hide()
			
			AskFrame.Heal:Hide()
			AskFrame.Dps:Hide()
			AskFrame.Tank:Hide()
			
			AskFrame.YesButton:Hide()
			AskFrame.EditBox:Hide()
			
			AskFrame.LevelBox:Hide()
			AskFrame.iLevelBox:Hide()
			AskFrame.RessiBox:Hide()
			
			AskFrame.NoButton:Show()
			AskFrame.NoButton:SetText("Close")
			AskFrame.NoButton:ClearAllPoints()
			AskFrame.NoButton:SetPoint("BOTTOMLEFT", 150, 10)
			AskFrame.NoButton:SetWidth(80)
			
		
			
			--idealy this needs to contain a scrollable dropdown, but thats a bit fancy
		end
	end

	
		local function ButtonHandler(self) --handles the commands for the yas and no buttons
		if AskFrame.page == 1 then --if they want to join the event		
			if self:GetText() == "Invite" then
				AskFrame.numdps = tonumber(UIDropDownMenu_GetText(AskFrame.DDDps))
				AskFrame.numheal = tonumber(UIDropDownMenu_GetText(AskFrame.DDHeal))
				AskFrame.numtank = tonumber(UIDropDownMenu_GetText(AskFrame.DDTank))
				
				AskFrame.healcount = 0
				AskFrame.dpscount = 0
				AskFrame.tankcount = 0
				
				AskFrame.event = AskFrame.EditBox:GetText()
				AskFrame.minres = tonumber(AskFrame.RessiBox:GetText()) 
				AskFrame.minilvl = tonumber(AskFrame.iLevelBox:GetText()) 
				AskFrame.minlvl = tonumber(AskFrame.LevelBox:GetText()) 
				
				local msg = "EVENT|"..AskFrame.event.."|DPS|"..AskFrame.numdps.."|HEAL|"..AskFrame.numheal.."|TANK|"..AskFrame.numtank
				
				if AskFrame.minres then
					msg = msg.."|RES|"..AskFrame.minres
				end
				if AskFrame.minilvl then
					msg = msg.."|iLVL|"..AskFrame.minilvl
				end
				if AskFrame.minlvl then
					msg = msg.."|LVL|"..AskFrame.minlvl
				end
				
				
				if AskFrame.event ~= "" and AskFrame.event ~= "[Type Event Name Here]" and string.len(AskFrame.event) > 5 then
					GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMEventNew", msg}
					AskFrame.TitleText:SetText("Waiting for players")
					SetAskFrame(3)
					AskFrame.page = 3
					IsLeader = true
				end
				
			elseif self:GetText() == "Cancel" then
				AskFrame:Hide()
			end
		elseif AskFrame.page == 2 then --second page, asking if dps or heal
			if self:GetText("Decline") then
				local reason = AskFrame.EditBox:GetText()
				if reason == "" or reason == "" or string.len(reason) < 5 then
					GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMEventBusy", ""}
				else
					GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMEventBusy", "REASON|"..reason}
				end
				
				tinsert(GMaster.Timers, {runonce = true, interval = 900, elapsed = 0, func = function() tempdisable = false end})
				AskFrame:Hide()
			end
		elseif AskFrame.page == 3 then
			if self:GetText() == "Close" then
				AskFrame:Hide()
			end
		end
	end

	AskFrame.YesButton:SetScript("OnClick", ButtonHandler)
	AskFrame.NoButton:SetScript("OnClick", ButtonHandler)

	local function AskCheck(event) --ask if they want to join the group
		AskFrame.event = event or ""
		AskFrame.page = 2
		SetAskFrame(2)
	end

	local function NewEvent()
		if AskFrame:IsShown() and AskFrame.page == 1 then
		
		else
			Queue = {}
			SetAskFrame(1)
			AskFrame.page = 1
			AskFrame:Show()
		end
	end

	function GMaster.CMA.EventCheck(prefix, msg, channel, player)
	
		if prefix == "GMEventNew" then
			if  player == GMaster.PlayerName then return end
		
			
			local ininst, instype = IsInInstance()
			if tempdisable then
				SendAddonMessage("GMEventBusy", "REASON| None", "GUILD")
			elseif ininst then 
				SendAddonMessage("GMEventBusy", instype, "GUILD")
			elseif GetNumRaidMembers() > 0 or GetNumPartyMembers() > 0 then
				SendAddonMessage("GMEventBusy", "Reason: Group", "GUILD")
			else
				
				local event, numdps, numheal, numtank = msg:match("EVENT|(.-)|DPS|(%d+)|HEAL|(%d+)|TANK|(%d+)")
				local ressi = tonumber(msg:match("|RES|(%d+)"))
				local ilvl = tonumber(msg:match("|iLVL|(%d+)"))
				local lvl = tonumber(msg:match("|LVL|(%d+)"))
				if event then
					if ressi or ilvl or lvl  then
						
						local pRes =  GetCombatRating(COMBAT_RATING_RESILIENCE_PLAYER_DAMAGE_TAKEN) --the players ressi
						local plevel = UnitLevel("player")
						local pilevel = floor(GetAverageItemLevel()+0.5)
						
						if ressi then
							if pRes >= ressi then
								--they can join
							else
								--they cant join!
								SendAddonMessage("GMEventBusy", "REASON| Crap Resi", "GUILD")
								return
							end
						end
						
						if ilvl then
							if pilevel >= ilvl then
								--they can join
							else
								--they cant join!
								SendAddonMessage("GMEventBusy", "REASON| Crap gear", "GUILD")
								return
							end
						end
						
						if lvl then
							if plevel >= lvl then
								--they can join
							else
								--they cant join!
								SendAddonMessage("GMEventBusy", "REASON| Too low", "GUILD")
								return
							end
						end
						
					end
					SendAddonMessage( "GMEventPending", "Pending", "GUILD") --insert resi
					
					AskFrame.event = event
					AskFrame.leader = player
					AskFrame.numheal = tonumber(numheal) or 0
					AskFrame.numdps = tonumber(numdps) or 0
					AskFrame.numtank = tonumber(numtank) or 0
					SetAskFrame(2)
					AskFrame.page = 2
					AskFrame:Show()
				end
			end
		elseif prefix == "GMEventBusy" then
			if IsLeader then
				if msg == "pvp" then
					Queue[player] = "Decline: In Battlground"
					UpdateList()
				elseif msg == "arena" then
					--they are in arena
					Queue[player] = "Decline: In Arena"
					UpdateList()
				elseif msg == "party" then
					--they are in an instance
					Queue[player] = "Decline: In Instance"
					UpdateList()
				elseif msg == "raid" then
					--they are raiding
				elseif msg:find("REASON|") then
					local reason = msg:match("REASON|(.+)")
					Queue[player] = "Decline: "..reason
					UpdateList()
				end
			end
		elseif prefix == "GMEventPending" then
			if not (player == GMaster.PlayerName)then
				--pull the ressi if needed
				--print("Recieved pending")
				Queue[player] = "Pending"
				UpdateList()
			end
		elseif prefix == "GMEventAccept" then
			local role = msg:match("|ROLE|(.+)")
			if IsLeader then
				if role then
					if role:find("Heal") then
						if AskFrame.healcount < AskFrame.numheal then
							if (AskFrame.healcount + AskFrame.dpscount + AskFrame.tankcount) == 5 then
								ConvertToRaid()
							end
							tinsert(GMaster.Timers, {runonce = true, interval = 3, elapsed = 0, func = InviteUnit, vars = {player}})
							
							Queue[player] = "Invited"
							UpdateList()
							AskFrame.healcount = AskFrame.healcount + 1
						else
							--send reply saying sorry, full up now
						end
					elseif role:find("Dps") then
						if AskFrame.dpscount < AskFrame.numdps then
							if (AskFrame.healcount + AskFrame.dpscount + AskFrame.tankcount) == 5 then
								ConvertToRaid()
							end
							tinsert(GMaster.Timers, {runonce = true, interval = 3, elapsed = 0, func = InviteUnit, vars = {player}})
							Queue[player] = "Invited"
							UpdateList()
							AskFrame.dpscount = AskFrame.dpscount + 1
						else
							--send reply saying sorry, full up now
						end
					elseif role:find("Tank") then
						if AskFrame.tankcount < AskFrame.numtank then
							if (AskFrame.healcount + AskFrame.dpscount + AskFrame.tankcount) == 5 then
								ConvertToRaid()
							end
							tinsert(GMaster.Timers, {runonce = true, interval = 3, elapsed = 0, func = InviteUnit, vars = {player}})
							Queue[player] = "Invited"
							UpdateList()
							AskFrame.tankcount = AskFrame.tankcount + 1
						else
							--send reply saying sorry, full up now
						end
					end
				end
			end
		end
	end
	function GMaster.GFL.GMEvent() --loads the event button
		if not GMSettings.modules.GMEvent then
			return
		end
		local Eventler = CreateFrame("Frame")

			Eventler:RegisterEvent("CHAT_MSG_ADDON")
			Eventler:SetScript("OnEvent", EventCheck)

		local button = CreateFrame("Button", nil, GuildFrame, "UIPanelButtonTemplate")
		module.button = button
				button:SetWidth(80)
				button:SetHeight(18)
				button:SetText("New Event")
				button:SetPoint("TOPRIGHT", GuildFrame, "TOPRIGHT", -25, -2)
				button:SetScript("OnClick", NewEvent)
				button:SetScript("OnEnter", function(self) GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
															GameTooltip:SetText("Find guild members for any event you would like")
											end)
				button:SetScript("OnLeave", function() GameTooltip:Hide() end)
				button:Show()
	end
end

function GMaster.ModuleSettings.GMEvent()

	
	--create settings page
	local parent = CreateFrame("Frame")
		parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
		parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
		parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
		parent.titleText:SetJustifyH("LEFT")
		parent.titleText:SetJustifyV("TOP")
		parent.titleText:SetText("GM-Event allows you to quickly create an event and invite other guild members based on certain criteria.\n"..
														"Currently you can invite based on level, item level, and resilience. Players that do not meet the criteria"..
														" or are busy (in an instance/bg/arena/etc) will not receive the invite.\n"..
														"There are no options as of yet, just click 'New Event' on the guild frame to get started")
	return parent
	
end

function GMaster.ModuleLoad.GMEvent()
	--enable the module
		GMaster.AL.GMEvent()
	if GMaster.GUILD_FRAME_LOADED then
		GMaster.GFL.GMEvent()
	else
		LoadAddOn("Blizzard_GuildUI")
	end

	
end

function GMaster.ModuleRemove.GMEvent()
	if module.button then
		module.button:Hide()
	end
	
	GMaster.CMA.EventCheck = function() end
	return true
end









--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Adds an in-game forum allowing players to communicate with one another without
	needing to be online at the same time.
--========================== 2. Details ===============================
	The forum is a reddit-style message board in that each reply is shown
	underneath the post it is a reply to.
	New topics on the front page must have titles, however replies can have replies without titles,
	whichever is inputted is shown as the title.
	Because of the style of the forum, deleting posts would mean that
	children of those posts would have to be deleted too. As a result, 
	deleting posts changes their content to "deleted" and greys them out, 
	leaving any undeleted child posts intact.
	There is currently no method of permanently deleting posts, 
	This would need to be stored server side somehow otherwise it will cause major headaches.
	

--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.52
fixed bug that hid the  rep bar.

1.4
	Topics can now be completely deleted.
	Guild Masters can delete all posts.
--========================== 5. To do =================================
	Priority: High
		Make replies properly delete.
		sticky posts.
		age limit of posts.
		
		Add Colors!
		convert gmfrequest to whisper
]]


--[[
Possible future plans:
	Polls
Sticky posts, etc:

need to properly check the way that the posts are sorted, in order to properly 
make the stickies higher up the list.

|cff66119d Test|r

--]]

GMaster.LoadOrder.GMForum = true

local module = {} 

function GMaster.AL.GMForum()
	if GMSettings.GMForum.Timing then
		tinsert(GMaster.Timers, {runonce = true, interval = 60, elapsed = 0, func = function()  GMSettings.GMForum.Timing = false end})
	end
			
	local ReplyTo -- the timestamp of the post
	local PlayerName = GMaster.PlayerName

	local FFrame = CreateFrame("Frame", "GuildForumFrame", UIParent)
			FFrame:Hide()
	local EditBoxInset = CreateFrame("Frame", nil, FFrame, "InsetFrameTemplate")
		EditBoxInset:SetPoint("TOP", FFrame, "BOTTOM")
		EditBoxInset:SetPoint("LEFT", FFrame, "LEFT")
		EditBoxInset:SetPoint("RIGHT", FFrame, "RIGHT", 18, 0)
		EditBoxInset:SetPoint("BOTTOM", FFrame, "BOTTOM", 0, -75)
		EditBoxInset:SetFrameStrata("HIGH")
			
	local TitleBoxInset = CreateFrame("Frame", nil, FFrame, "InsetFrameTemplate")
		TitleBoxInset:SetPoint("TOPLEFT", EditBoxInset, "BOTTOMLEFT", 60, 0)
		TitleBoxInset:SetPoint("BOTTOMRIGHT", EditBoxInset, "BOTTOMRIGHT", -110, -20)
		TitleBoxInset:SetFrameStrata("HIGH")
		TitleBoxInset:Hide()
			
		TitleBoxInset.TitleText = TitleBoxInset:CreateFontString(nil, "OVERLAY", "GameFontNormal")
		TitleBoxInset.TitleText:SetWidth(60)
		TitleBoxInset.TitleText:SetHeight(20)
		TitleBoxInset.TitleText:SetPoint("TOPRIGHT", TitleBoxInset, "TOPLEFT")
		TitleBoxInset.TitleText:SetText("Title:")
			
	local PostButton = CreateFrame("Button", nil, EditBoxInset, "UIPanelButtonTemplate")
		PostButton:SetText("Post")
		PostButton:SetWidth(100)
		PostButton:SetHeight(20)
		PostButton:SetPoint("BOTTOMRIGHT", EditBoxInset, "BOTTOMRIGHT", -5, -21)
			--]]
			
	local TitleContainer = CreateFrame("ScrollFrame", "ForumTitleFrame", FFrame, "HybridScrollFrameTemplate")
		TitleContainer:SetPoint("TOPLEFT", FFrame, "TOPLEFT", 0, -5)
		TitleContainer:SetHeight(300)
		--TitleContainer:SetPoint("BOTTOMRIGHT", FFrame, "BOTTOMRIGHT", -2, 5)

	local TitleContainerScroll = CreateFrame("Slider", "ForumTitleFrameScrollBar", TitleContainer, "HybridScrollBarTemplate")
		TitleContainerScroll:SetPoint("TOPLEFT", TitleContainer, "TOPRIGHT", 0, -12)
		TitleContainerScroll:SetPoint("BOTTOMLEFT", TitleContainer, "BOTTOMRIGHT", 0, 12)
		--TitleContainer:SetScrollChild(TitleContainerScroll)
			
	EditBoxInset:Hide()
	ForumEditBoxScroll = CreateFrame("ScrollFrame", "ForumEditBoxScroll", EditBoxInset, "UIPanelScrollFrameTemplate")

	ForumEditBoxScroll:SetPoint("TOPLEFT", EditBoxInset, "TOPLEFT", 10, -5)
	ForumEditBoxScroll:SetPoint("BOTTOMRIGHT", EditBoxInset, "BOTTOMRIGHT", -27, 3)


	ForumEditBox = CreateFrame("EditBox", "ForumEditBox", ForumEditBoxScroll)
	ForumEditBox:SetScript("OnEscapePressed", function(self) ToggleGuildFrame() end)
	ForumEditBox:SetWidth(450)
	ForumEditBox:SetHeight(85)
	ForumEditBox:SetMultiLine(true)
	ForumEditBox:SetFontObject(GameFontHighlight)
	ForumEditBoxScroll:SetScrollChild(ForumEditBox)
	
	TitleEditBox = CreateFrame("EditBox", "ForumTitleEditBox", ForumEditBoxScroll)
	TitleEditBox:SetScript("OnEscapePressed", function(self) self:ClearFocus() end)
	TitleEditBox:SetPoint("TOPLEFT", TitleBoxInset, "TOPLEFT", 3, 0)
	TitleEditBox:SetPoint("BOTTOMRIGHT", TitleBoxInset, "BOTTOMRIGHT", -3, 0)
	TitleEditBox:SetMultiLine(false)
	TitleEditBox:SetFontObject(GameFontHighlight)
	
	local NewTopic = CreateFrame("Button", nil, FFrame, "UIPanelButtonTemplate")
		NewTopic:SetText("New Topic")
		NewTopic:SetWidth(100)
		NewTopic:SetHeight(25)
		NewTopic:SetPoint("BOTTOMRIGHT", FFrame, "TOPRIGHT", -10, 5)
			
			
	local MsgFrame = CreateFrame("Frame", nil, FFrame)
		MsgFrame:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background", 
										edgeFile = "Interface/Tooltips/UI-Tooltip-Border", 
										tile = true, tileSize = 16, edgeSize = 16, 
										insets = { left = 4, right = 4, top = 4, bottom = 4 }})
		MsgFrame:SetBackdropColor(0,0,0,1);
		
		MsgFrame:SetPoint("TOPLEFT", FFrame, "TOPRIGHT", 25, -5)
		MsgFrame:SetPoint("BOTTOMLEFT", FFrame, "BOTTOMRIGHT", 25, 5)
		MsgFrame:SetWidth(300)
		MsgFrame:Hide()
		
		MsgFrame.Text = MsgFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
		MsgFrame.Text:SetPoint("TOPLEFT", MsgFrame, "TOPLEFT", 10, -10)
		MsgFrame.Text:SetPoint("BOTTOMRIGHT", MsgFrame, "BOTTOMRIGHT", -10, 30)
		MsgFrame.Text:SetJustifyH("LEFT")
		MsgFrame.Text:SetJustifyV("TOP")
	
	local ReplyButton = CreateFrame("Button", nil, MsgFrame, "UIPanelButtonTemplate")
		ReplyButton:SetText("Reply")
		ReplyButton:SetWidth(100)
		ReplyButton:SetHeight(20)
		ReplyButton:SetPoint("BOTTOMRIGHT", MsgFrame, "BOTTOMRIGHT", -5, -21)

												
	local EditButton = CreateFrame("Button", nil, MsgFrame, "UIPanelButtonTemplate")
		EditButton:SetText("Edit")
		EditButton:SetWidth(100)
		EditButton:SetHeight(20)
		EditButton:SetPoint("RIGHT", ReplyButton, "LEFT", -5, 0)
		EditButton:Hide()
			
	local parent
	
	local TopicPage = CreateFrame("Frame", nil, FFrame)
		TopicPage:SetAllPoints(FFrame)
		TopicPage.buttons = {}
	
	local Scroller = CreateFrame("ScrollFrame", "GMForumScrollFrame", FFrame, "FauxScrollFrameTemplate")
		Scroller:SetWidth(30)
		Scroller:SetHeight(300)
		Scroller:SetPoint("TOPRIGHT", FFrame, "TOPRIGHT", -5, 0)
		Scroller:Show()
	
	TopicPage:SetScript("OnShow", Forum_Update)
	

		local button
			
			local TopicTable = {}
			--add hem if its open
			
			local function AddChild(dated, level)
				local self = GMForum[dated]
				self.level = level
				if self.children and self.open and not (self.msg == "DELETE") then
					TopicTable[#TopicTable +1 ] = self
					for child, v in pairs(self.children) do
						AddChild(child, (level+1))
					end
				elseif not (self.msg == "DELETE") then
					self.dated = dated
					TopicTable[#TopicTable +1 ] = self
				end
			end
			
			local function Forum_Update() --called whenever a message is recieved, its opened, scrollbar is moved
			
				TopicTable = {}

					--find all children
					table.sort(GMForum, function(a, b) return a > b end)
					
					for dated, info in pairs(GMForum) do
						if info.replyto > 1 then --its a reply
							if not GMForum[info.replyto] then
									return
									--this means it doesnt have the parent for some reason
									--need to do something about it!
							end
						
							if not GMForum[info.replyto].children then
								GMForum[info.replyto].children = {}
							end
							if not GMForum[info.replyto].children[dated] then
								GMForum[info.replyto].children[dated] = true
							end
							
							--info.level = GMForum[info.replyto].level + 1
						else
							--info.level = 1
						end
					end
					
					for dated, info in pairs(GMForum) do
						if info.replyto < 1 and not (info.msg == "DELETED" )then
							info.level = 1
							AddChild(dated, 1)
						end
					end
					local offset = 0
					
				FauxScrollFrame_Update(Scroller, #TopicTable, 16, 16)
					
				offset = FauxScrollFrame_GetOffset(Scroller)
				
				
				for index = 1, #TopicPage.buttons do
				local i = index + offset
						button = TopicPage.buttons[index]
				if not button then 
					return
				end
					if TopicTable[i] then
					local info = TopicTable[i]
							
							
							
							if TopicTable[i].title == "" then
								button.string1:SetText(TopicTable[i].msg)	
							else
								button.string1:SetText(TopicTable[i].title)	
							end
											
							
						if info.level == 1 then
							button.icon:SetPoint("LEFT", button, "LEFT", 10, 0)
						
							button.string1:SetWidth(200)
							button.string1:SetTextColor(1,1,0.3)
							--button.string1:SetWidth(300)
							button.left:SetTexture()
							button.left:Show()
							button.right:Show()
							button.middle:Show()
							button.left:SetTexture("Interface\\Buttons\\CollapsibleHeader")
							--button.texture:SetTexture("Interface\\TokenFrame\\UI-TokenFrame-CategoryButton")
							
							button.texture:Show()
						else
							button.left:Hide()
							button.right:Hide()
							button.middle:Hide()
							button.string1:SetTextColor(1,1,1)
							button.string1:SetWidth(150)
							button.icon:SetPoint("LEFT", button, "LEFT", 15 + (info.level * 10), 0)
							--button.string1:SetWidth(300 -(info.level * 10))
							button.texture:SetTexture("Interface\\GuildFrame\\GuildFrame")
							--button.texture:Hide()
						end
						
							if TopicTable[i].msg == "DELETED" then
								button.string1:SetText("[Deleted]")
								button.string1:SetTextColor(0.6, 0.6, 0.6)
							end	
							
							if info.children then
								button.icon:Show()
							else
								button.icon:Hide()
							end
							
								
							button.string2:SetText(TopicTable[i].name)
							if TopicTable[i].name == GMaster.PlayerName or IsGuildLeader() then
								button.delete:Show()
							else
								button.delete:Hide()
							end
							
							button.tooltip = TopicTable[i].msg
							--change to suit new purpose
							local dated = date("%H:%M %d-%m", TopicTable[i].dated)
							
							button.string3:SetText(dated)
							button.id = TopicTable[i].dated
							button.replyto = TopicTable[i].replyto
							
							if GMRoster[TopicTable[i].name] then --if the person is still in the guild
								local class = GMRoster[TopicTable[i].name].class
								local classColor = RAID_CLASS_COLORS[class];
								if class then
									button.string2:SetTextColor(classColor.r, classColor.g, classColor.b);
								end
							else 
								--tremove(GMForum, i)
								--Forum_Update()
							end
							
						if TopicTable[i].msg == "DELETED" and not info.children then
							--button:Hide()
							--offset = offset -1
						else
							button:Show()
						end
					else
							button.string1:SetText("")		
							button.string2:SetText("")
							button.string3:SetText("")
							button.texture:Hide()
							button:Hide()
					end
				end
			end

			Scroller:SetScript("OnVerticalScroll", function(self, value) FauxScrollFrame_OnVerticalScroll(self, value, 16, Forum_Update)  end)
			
			
			
				PostButton:SetScript("OnClick", function() 
														if GMSettings.GMForum.Timing and (ReplyTo == 0) then
															ForumTitleEditBox:SetText("You cannot make a new topic for 10 minutes!")
														else
															if ForumTitleEditBox:GetText() == "" and (ReplyTo ==0) then
																ForumTitleEditBox:SetText("Please Set a Title!")
															else
																if ForumEditBox:GetText() == "" then
																	ForumEditBox:SetText("Please write a message here")
																else
																	local dated
																	if EditButton.clicked then
																		dated = EditButton.id
																		ReplyTo = GMForum[dated].replyto
																		
																	else
																		dated = time()
																	end
																	
																	local msg = ""
																	msg = dated.."-"..ReplyTo.."|title"..ForumTitleEditBox:GetText()
																	GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFnew", msg}
																	
																	local str = ForumEditBox:GetText()
																	while str:sub(1, 200) ~= "" do
																		msg = dated.."-"..ReplyTo.."|msg"..str:sub(1,200)
																	   str = str:sub(201)
																	   GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFnew", msg}
																	end
																	
																	GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFnew", (dated.."-"..ReplyTo.."|&&&&")}
																	
																	Forum_Update()
																	if ReplyTo == 0 then
																		tinsert(GMaster.Timers, {runonce = true, interval = 600, elapsed = 0, func = function()  GMSettings.GMForum.Timing = false end})
																		GMSettings.GMForum.Timing = true
																	end
																	
																	ForumEditBox:SetText("") --clear everything
																	ForumTitleEditBox:SetText("")
																	GuildFrameInset:SetPoint("BOTTOMRIGHT", -25, 5);
																	EditBoxInset:Hide() 
																	TitleBoxInset:Hide()
																	MsgFrame:Hide()
																end
															end
														end
											end)
											
	function GMaster.GFL.GMForum()
		
			
			if ( GetGuildLevelEnabled() ) then
				GuildFrameTab1:SetPoint("TOPLEFT", GuildFrame, "BOTTOMLEFT", -10, 0)
			end
			FFrame:SetParent(GuildFrame)
			FFrame:SetPoint("TOPLEFT", GuildFrameInset, "TOPLEFT")
			FFrame:SetPoint("BOTTOMRIGHT", GuildFrameInset, "BOTTOMRIGHT")
			GuildFrame_RegisterPanel(FFrame) --adds the panel into teh list of panels
			
			NewTopic:SetScript("OnMouseUp", function(self) if self.active then
																GuildFrameInset:SetPoint("BOTTOMRIGHT", -25, 5);
																EditBoxInset:Hide() 
																TitleBoxInset:Hide()
																self.active = nil 
															else
																 GuildFrameInset:SetPoint("BOTTOMRIGHT", -25, 100);
																EditBoxInset:Show()
																TitleBoxInset:Show()
																ReplyTo = 0
																self.active = true
															end
														end)
			
			local ChatButton = CreateFrame("BUTTON", "GuildFrameTab6", GuildFrame, "CharacterFrameTabButtonTemplate")
			module.ChatButton = ChatButton
			ChatButton:SetText("Forum")
			ChatButton:SetPoint("LEFT", GuildFrameTab5, "RIGHT", -15, 0)
			ChatButton:SetID(6)
			
			PanelTemplates_SetNumTabs(GuildFrame, 6); --chaneg the number of tabs the guild pane has

			HybridScrollFrame_CreateButtons(TitleContainer, "GuildRosterButtonTemplate", 8, 0, "TOPLEFT", "TOPLEFT", 0, 0, "TOP", "BOTTOM");
			
			for i = 1, 16 do
			
				local button = CreateFrame("Button", "ForumFrameButton"..i, TopicPage, "GuildRosterButtonTemplate")
				
				local border = _G[button:GetName().."BarTexture"]
				border:Hide()
				
				button.texture = _G[button:GetName().."Stripe"]
				
				local Icon = _G[button:GetName().."Icon"]
				Icon:SetTexture("Interface\\Buttons\\UI-PlusMinus-Buttons")
				Icon:ClearAllPoints()
				Icon:SetHeight(10)
				Icon:SetWidth(10)
				Icon:SetPoint("LEFT", button, "LEFT")
				Icon:SetDrawLayer("OVERLAY")
				--Icon:Hide()
				button.icon = Icon
				
				button.left = button:CreateTexture()
				button.left:SetTexture("Interface\\Buttons\\CollapsibleHeader")
				button.left:SetTexCoord(0.17578125, 0.47265625, 0.29687500, 0.54687500)
				button.left:SetWidth(76)
				button.left:SetHeight(button:GetHeight())
				button.left:SetPoint("LEFT", button, "LEFT", 5, 0)
				
				button.right = button:CreateTexture()
				button.right:SetTexture("Interface\\Buttons\\CollapsibleHeader")
				button.right:SetTexCoord(0.17578125, 0.47265625, 0.01562500, 0.26562500)
				button.right:SetWidth(76)
				button.right:SetHeight(button:GetHeight())
				button.right:SetPoint("RIGHT", button, "RIGHT", -5, 0)
				
				button.middle = button:CreateTexture()
				button.middle:SetTexture("Interface\\Buttons\\CollapsibleHeader")
				button.middle:SetTexCoord( 0.48046875, 0.98046875, 0.01562500, 0.26562500)
				button.middle:SetWidth(76)
				button.middle:SetHeight(button:GetHeight())
				button.middle:SetPoint("LEFT", button.left, "RIGHT", -20, 0)
				button.middle:SetPoint("RIGHT", button.right, "LEFT", 20, 0)
				
				button.string1:SetPoint("LEFT", button.icon, "RIGHT", 5, 0)
				button.string1:SetWidth(150)
				button.string1:SetJustifyH("LEFT")
				button.string1:Show()
				
				button.string2:SetPoint("LEFT", button.string1, "RIGHT", 5, 0)
				button.string2:SetWidth(70)
				button.string2:SetJustifyH("LEFT")
				button.string2:Show()
				
				button.string3:SetPoint("LEFT", button.string2, "RIGHT")
				button.string3:SetWidth(100)
				button.string3:SetJustifyH("LEFT")
				button.string3:Show()
				button.icon:SetTexCoord(0, 0.4375, 0, 0.4375);
				
				button:SetHeight(20)
				button:SetPoint("LEFT", TopicPage, "LEFT")
				button:SetPoint("RIGHT", TopicPage, "RIGHT")
				
				button.delete = CreateFrame("Button", nil, button)
				button.delete:SetHeight(15)
				button.delete:SetWidth(15)
				button.delete:SetPoint("RIGHT", button, "RIGHT", -7, 0)
				button.delete:SetNormalTexture("Interface\\Buttons\\UI-GroupLoot-Pass-Up")
				button.delete:SetPushedTexture("Interface\\Buttons\\UI-GroupLoot-Pass-Down")
				button.delete:SetHighlightTexture("Interface\\Buttons\\UI-GroupLoot-Pass-Highlight")
				button.delete:SetScript("OnMouseUp", function(self)
																					local button = self:GetParent()
																					local msg = button.id.."-"..button.replyto.."|msgDELETED|&&&&"
																					GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFnew", msg}
																		end)
																		
				if parent then
					parent = _G["ForumFrameButton"..(i-1)]
					button:SetPoint("TOP", parent, "BOTTOM", 0, -2)
				else
					button:SetPoint("TOP", FFrame, "TOP")
					parent = button
				end
					
				button:SetScript("OnClick", function(self) 
												if GMForum[self.id].open then 
													GMForum[self.id].open = false 
													MsgFrame:Hide()
													EditButton:Hide()
													button.icon:SetTexCoord(0, 0.4375, 0, 0.4375);
					
												else 
													GMForum[self.id].open = true 
													MsgFrame.Text:SetText(self.tooltip)
													MsgFrame:Show()
													ReplyTo = self.id
													button.icon:SetTexCoord(0.5625, 1, 0, 0.4375);
													if GMForum[self.id].name == GMaster.PlayerName then
														ReplyButton.id = self.id
														EditButton.id = self.id
														EditButton.clicked = false
														EditButton:Show()
													else
														EditButton:Hide()
													end
												end 
												Forum_Update() 
											end)
											
						button:SetScript("OnShow", function(self) 
												Forum_Update()
												if GMForum[self.id] then
													if GMForum[self.id].open then 
														button.icon:SetTexCoord(0.5625, 1, 0, 0.4375);
													else 
														button.icon:SetTexCoord(0, 0.4375, 0, 0.4375);	
													end 
												end
											end)
											
				button:SetScript("OnEnter", function(self) GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
															GameTooltip:SetText(self.tooltip)
											end)
				button:SetScript("OnLeave", function() GameTooltip:Hide() end)
				
				
				button:Show()
				tinsert(TopicPage.buttons, button)
				
			end
			EditButton:SetScript("OnClick", function(self) 	
															if self.id then
																if GMForum[self.id] then
																self.clicked = true
																	ForumTitleEditBox:SetText(GMForum[self.id].title)
																	ForumEditBox:SetText(GMForum[self.id].msg)
																		 GuildFrameInset:SetPoint("BOTTOMRIGHT", -25, 100);
																EditBoxInset:Show()
																TitleBoxInset:Show()
																end
															end
														end)
														
			ChatButton:SetScript("OnClick", function(self) PanelTemplates_Tab_OnClick(self, GuildFrame)
															GuildFrame_TabClicked(self) end)
			ChatButton:Show()
			
					ReplyButton:SetScript("OnMouseUp", function(self) if self.active then
																GuildFrameInset:SetPoint("BOTTOMRIGHT", -25, 5);
																EditBoxInset:Hide() 
																TitleBoxInset:Hide()
																self.active = false
															else
																 GuildFrameInset:SetPoint("BOTTOMRIGHT", -25, 100);
																EditBoxInset:Show()
																TitleBoxInset:Show()
																
															end
														end)
			local function GuildTabButtonClicked(self)
				local tabIndex = self:GetID();
				if self:GetID() == 6 then
					
				
					GuildViewLogButton:Hide()
					GuildControlButton:Hide()
					GuildAddMemberButton:Hide()
					--GuildFactionBar:Hide()
					GuildFrameInset:Show()
					
					ButtonFrameTemplate_ShowButtonBar(GuildFrame);
					  GuildFrame_ShowPanel("GuildForumFrame");
					  GuildFrameInset:ClearAllPoints()
					  GuildFrameInset:SetPoint("TOPLEFT", 4, -60);
					  if NewTopic.active then
						 GuildFrameInset:SetPoint("BOTTOMRIGHT", -25, 100);
					  else
						GuildFrameInset:SetPoint("BOTTOMRIGHT", -25, 5);
					  end
				end
			end
			hooksecurefunc("GuildFrame_TabClicked", GuildTabButtonClicked)
		end
	

	--=============================== Sycing Stuff ==============================================
	--=======================================================================================

	local temptable = {}

	function GMaster.CMA.ForumMsg(prefix, msg, channel, player)
		if prefix == "GMFnew" then --its a new message from someone online
		
		local dated, replyto = msg:match("^(%d+)-(%d+)|")
		
			dated = tonumber(dated)
			replyto = tonumber(replyto)
			if not temptable[dated] then
				temptable[dated] = {title = "", message = ""}
			end
			
			if msg:find("|title") then
				temptable[dated].title = temptable[dated].title..msg:match("|title(.*)")
			end
			if msg:find("|msg") then
				temptable[dated].message = temptable[dated].message..msg:match("|msg(.+)")
			end
			if msg:find("&&&&$") then
				if msg:find("msgDELETED") then
					GMForum[dated] = nil
					GMForum[dated] = {replyto = replyto, title = "", msg = "DELETED", name = player}
				else
					if GMForum[dated] then
						GMForum[dated].msg = temptable[dated].message
						GMForum[dated].title = temptable[dated].title
						GMForum[dated].edited = time()
					else
						GMForum[dated] = {replyto = replyto, title = temptable[dated].title, msg = temptable[dated].message, name = player}
					end
				end
				Forum_Update()
				temptable[dated] = nil
			end
		elseif prefix == "GMFBroadcast" then
			if not (player == PlayerName) then
				local dated, replyto = msg:match("^(%d+)-(%d+)|")
				local deleted = msg:match("|DELETED")
				local edited = msg:match("|e(%d+)")
				edited = tonumber(edited)
				dated = tonumber(dated)
				replyto = tonumber(replyto)
				if deleted then
					GMForum[dated] = {replyto = replyto, title = "", msg = "DELETED", name = ""}
				else
					if GMForum[dated] then
						if GMForum[dated].edited and edited then
							if tonumber(GMForum[dated].edited) > edited then
								GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFBroadcast", dated.."-"..GMForum[dated].replyto.."|e"..GMForum[dated].edited}
							elseif tonumber(GMForum[dated].edited) < edited then
								GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFRequest"..player, dated}
							end
						else
							GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFRequest"..player, dated}
						end
					else
						GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFRequest"..player, dated}
					end
				end
			end
		elseif prefix:find("^GMFSend"..PlayerName) then

			local dated, replyto = msg:match("^(%d+)-(%d+)|")
					dated = tonumber(dated)
					replyto = tonumber(replyto)
					if not temptable[dated] then
						temptable[dated] = {title = "", message = ""}
					end
					
					if msg:find("|title") then
						temptable[dated].title = temptable[dated].title..msg:match("|title(.-)|")
					end
					
					if msg:find("|name") then
						temptable[dated].name = msg:match("|name(.-)|")
					end
					if msg:find("|msg") then
						temptable[dated].message = temptable[dated].message..msg:match("|msg(.+)")
					end
					if msg:find("|e%d+") then
						temptable[dated].edited = msg:match("|e(%d+)")
					end
					if msg:find("&&&&$") then
						if GMForum[dated] then
							GMForum[dated].message = temptable[dated].msg
							GMForum[dated].title = temptable[dated].title
							GMForum[dated].edited = tonumber(temptable[dated].edited)
						else
							GMForum[dated] = {replyto = replyto, title = temptable[dated].title, msg = temptable[dated].message, name = temptable[dated].name}
						end
						temptable[dated] = nil
					end
			
			
			
		elseif prefix:find("^GMFRequest"..PlayerName) then
			--send the table
			msg = tonumber(msg)
			local send
			
			if GMForum[msg] then
				if GMForum[msg].edited then
					send = msg.."-"..GMForum[msg].replyto.."|title"..GMForum[msg].title.."|name"..GMForum[msg].name.."|e"..GMForum[msg].edited
				else
						send = msg.."-"..GMForum[msg].replyto.."|title"..GMForum[msg].title.."|name"..GMForum[msg].name.."|"
				end
				GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFSend"..player, send}
			
				local str = GMForum[msg].msg
				
				while str:sub(1, 200) ~= "" do
					send = msg.."-"..GMForum[msg].replyto.."|msg"..str:sub(1,200)
				   str = str:sub(201)
				   
				   GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFSend"..player, send}
				end
				
				GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFSend"..player, (msg.."-"..GMForum[msg].replyto.."|&&&&")}

			end
			
		end
	end

	function GMaster.PEW.ForumBroadcast() --should move this to AL really
		if GMaster.LastLogin < (time() - 3600) then
			if GMForum then
				for dated, info in pairs(GMForum) do --broadcast all know forum message dates
					if info.msg == "DELETED" then
						GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFBroadcast", dated.."-"..info.replyto.."|DELETED"}
					elseif info.edited then
						GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFBroadcast", dated.."-"..info.replyto.."|e"..info.edited}
					else
						GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMFBroadcast", dated.."-"..info.replyto.."|"}
					end
				end
			end	
		end
	end
end

function GMaster.ModuleSettings.GMForum()
--create settings page
	local parent = CreateFrame("Frame")
		parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
		parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
		parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
		parent.titleText:SetJustifyH("LEFT")
		parent.titleText:SetJustifyV("TOP")
		parent.titleText:SetText("GM-Forum adds a small forum to the guild frame, allowing you to communicate with players that aren't online.\n ")
	return parent


end

function GMaster.ModuleLoad.GMForum()
	--enable the module
	GMaster.AL.GMForum()
	if GMaster.GUILD_FRAME_LOADED then
		GMaster.GFL.GMForum()
	else
		LoadAddOn("Blizzard_GuildUI")
	end
	
	
	
end

function GMaster.ModuleRemove.GMForum()
	if module.ChatButton then
		module.ChatButton:Hide()
	end
	if GuildFrame_TabClicked then
	GuildFrame_TabClicked(GuildFrameTab1);
	end
	
	return true
end


--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Adjusts the layout of the guild frame for more direct access to certain 
	features and information.
--========================== 2. Details ===============================
	Guild message of the day and events are moved to the first page, as well as
	the Add Member, View Log, and guild control buttons for guild masters.
	Guild rewards and guild perks are now both shown under the "Rewards" tab.
	Some extra info is shown under the "Info" tab.
	
	A "kill chat" button has been added to the guild control page. This will temporarily block all 
	guild chat, in case of arguements etc.
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
2.0
	Lots of small fixes to do with the new patch

1.6
	Fixed issue with rewards frame cuasing an error on mouseover for level 1 guilds.

1.5
	Fixed a bug due to the recent interface changes,
	Brought back the info window. This will be used to show/edit the guild information,
	and also show some other stats about the guild.
- 1.47
	Added a button in guild control to temporarily suspend all guild chat.
	Rewards now show properly
	guild masters can delete all posts
	some posts can be properly deleted
--========================== 5. To do =================================
	 fix the reward showing when the forum shows.
	Move the guild control button to the roster frame.
	Bring the info frame back in and add some guild stats:
	average level
	number of 85's
	number of each class.
	
	Get the Invite Request working.
	
	BUG:
	rep bar doesnt show back up again after moving to forum
	
]]

--[[ 
Future plans:
More info on the info page, summary of stats collected by the addon.
--]]


GMaster.LoadOrder.GMGuildFrame = true

function GMaster.AL.GMGuildFrame()
	function GMaster.GFL.GMGuildFrame()
		
		--move the first tab allong a bit		
		GuildFrameTab1:SetPoint("TOPLEFT", GuildFrame, "BOTTOMLEFT", -5, 0) 
		
		local Settings = GMSettings.modules.GMGuildFrame
		if not Settings.PageWidths then
				Settings.PageWidths = {}
		end
		--=================== Adds a button to temporarily block guild chat. =======================
		--===================================================================================================
		
		local function KillGuildChat(self)
			if self.active then
				self.active = nil
				self:SetText("Kill Chat")
				SendChatMessage("[GMS:] Guild Chat Active.", "GUILD")
				for i = 2, GuildControlGetNumRanks() do
					GuildControlSetRank(i)
					GuildControlSetRankFlag(2, true)
					GuildControlSaveRank()
				end
			else
				self.active = true
				self:SetText("Activate Chat")
				SendChatMessage("[GMS:] Guild Chat Locked.", "GUILD")
				for i = 2, GuildControlGetNumRanks() do
					GuildControlSetRank(i)
					GuildControlSetRankFlag(2, false)
					GuildControlSaveRank()
				end
			end
		end
		
		local killguild = CreateFrame("Button", nil, GuildFrame, "UIPanelButtonTemplate")
		killguild:SetSize(100, 25)
		killguild:SetText("Kill Chat")
		
		killguild:SetScript("OnClick", KillGuildChat)
		
		killguild:SetParent(GuildControlUI)
		killguild:SetPoint("TOPLEFT", 20, -20)
		
		--================================================================================================
			
			--static settings
			
		if GuildFrameTab6 then -- since this runs after the forum, it should move the forum tab.
			GuildFrameTab6:SetPoint("LEFT", GuildFrameTab5, "RIGHT", -15, 0)
		end
		
		function GuildFrame_Toggle() --make sure we hide the tabs we dont want.
			if ( GuildFrame:IsShown() ) then
				HideUIPanel(GuildFrame);
			else
				ShowUIPanel(GuildFrame);
				GuildFrameTab3:Hide()
				GuildFrameTab4:SetPoint("LEFT", GuildFrameTab2, "RIGHT", -15, 0)
			end
		end
		
		function GuildFrame_UpdateFaction() --replace the blizz function to change the text formatting
			local factionBar = GuildFactionFrame;
			local gender = UnitSex("player");
			local name, description, standingID, barMin, barMax, barValue, _, _, _, _, _, _, _, repToCap, weeklyCap = GetGuildFactionInfo();
			local factionStandingtext = GetText("FACTION_STANDING_LABEL"..standingID, gender);
			--Normalize Values
			barMax = barMax - barMin;
			barValue = barValue - barMin;
			GuildFactionBarLabel:SetText(barValue.." / "..barMax.."  "..factionStandingtext);
			GuildFactionFrameStanding:SetText(factionStandingtext);
			GuildBar_SetProgress(GuildFactionBar, barValue, barMax, repToCap or 0);
		end
			
				
				
			
		--move the faction bar
		GuildFactionFrame:ClearAllPoints() 
		GuildFactionFrame:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 58, -3)
		GuildFactionFrame:SetWidth(182)
		GuildFactionFrameStanding:Hide() --hide the faction text
		
		
		
		GuildFrameTitleText:Hide() -- hide the title text (people generally know the name of their own guild)
		GuildFactionFrameHeader:Hide()
		GuildXPFrameLevelText:Hide() --hide the level text(its already written on the tabard)
		GuildXPBar:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 70, -30)
		GuildFrameTab3:Hide()
		
		GuildViewLogButton:SetParent(GuildFrame)
	--[[
		GuildViewLogButton:ClearAllPoints()
		GuildViewLogButton:SetSize(25, 80)
		GuildViewLogButton:SetPoint("LEFT", GuildAddMemberButton, "RIGHT")
	--]]
		GuildAddMemberButton:SetParent(GuildFrame)
		
		GuildControlButton:SetParent(GuildFrame)
		
		GuildFactionFrame:Show();
		GuildFactionFrame:ClearAllPoints() 
		GuildFactionFrame:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 58, -3)
		GuildFactionFrame:SetWidth(182)
			
			--===============================================================================
			--===============================================================================
			
			GuildRoster()
			
			--===============================================================================

			
			
			local header1 = CreateFrame("Frame", nil, GuildFrame)
						header1:SetAllPoints(GuildFrameInset)
			header1.text = header1:CreateFontString(nil, "ARTWORK", "GameFontNormal")
			
			header1.text:SetPoint("TOPLEFT", 10, -3)
			header1.text:SetPoint("BOTTOMRIGHT", header1, "TOPRIGHT", 0, -20)
			header1.text:SetJustifyH("LEFT")
			
			header1.background = header1:CreateTexture()
			header1.background:SetTexture("Interface\\GuildFrame\\GuildFrame")
			header1.background:SetTexCoord(0.00097656, 0.31445313, 0.00195313, 0.59765625)
			header1.background:SetPoint("TOPLEFT", 3, -3)
			header1.background:SetDrawLayer("BACKGROUND")
			header1.background:SetPoint("BOTTOMRIGHT", header1, "BOTTOMRIGHT", -3, 3)
			
			header1.bar = header1:CreateTexture()
			header1.bar:SetTexture("Interface\\GuildFrame\\GuildFrame")
			header1.bar:SetTexCoord(0.00097656, 0.31445313, 0.93164063, 0.97460938)
			header1.bar:SetPoint("TOPLEFT", 3, -2)
			header1.bar:SetDrawLayer("ARTWORK")
			header1.bar:SetPoint("BOTTOMRIGHT", header1, "TOPRIGHT", -3, -22)
			
			local header2 = CreateFrame("Frame", nil, GuildFrame)
			header2.text = header2:CreateFontString(nil, "ARTWORK", "GameFontNormal")
			
			header2.text:SetPoint("TOPLEFT", 10, -5)
			header2.text:SetPoint("BOTTOMRIGHT", header2, "TOPRIGHT", 0, -20)
			header2.text:SetJustifyH("LEFT")
			
			header2.background = header2:CreateTexture()
			header2.background:SetTexture("Interface\\GuildFrame\\GuildFrame")
			header2.background:SetTexCoord(0.00097656, 0.31445313, 0.00195313, 0.59765625)
			header2.background:SetPoint("TOPLEFT", 3, -3)
			header2.background:SetDrawLayer("BACKGROUND")
			header2.background:SetPoint("BOTTOMRIGHT", header2, "BOTTOMRIGHT", -3, 3)
			
			header2.bar = header2:CreateTexture()
			header2.bar:SetTexture("Interface\\GuildFrame\\GuildFrame")
			header2.bar:SetTexCoord(0.00097656, 0.31445313, 0.93164063, 0.97460938)
			header2.bar:SetPoint("TOPLEFT", 3, -3)
			header2.bar:SetDrawLayer("ARTWORK")
			header2.bar:SetPoint("BOTTOMRIGHT", header2, "TOPRIGHT", -3, -25)
		
			CreateFrame("Frame", "GMForumInset", GuildFrame, "InsetFrameTemplate")
			header2:SetAllPoints(GMForumInset)
		
		
			local StatsPage = CreateFrame("Frame", nil, GuildFrame)
			StatsPage:SetAllPoints(GuildFrame)
		
			local MainPage = CreateFrame("Frame", nil, GuildFrame)
						MainPage:SetAllPoints(GuildFrame)
						
						GuildNewsContainer:SetParent(MainPage)
						
	MainPage:SetScript("OnShow", function(self) --when the page is shown
		
		GuildInfoEvents_Update()
				
		if CanEditGuildEvent() then
			GuildInfoEditEventButton:ClearAllPoints()
			GuildInfoEditEventButton:SetParent(MainPage)
			GuildInfoEditEventButton:SetPoint("TOPRIGHT", header2, "TOPRIGHT",  -10, -5)
			GuildInfoEditEventButton:SetHeight(15)
			GuildInfoEditEventButton:SetWidth(100)
			GuildInfoEditEventButton:Show()
		else
			GuildInfoEditEventButton:Hide()
		end
					
				--show:
				GuildViewLogButton:Show()
				
				GMForumInset:Show()
				header1:Show()
				header2:Show()
				GuildInfoMOTD:Show()
				GuildNewsFrame:Show()
				GuildFrameInset:Show()
								
				--hide
				GuildPerksToggleButton:Hide()
				GuildNextPerkButton:Hide()
				GuildLatestPerkButton:Hide()
				GuildAllPerksFrame:Hide()
				GuildInfoDetailsFrame:Hide()
				GuildMainFrame:Hide()
				GuildInfoEditDetailsButton:Hide()
				
				--modify:
				
				header2.text:SetText("Events")
				header1.text:SetText("Message of the Day:")
				
				GuildInfoEventsContainer:Show()
				
					local numEvents = CalendarGetNumGuildEvents();
					local scrollFrame = GuildInfoEventsContainer;
					local totalHeight = numEvents * scrollFrame.buttonHeight;
					
					
					if totalHeight > 100 then
						GuildInfoEventsContainer:SetHeight(110)
						GMForumInset:SetHeight(140)
						GuildNewsContainer:SetHeight(90)
					elseif totalHeight < 20 then
						GuildNewsContainer:SetHeight(180)
						GuildInfoEventsContainer:SetHeight(30)
						GMForumInset:SetHeight(50)
					else
						GuildNewsContainer:SetHeight(200 - totalHeight)
						GuildInfoEventsContainer:SetHeight( totalHeight)
						GMForumInset:SetHeight( totalHeight + 30)
					end
					
					GuildNewsContainer:ClearAllPoints()
					GuildNewsContainer:SetPoint("TOPLEFT", GuildFrameBottomInset, "TOPLEFT", 7,-22)
					GuildNewsContainer:SetPoint("BOTTOMRIGHT", GuildFrameBottomInset, "BOTTOMRIGHT", -25,5)
					
					GuildNewsFrame:ClearAllPoints()
					GuildNewsFrame:SetPoint("TOPLEFT", GuildFrameBottomInset, "TOPLEFT", 0, 0)
					GuildNewsFrame:SetPoint("RIGHT", GuildFrameBottomInset, "RIGHT", 0, 0)
					
					GuildNewsFrameHeader:ClearAllPoints()
					GuildNewsFrameHeader:SetPoint("TOPLEFT", GuildFrameBottomInset, "TOPLEFT", 3, -3)
					GuildNewsFrameHeader:SetPoint("RIGHT", GuildFrameBottomInset, "RIGHT", -5, 0)
					GuildNewsFrameHeader:SetHeight(22)
					
					GuildFrameInset:ClearAllPoints()
					GuildFrameInset:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 4, -55)
					GuildFrameInset:SetPoint("RIGHT", GuildFrame, "RIGHT", -7, 0)
					GuildFrameInset:SetHeight(82)
					
					
					
					GuildInfoEditMOTDButton:SetParent(MainPage)
					GuildInfoEditMOTDButton:ClearAllPoints()
					GuildInfoEditMOTDButton:SetPoint("TOPRIGHT", header1, "TOPRIGHT", -10, -3)
					GuildInfoEditMOTDButton:SetHeight(15)
					GuildInfoEditMOTDButton:SetWidth(80)
					GuildInfoMOTD:SetParent(header1)
					GuildInfoMOTD:ClearAllPoints()
					GuildInfoMOTD:SetPoint("TOPLEFT", 10, -25)
					GuildInfoMOTD:SetPoint("BOTTOMRIGHT", header1, "BOTTOMRIGHT", -5, 0)
					
			
					GuildInfoEventsContainer:SetParent(GMForumInset)
					GuildInfoEventsContainer:SetPoint("TOPLEFT", 7, -25)
					GuildInfoEventsContainer:SetWidth(305)
					
					GuildFrameBottomInset:ClearAllPoints()
					GuildFrameBottomInset:SetPoint("TOPLEFT", GuildFrameInset, "BOTTOMLEFT", 0, 0)
					GuildFrameBottomInset:SetPoint("BOTTOMRIGHT", GMForumInset, "TOPRIGHT", 0, 0)
					
					header2:SetAllPoints(GMForumInset)
					
					GMForumInset:SetPoint("BOTTOMLEFT", GuildFrame, "BOTTOMLEFT", 5, 25)
					GMForumInset:SetPoint("RIGHT", GuildFrame, "RIGHT", -7, 0)
			
			end)
			MainPage:SetScript("OnHide", function(self)
				header1:Hide()
				header2:Hide()
				GuildInfoEditMOTDButton:Hide()
				GuildInfoEditEventButton:Hide()
				GMForumInset:Hide()
			end)
			--[[
			local InfoPage = CreateFrame("Frame", nil, GuildFrame)
						InfoPage:SetAllPoints(GuildFrame)
						
			InfoPage:SetScript("OnShow",
			function(self)
					
			
			
				--hide:
					MainPage:Hide()
					GuildInfoEventsContainer:Hide()
					GuildInfoEditMOTDButton:Hide()
					GuildAddMemberButton:Hide()
					GuildViewLogButton:Hide()
					GuildControlButton:Hide()
					GuildInfoMOTD:Hide()
					GuildInfoFrame:Hide()
					GuildInfoEditEventButton:Hide()
				--show:
					header1:Show()
					header2:Show()
					GuildInfoDetailsFrame:Show()
					GMForumInset:Show()
					
					if CanEditGuildInfo() then
						GuildInfoEditDetailsButton:Show()
						GuildInfoEditDetailsButton:SetParent(self)
					else
						GuildInfoEditDetailsButton:Hide()
					end
				--modify:
				
					header2.text:SetText("Guild Information")
					header1.text:SetText("Guild Statistics")
												
					GuildFrameInset:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 4, -53)
					GuildFrameInset:SetPoint("BOTTOMRIGHT", GuildFrame, "BOTTOMRIGHT", -7, 5)
									
					
					
					GuildInfoEditDetailsButton:ClearAllPoints()
					GuildInfoEditDetailsButton:SetParent(self)
					GuildInfoEditDetailsButton:SetPoint("TOPRIGHT", header2, "TOPRIGHT",  -10, -5)
					GuildInfoEditDetailsButton:SetHeight(15)
					GuildInfoEditDetailsButton:SetWidth(100)
					
				
					GuildInfoDetailsFrame:SetParent(header2)
					GuildInfoDetailsFrame:SetPoint("TOPLEFT", 7, -25)
					GuildInfoDetailsFrame:SetWidth(305)
					GuildInfoDetailsFrame:SetHeight(90)
					GMForumInset:SetHeight(125)
					GMForumInset:SetPoint("BOTTOMLEFT", GuildFrame, "BOTTOMLEFT", 5, 5)
				
				
			end)
			
			InfoPage:SetScript("OnHide",
			function(self)
				header1:Hide()
				header2:Hide()
				GMForumInset:Hide()
			end)
			--]]
			
						
		
		RequestGuildRewards()
		QueryGuildXP();
		QueryGuildNews();
		OpenCalendar();		-- to get event data
		GuildFrame_UpdateTabard();
		GuildFrame_UpdateLevel();
		GuildFrame_UpdateXP();
		GuildFrame_UpdateFaction();
		GuildFrame_CheckPermissions();
		
		local function GuildInfo_CheckTabs()
			if ( IsGuildLeader() ) then
				GuildInfoFrameTab3:SetPoint("LEFT", GuildInfoFrameTab2, "RIGHT");
			else
				GuildInfoFrameTab3:SetPoint("LEFT", GuildInfoFrameTab4, "RIGHT");
			end
			
			if CanEditGuildEvent() then
				GuildInfoEditEventButton:Show()
			else
				GuildInfoEditEventButton:Hide()
			end
		end
			
		local function GuildInfo_CheckPage()
			local selected = PanelTemplates_GetSelectedTab(GuildInfoFrame);
			
			if selected == 1 then
				StatsPage:Hide()
				if CanGuildInvite() then
					GuildAddMemberButton:Show()
				end	
							
				if CanEditMOTD() then
					GuildInfoEditMOTDButton:Show()
				end
						
				if ( IsGuildLeader() ) then
					GuildControlButton:Show();
				end
			elseif selected == 2 or selected == 3 then
				StatsPage:Hide()
				GuildViewLogButton:Hide()
				GuildAddMemberButton:Hide()
				GuildControlButton:Hide()
			elseif selected == 4 then
				GuildInfoFrameApplicants:Hide()
				StatsPage:Show()

				
			end
		end
			
						
	local function GuildTabButtonClicked(self)
		
		local tabIndex = self:GetID();
		local width = Settings.PageWidths[tabIndex]
		if width then
			GuildFrame:SetWidth(width)
			SetUIPanelAttribute(GuildFrame, "width", width	)
		end		
		if ( tabIndex == 1 ) then -- Guild
			QueryGuildXP();
			QueryGuildNews();
			OpenCalendar();		-- to get event data
			GuildFrame_UpdateTabard();
			GuildFrame_UpdateLevel();
			GuildFrame_UpdateXP();
			GuildFrame_UpdateFaction();
			GuildFrame_CheckPermissions();
							
			if CanGuildInvite() then
				GuildAddMemberButton:Show()
			end	
						
			if CanEditMOTD() then
				GuildInfoEditMOTDButton:Show()
			end
					
			if ( IsGuildLeader() ) then
				GuildControlButton:Show();
			end
				
			--InfoPage:Hide()
			MainPage:Show() --does all the hard work, so you dont have to!
					
		elseif ( tabIndex == 2 ) then -- Roster 
				
		--Hide
			MainPage:Hide()
		--	InfoPage:Hide()
			GuildPerksToggleButton:Hide()
			GuildAllPerksFrame:Hide()
			GuildInfoEditMOTDButton:Hide()
			GMForumInset:Hide()
			header2:Hide()
			header2:Hide();
			GuildXPFrame:Hide();
			GuildAddMemberButton:Hide();
			GuildControlButton:Hide();
			GuildViewLogButton:Hide();
			GuildNextPerkButton:Hide()
			GuildLatestPerkButton:Hide()
			GuildAllPerksFrame:Hide()
		
		--Modify
			
			ButtonFrameTemplate_HideButtonBar(GuildFrame);
				
			GuildFactionFrame:Show();
				
			updateRosterCount = true;
			
		
		elseif ( tabIndex == 3 ) then -- News
			--this tab is hidden completely
			GuildLatestPerkButton:Hide()
			GuildLatestPerkButton:Hide()
			MainPage:Hide()
		--	InfoPage:Hide()
				
		elseif ( tabIndex == 4 ) then -- Rewards
			
			RequestGuildRewards()
			GuildRewards_Update()				
		
		--hide
			MainPage:Hide()
		--	InfoPage:Hide()
			
			GuildInfoEditMOTDButton:Hide()
			GMForumInset:Hide()
			GuildAllPerksFrame:Hide()
			GuildXPFrame:Hide();
			GuildAddMemberButton:Hide();
			GuildControlButton:Hide();
			GuildViewLogButton:Hide();
		
		--show
				GuildFrame_ShowPanel("GuildRewardsFrame");
				GuildRewardsContainer:Show()
				GuildFrameInset:Show()
				
				local level = GetGuildLevel()
				if level == 25 then
					GuildNextPerkButton:Hide()
					GuildLatestPerkButton:Show()
				elseif level == 1 then
					GuildLatestPerkButton:Hide()
					GuildNextPerkButton:Show()
				else
					GuildLatestPerkButton:Show()
					GuildNextPerkButton:Show()
				end
				GuildFrameBottomInset:Show()
				GuildFactionFrame:Show();
				
			GuildRewardsContainer:SetHeight(200)
			GuildRewardsContainer:SetWidth(315)
			GuildAllPerksFrame:SetParent(GuildFrameBottomInset)
			GuildAllPerksFrame:SetAllPoints(GuildFrameBottomInset)
			
			GuildPerksContainer:SetWidth(307)
			GuildPerksContainer:SetHeight(300)
			
			GuildRewardsFrameBg:SetHeight(200)
			GuildRewardsFrameBg:SetWidth(315)
			GuildRewardsFrameBg:SetParent(GuildRewardsFrame)
			GuildPerksToggleButton:Show()
			GuildPerksToggleButton.ac = nil
			
			GuildRewardsFrameBg:SetHeight(200)
			

			GuildFrameBottomInset:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 5, -275)
			GuildPerksToggleButtonRightText:SetText(GUILD_VIEW_ALL_PERKS_LINK);
			GuildPerksToggleButtonArrow:SetTexCoord(0.45312500, 0.64062500, 0.01562500, 0.20312500);
				 
			
			GuildPerksToggleButton:SetParent(GuildFrameBottomInset)
			GuildPerksToggleButton:SetPoint("TOPLEFT", 5, -5)
			
			GuildPerksToggleButton:SetScript("OnClick", function(self) 
																					if self.ac then 
																						self.ac = nil 
																						GuildRewardsFrameBg:SetHeight(200)
																						GuildRewardsContainer:Show()
																						GuildAllPerksFrame:Hide()
																						GuildFrameInset:Show()
																						GuildRewardsFrameBg:SetParent(GuildRewardsFrame)
																						GuildFrameBottomInset:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 5, -275)
																						GuildPerksToggleButtonRightText:SetText(GUILD_VIEW_ALL_PERKS_LINK);
																						GuildPerksToggleButtonArrow:SetTexCoord(0.45312500, 0.64062500, 0.01562500, 0.20312500);
																						local level = GetGuildLevel()
																						if level == 25 then
																							GuildNextPerkButton:Hide()
																							GuildLatestPerkButton:Show()
																						elseif level == 1 then
																							GuildLatestPerkButton:Hide()
																							GuildNextPerkButton:Show()
																						else
																							GuildLatestPerkButton:Show()
																							GuildNextPerkButton:Show()
																						end
																					else 
																							 GuildNextPerkButton:Hide()
																							GuildLatestPerkButton:Hide()
																						self.ac = true 
																						GuildRewardsFrameBg:SetHeight(320)
																						GuildRewardsContainer:Hide()
																						GuildAllPerksFrame:Show()
																						GuildRewardsFrameBg:SetParent(GuildAllPerksFrame)
																						GuildFrameInset:Hide()
																						GuildFrameBottomInset:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 5, -65)
																						GuildPerksToggleButtonRightText:SetText(GUILD_VIEW_NEW_PERKS_LINK);
																						GuildPerksToggleButtonArrow:SetTexCoord(0.45312500, 0.64062500, 0.20312500, 0.01562500);	
																					end
																				end)
			
			GuildFrameBottomInset:ClearAllPoints()
			GuildFrameBottomInset:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 5, -275)
			GuildFrameBottomInset:SetPoint("BOTTOMRIGHT", GuildFrame, "BOTTOMRIGHT", -7, 30)
			
			
			 
			 GuildLatestPerkButton:ClearAllPoints()
			 GuildLatestPerkButton:SetParent(GuildFrameBottomInset)
			 GuildLatestPerkButton:SetPoint("BOTTOMLEFT", 15, 20)
			 
			 
			 GuildNextPerkButton:SetParent(GuildFrameBottomInset)
			 
				
				ButtonFrameTemplate_HideButtonBar(GuildFrame);
				GuildFrameInset:ClearAllPoints()
				GuildFrameInset:SetPoint("TOPLEFT", 4, -65);
				GuildFrameInset:SetPoint("BOTTOMRIGHT", -7, 150);

				updateRosterCount = true;
				
		elseif ( tabIndex == 5 ) then -- Info
				--[[ want: 
						List of stats
						Guild info
						rank info.
						player info.
					
					--]]
					
				
					GuildViewLogButton:Show()
				
					
			if not GuildInfoFrameTab4 then
				local StatsTab = CreateFrame("Button", "GuildInfoFrameTab4", GuildInfoFrame, "TabButtonTemplate")
				StatsTab:SetText("Stats")
				StatsTab:SetPoint("LEFT", GuildInfoFrameTab1, "RIGHT", 0, 0)
				StatsTab:SetID(4)
				StatsTab:SetScript("OnClick", function(self) PanelTemplates_Tab_OnClick(self, GuildInfoFrame) GuildInfoFrame_Update(); end)
				_G[StatsTab:GetName().."HighlightTexture"]:SetWidth(StatsTab:GetTextWidth() + 31);
				
				PanelTemplates_SetNumTabs(GuildInfoFrame, 4) --add the extra tab

					--narrow the other tabs down a bit to fit the new tab
				PanelTemplates_TabResize(GuildInfoFrameTab1, -8)
				PanelTemplates_TabResize(GuildInfoFrameTab2, -8)
				PanelTemplates_TabResize(GuildInfoFrameTab3, -8)
				PanelTemplates_TabResize(GuildInfoFrameTab4, -8)
				
				GuildInfoFrameTab2:SetPoint("LEFT", GuildInfoFrameTab4, "RIGHT")
				
				hooksecurefunc("GuildInfoFrame_UpdatePermissions", GuildInfo_CheckTabs)
				hooksecurefunc("GuildInfoFrame_Update", GuildInfo_CheckPage)
			end
					
			if CanGuildInvite() then
				GuildAddMemberButton:Show()
			end	
				
				
			if ( IsGuildLeader() ) then
				GuildControlButton:Show();
			end
			
			MainPage:Hide()
		
		elseif self:GetID() == 6 then
				GuildFrameInset:Show()
				
				MainPage:Hide()
				--InfoPage:Hide()
			
				
				GuildAllPerksFrame:Hide()
				GuildNextPerkButton:Hide()
				GuildLatestPerkButton:Hide()
				GuildInfoEditMOTDButton:Hide()
				GMForumInset:Hide()
				
				GuildXPFrame:Hide();
				GuildFactionFrame:Hide();
				GuildAddMemberButton:Hide();
				GuildControlButton:Hide();
				GuildViewLogButton:Hide();
					  
					
			
		end
				GuildFrameMembersCountLabel:Hide();
				GuildFactionFrame:Show();
	end

			hooksecurefunc("GuildFrame_TabClicked", GuildTabButtonClicked)
			MainPage:Hide()
			GuildTabButtonClicked(GuildFrameTab1)
			GuildTabButtonClicked(GuildFrameTab2)
			
	--==============================================================================================
	
	local Sizer = CreateFrame("Button", nil, GuildFrame)
			Sizer:SetSize(15, 100)
			Sizer:SetPoint("CENTER", GuildFrame, "RIGHT", 7, 0)
			Sizer.Tex = Sizer:CreateTexture()
			Sizer.Tex:SetAllPoints(Sizer)
			Sizer.Tex:SetTexture("Interface\\RAIDFRAME\\RaidPanel-Toggle")
			Sizer.Tex:SetTexCoord(1, 0.5, 1, 0)
			Sizer:SetScript("OnMouseDown", function(self) end)
			Sizer:SetScript("OnMouseUp", function(self) end)

			
			
			Sizer:SetMovable(true)
			Sizer:SetScript("OnMouseDown", function(self) 
																			_, self.center = self:GetCenter() 
																			--self.center = self.center* UIParent:GetEffectiveScale() 
																			self:ClearAllPoints()
																			GuildFrame:SetPoint("RIGHT", self, "CENTER", -7, 0)
																			self:SetScript("OnUpdate", function(self) 
																																		local r, l = GuildFrame:GetRight(),  GuildFrame:GetLeft() 
																																		local x, y = GetCursorPosition() 
																																			x = x/UIParent:GetEffectiveScale() 
																																		if (r -l) < 345 then
																																			if x > r then
																																				self:SetPoint("CENTER", UIParent, "BOTTOMLEFT", x, self.center)
																																			end
																																		elseif (r - l) > 800 then
																																			if x < r  then
																																				self:SetPoint("CENTER", UIParent, "BOTTOMLEFT", x, self.center)
																																			end
																																		else
																																			self:SetPoint("CENTER", UIParent, "BOTTOMLEFT", x, self.center)
																																		end
																																	end) 
																			end)
   
			Sizer:SetScript("OnMouseUp", function(self)
																			
																		self:SetScript("OnUpdate", nil)
																		local r, l = GuildFrame:GetRight(),  GuildFrame:GetLeft() 
																		local t = GuildFrame:GetTop()
																		GuildFrame:ClearAllPoints()
																		GuildFrame:SetPoint("TOPLEFT", UIParent, "BOTTOMLEFT", l, t)
																		GuildFrame:SetWidth(r-l)
																		Sizer:SetPoint("CENTER", GuildFrame, "RIGHT", 7, 0)
																		SetUIPanelAttribute(GuildFrame, "width", r-l)
																		Settings.PageWidths[PanelTemplates_GetSelectedTab(GuildFrame)] = r-l
																end)
	

	
end
end	




--======================= Settings stuff  =============================
--======================================================================

function GMaster.ModuleSettings.GMGuildFrame()
--create settings page
	local parent = CreateFrame("Frame")
		parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
		parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
		parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
		parent.titleText:SetJustifyH("LEFT")
		parent.titleText:SetJustifyV("TOP")
		parent.titleText:SetText("GM-GuildFrame makes the layout of the guild frame a little more sensible.\n "
															.."The Message of the day, news, and events are now on the main page, the reward page shows both"
															.." rep rewards and guild perks, and the guild info shows some extra guild stats.")
	return parent

end

function GMaster.ModuleLoad.GMGuildFrame()
	--enable the module
		GMaster.AL.GMGuildFrame()
		
	if GMaster.GUILD_FRAME_LOADED then
		GMaster.GFL.GMGuildFrame()
	else
		LoadAddOn("Blizzard_GuildUI")
	end
	
	
	
end

function GMaster.ModuleRemove.GMGuildFrame()
	--this is a pretty big job, best to just reload the UI
	return false
end


--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Shows guild members on the map
--========================== 2. Details ===============================
	Location data is recorded by the addon and then transmitted out ot other guild members.
	If more than one player is in the same zone, the update frequency increases.
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.52
	Tooltips now show when the map is fullscreen

1.42
	Fixed a problem where guildies that had entered an instance where shown at the last location before entering
	Fixed an error caused by recieving the location of a player in an instance
	
--========================== 5. To do =================================
	Efficiency:
	Decrease the update interval for players in seperate zones,
	Increase the interval for players in the same zones, using the 
	whisper channel.
]]

GMaster.LoadOrder.GMLocator = true

local module = {}

	local MAX_ICONS = 25
	local ClassCoord = { 
									WARRIOR = {0, 0.125, 0, 0.25},
									PALADIN = {0.125, 0.25, 0, 0.25},
									HUNTER = {0.25, 0.375, 0, 0.25},
									ROGUE = {0.375, 0.5, 0, 0.25},
									PRIEST = {0.5, 0.625, 0, 0.25},
									DEATHKNIGHT = {0.625, 0.75, 0, 0.25},
									SHAMAN= {0.75, 0.875, 0, 0.25},
									MAGE = {0.875, 1, 0, 0.25},
									WARLOCK = {0, 0.125, 0.25, 0.5},
									DRUID = {0.25, 0.375, 0.25, 0.5}
								}

function GMaster.AL.GMLocator() --load when the addon loads

	local Player = {} --set up a table with the players details
	Player.zx = 0
	Player.zy = 0
	Player.zcont = 0
	Player.zzone = 0
	Player.standing = 0 
	local partyNames = {}

	if not module.statusFrame then
		module.statusFrame = CreateFrame("Frame")
	end
	local statusFrame = module.statusFrame
	 

	local function SendLocation()
			
		if not IsInGuild() then
			return
		end
		
		if IsInInstance() then
			GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMLocator", "ININSTANCE"}
			return
		end
			
			
			
		statusFrame:UnregisterEvent("WORLD_MAP_UPDATE")
			local lastCont, lastZone = GetCurrentMapContinent(), GetCurrentMapZone();
			SetMapToCurrentZone();
			
			local zx, zy = GetPlayerMapPosition("player")
			local zcont, zzone = GetCurrentMapContinent(), GetCurrentMapZone()
				
			SetMapZoom(GetCurrentMapContinent())
			local cx, cy = GetPlayerMapPosition("player")
			local ccont, czone = GetCurrentMapContinent(), GetCurrentMapZone()
			
				if (zx + zy + cx + cy) > 0 then -- the playe rmight have the map open which will screw things up a bit
					zx = floor(zx * 10000 + 0.5)
					zy = floor(zy *10000 + 0.5)
					cx = floor(cx *10000 + 0.5)
					cy = floor(cy *10000 + 0.5)
					if zx ~= Player.zx and zy ~= Player.zy then
						Player.zx = zx
						Player.zy = zy 
						Player.zcont = zcont
						Player.zzone = zzone
						
						GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMLocator", "zx"..zx.."zy"..zy.."cx"..cx.."cy"..cy.."zcont"..zcont.."zzone"..zzone.."ccont"..ccont.."czone"..czone}
					end
				end
			SetMapZoom(lastCont, lastZone); -- set map zoom back to what it was before;
		statusFrame:RegisterEvent("WORLD_MAP_UPDATE")
	end


	if not module.iconsloaded then
		for i = 1, MAX_ICONS do
			local icon = CreateFrame("Button", "GMLocWorldButton"..i,WorldMapButton)
			icon.tex = icon:CreateTexture()
			icon.tex:SetAllPoints(icon)
			icon.tex:SetTexture("Interface\\Minimap\\PartyRaidBlips")
			icon.tex:SetTexCoord(0, 0.125,  0, 0.25)		
			icon:SetWidth(16)
			icon:SetHeight(16)
			icon.tooltip = ""
			icon:SetScript("OnEnter", function(self) 
															WorldMapTooltip:SetOwner(self, "ANCHOR_RIGHT")
															WorldMapTooltip:SetText(self.tooltip)
														end)
			icon:SetScript("OnLeave", function(self) WorldMapTooltip:Hide() end)
		end
		module.iconsloaded = true
	end

	statusFrame.elapsed = 0
	statusFrame.interval = 5

	local function MainMapRefresh(self)
		local curCont = GetCurrentMapContinent() -- get the current continent
		local curZo = GetCurrentMapZone() --current zone
		local i = 1

		if curCont < 0 or curCont > 4 or IsInInstance() then --hide them all if its a bg etc
			for i = 1, MAX_ICONS do
				local  button = getglobal("GMLocWorldButton" .. i)
				button:Hide()
			end
			return
		end
		
		for i = 1, MAX_ICONS do
			local  button = getglobal("GMLocWorldButton" .. i)
			button:Hide()
		end
		
		local found
	
		for player, info in pairs(GMRoster) do
			if info.online  and player ~= GMaster.PlayerName and info.zx then
				if partyNames[player] then
					return
				end
				local button = _G["GMLocWorldButton"..i]
				local x, y	
				
				if  (info.zzone == curZo)  and (info.zcont == curCont) then
					x, y = info.zx, info.zy
				elseif (info.czone == curZo) and (info.ccont == curCont ) then
					x, y = info.cx, info.cy
				end
					if i <= MAX_ICONS then
						if button and x and y then
							found = true
							local width, height = WorldMapButton:GetWidth(), WorldMapButton:GetHeight()
							local x, y = (width/10000)*x, (height/10000)*y
							if info.class then
								button.tex:SetTexCoord(unpack(ClassCoord[info.class]))
							end
							button:SetPoint("CENTER", WorldMapButton, "TOPLEFT", x, -y)
							button:SetFrameStrata("TOOLTIP")
							button:SetFrameLevel(WorldMapButton:GetFrameLevel() + 50)
							button.tooltip = player
							button:Show()
							i = i + 1
						else
							button:Hide()
						end
					end
			end
		end
			tinsert(GMaster.Timers, {runonce = true, interval = (self.interval-1), elapsed = 0, func = SendLocation})
			return found
	end

	local function UpdateMainMap(self, elapsed)
	statusFrame.elapsed = statusFrame.elapsed + elapsed
		if statusFrame.elapsed > statusFrame.interval then
				statusFrame.elapsed = 0
				local found = MainMapRefresh(self)
				if found then
					self.interval = 5
				else
					self.interval = 20
				end
		end
	end

	local function UpdatePartyNames()
	partyNames = {}
		if( GetNumRaidMembers() > 0 ) then
			for i=1, MAX_RAID_MEMBERS do
				local playerName = UnitName( "raid" .. i );
				if playerName then
					partyNames[playerName] = true
				end
			end
		else
			for i=1, MAX_PARTY_MEMBERS do
				local playerName = UnitName( "party" .. i );
				if playerName then
					partyNames[playerName] = true
				end
			end
		end
	end

	function GMaster.CMA.GMLocator(prefix, msg, channel, player)
		if prefix == "GMLocator" then
			if msg == "ININSTANCE" then
				if GMRoster[player] then
					GMRoster[player].zx = nil --this should stop the map from checking it, needs testing
					return
				else
					return
				end
			end
			if player ~= GMaster.PlayerName then
			local zx, zy, cx, cy, zcont, zzone, ccont, czone = msg:match("zx(%d+)zy(%d+)cx(%d+)cy(%d+)zcont(%d+)zzone(%d+)ccont(%d+)czone(%d+)")
				if zx then
					if GMRoster[player]  then
					GMRoster[player].zx = tonumber(zx)
					GMRoster[player].zy = tonumber(zy)
					GMRoster[player].cx = tonumber(cx)
					GMRoster[player].cy = tonumber(cy)
					GMRoster[player].zcont = tonumber(zcont)
					GMRoster[player].zzone = tonumber(zzone)
					GMRoster[player].ccont = tonumber(ccont)
					GMRoster[player].czone = tonumber(czone)
					GMRoster[player].online = true
					end
				end		
			end
		end	
	end

	local function StatusCheck(self, event, ...)	
		if event == "CHAT_MSG_SYSTEM" then
			local msg = ...
			local player = msg:match("(.-) has gone offline")
			if GMRoster[player] then
				GMRoster[player].online = nil
			end
		elseif event == "PARTY_MEMBERS_CHANGED" then -- change this for thje actual function
			UpdatePartyNames()
		elseif event == "ZONE_CHANGED_NEW_AREA" then
			tinsert(GMaster.Timers, {runonce = true, interval = 3, elapsed = 0, func = SendLocation})
		elseif event == "WORLD_MAP_UPDATE" then
			MainMapRefresh(self)
		end
	end


	statusFrame:RegisterEvent("CHAT_MSG_SYSTEM")
	statusFrame:RegisterEvent("PARTY_MEMBERS_CHANGED") -- raid members changing
	statusFrame:RegisterEvent("ZONE_CHANGED_NEW_AREA") -- current map zone changing

	statusFrame:RegisterEvent("WORLD_MAP_UPDATE")
	statusFrame:SetScript("OnEvent", StatusCheck)
	statusFrame:SetScript("OnUpdate", UpdateMainMap)
	
	if not module.togglebutton then
		module.togglebutton = CreateFrame("CheckButton", "GMLocatorCheckButton", WorldMapFrame, "ChatConfigCheckButtonTemplate")
		_G[module.togglebutton:GetName().."Text"]:SetText ("Show Guild Members")
		_G[module.togglebutton:GetName().."Text"]:SetTextColor(1, 0.8, 0)
			module.togglebutton:SetSize(25, 25)
			module.togglebutton:SetPoint("RIGHT", WorldMapQuestShowObjectives, "LEFT", -300, 0)
			module.togglebutton:SetScript("OnClick", function(self) 
																									if self:GetChecked() then
																										GMaster.AL.GMLocator()
																									else
																										GMaster.CMA.GMLocator = function() end --prevent it from recieving locations
																										statusFrame:SetScript("OnUpdate", nil) --stop it from ending locations
																										statusFrame:SetScript("OnEvent", nil)
																										
																										for i = 1, MAX_ICONS do --hide all the icons
																											local  button = getglobal("GMLocWorldButton" .. i)
																											button:Hide()
																										end
																									end
																								end )
																								
	end
		module.togglebutton:SetChecked(true)
		
		
end



function GMaster.ModuleSettings.GMLocator()
	local parent = CreateFrame("Frame")
			parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
			parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
			parent.titleText:SetJustifyH("LEFT")
			parent.titleText:SetJustifyV("TOP")
			parent.titleText:SetText("GM-Locator shares your location with other guild members on the map, allowing you see where all your bestest"
																.." buddies are!")
		return parent
end

function GMaster.ModuleLoad.GMLocator()
	
	GMaster.AL.GMLocator()
	
	module.togglebutton:Show()
end

function GMaster.ModuleRemove.GMLocator()
	GMaster.CMA.GMLocator = function() end --prevent it from recieving locations
	module.statusFrame:SetScript("OnUpdate", nil) --stop it from ending locations
	module.statusFrame:SetScript("OnEvent", nil)
	module.togglebutton:Hide()

	for i = 1, MAX_ICONS do --hide all the icons
			local  button = getglobal("GMLocWorldButton" .. i)
			button:Hide()
	end
		
	return true
end


--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Refreshes the guild message of the day at set intervals
--========================== 2. Details ===============================
	Aimed to encourage players to actually read the message of the day, 
	This module will refresh the current message of the day at set intervals, 
	Making it appear in guild chat.
	The duration between update can be set in the interface options for the module.
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.6
	-should sync updates with other players
1.52:
	Hopefully fixed the update bug.
1.5
Should now work!
--========================== 5. To do =================================
	Sync duration with other players
	Add the duration slider to the edit box of the MOTD
]]


local module = {}

GMaster.LoadOrder.GMOTD = true --add it into the addon list

function GMaster.AL.GMOTD()
	GMSettings.MOTDinterval = GMSettings.MOTDinterval or 3600

	function GMaster.GFL.GMOTD()
		if CanEditMOTD() then
			GMSettings.lastMOTD = GMSettings.lastMOTD or time()
			
			
			function module.RefreshMOTD()
				
				if (time() - GMSettings.lastMOTD) > GMSettings.MOTDinterval then
					local motd = GetGuildRosterMOTD()
					if motd and type(motd) =="string" and not motd == "" then
						GuildSetMOTD(motd)
					end
					GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMOTD", time()}				
				end
			end
			
			function GMaster.CMA.CheckMOTD(prefix, msg, channel, player)
				if prefix == "GMOTD" then
					local lastsent = tonumber(msg)
					if lastsent then
						GMSettings.lastMOTD = lastsent
					end
				end
			end
			tinsert(GMaster.Timers, {runonce = false, interval = 60, elapsed = 0, func = module.RefreshMOTD}) --checks every 60 seconds to see if it needs updating
		end
	end
end

function GMaster.ModuleSettings.GMOTD()
	local parent = CreateFrame("Frame")
			parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
			parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
			parent.titleText:SetJustifyH("LEFT")
			parent.titleText:SetJustifyV("TOP")
			parent.titleText:SetText("GM-MOTD resheses the MTOD, so you don't have to."
																.."\n Just drag the slider to set the update duration")
			
			
			parent.delaySlide =  CreateFrame("Slider", "GMOTDSlide", parent, "OptionsSliderTemplate")
	parent.delaySlide:SetWidth(300)
	parent.delaySlide:SetHeight(20)
	parent.delaySlide:SetMinMaxValues(10, 60)
	parent.delaySlide:SetValueStep(1)

	parent.delaySlide:SetPoint("TOP", 0 , -100)
	parent.delaySlide:SetScript("OnValueChanged", function(self, value) GMSettings.MOTDinterval = value*60 end)
	parent.delaySlide:SetValue(GMSettings.MOTDinterval/60)

	GMOTDSlideLow:SetText("10 minutes")
	GMOTDSlideHigh:SetText("1 hour")
		return parent
end

function GMaster.ModuleLoad.GMOTD()
	GMaster.AL.GMOTD()
	if GMaster.GUILD_FRAME_LOADED then
		GMaster.GFL.GMOTD()
	else
		LoadAddOn("Blizzard_GuildUI")
	end
end

function GMaster.ModuleRemove.GMAlts()
	module.RefreshMOTD = function() end
	return true
end--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Auto rank guild members based on certain criteria.
--========================== 2. Details ===============================
	Adds an extra item to the dropdown in "Guild Control" which allows you to 
	apply certain filters to each rank. Guild members can then be sorted between ranks
	based on wether they match the specified filters.
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.52:
	merged antirankspam into this module
1.50
	Scrapped the manual vs auto features.
	Integrated the module into the guild control UI ("Rank Requirements" in the guild rank control dropdown)
	fixed a bug where it would still spam per rank change.
--========================== 5. To do =================================
	Add extra methods to rank people by.
	Broadcast the requirements so that the guild members can see what they need to do
	to achieve the next rank.
	Priority: High
	Need to send a message to anitrankspam to make it block all rank changes
	need to convert it to modular
]]



--[[
Other ideas:
General ranking tools:
Remove all members offline for more then X months 
																-(ignore specific rank)
																-account for alts.
Delete Rank: Auto move everyone from that rank either up or down																

when promoting someone manually, allow optional reason
delay the manual promote until the player is next online, this way they will notcie their new rank change.
snend some kind of congratulations.

This may be better suited to being integrated into the guild control UI


--]]

--[[
Need to merge the old test methods into the new ui

SendAddonMessage("GMRanker", "Start", "GUILD")
	tinsert(GMaster.Timers, {runonce = true, interval = 10, elapsed = 0, func = function() SendAddonMessage("GMRanker", "End", "GUILD") end})

--]]
--change this to add a tooltip.


GMaster.LoadOrder.GMRanker = true

local module = {}

local reqs = {Level = "Minimum Level for this rank",
							Age = "Minimum length of time in guild (days)",
							Chattyness = "Minimum number of times spoken in guild chat",
							Donations = "Minimum donated, in gold, through looting or direct donations",
							}
							
							--[[  need to add these in as they are written
							reqs["Events Created"] = "Minimum number of events that the player has started in the guild"
							reqs["Events Attended"] = "Minimum number of events the player has attended"
							reqs["Guild Rep"] = "Minimum guild reputation earned"
							reqs["Battlegrounds Attended"] = "Time spent in battlegrounds (hours)"
							reqs["Instanced Attended"] = "Time spent in instances"
							--]]
							
GMSettings.RankList = {}


local RankFrame= CreateFrame("Frame", nil, UIParent)
RankFrame:Hide()


local SettingsFrame = CreateFrame("Frame", nil, RankFrame)
SettingsFrame:SetAllPoints(RankFrame)
SettingsFrame:Hide()


--ton.icon:SetTexCoord(0.5625, 1, 0, 0.4375);
--create all of the settings:
--[[
	need an add button, a remove button, a label and edit box for each setting.
	
	need a dynamic system to load and show the settings for each requirement
	
	scroll frame to scroll each item (copy from the guild tab)
	
	remove button to remove each item
--]]
local function CheckEligible(name, info, rank, checks)
	if checks.Level then
		if info.level < checks.Level then
			return
		end
	end
	local tempstats = {}
	
	
	for dated, players in pairs(GMLogs) do
		if players[name] then
			for i = 1, #players[name] do
				if tempstats[i] then
					tempstats[i] = tempstats[i] + players[name][i]
				else
					tempstats[i] = players[name][i]
				end
			end
		end
	end
	
	if checks.Donations then
		local donated = (tempstats[22] or 0) - (tempstats[23] or 0) - (tempstats[24] or 0) + (tempstats[25] or 0)
		
		if (donated < checks.Donations) then
			return
		end
	end
	
	if checks.Chattyness then
		if not tempstats[3] then
			return
		end
		if (tempstats[3] < checks.Chattyness) then
			return
		end
	end
	
	if checks.Age then
		if GMRoster[name].firstseen then
			local age = time() - GMRoster[name].firstseen
			age = age/86400
			
			if age < checks.Age then
				return
			end
		end
	end
	

	if (info.rank + 1) <= RankFrame.selectedrank then
		return
	end	
	GMaster.Debug("promoting "..name)
	--if it has got to this point, they need to be promoted:
	
	for i = 1, (info.rank+1 - RankFrame.selectedrank) do 
		tinsert(GMaster.Timers, {runonce = true, interval = 1*i, elapsed = 0, func = GuildPromote, vars = {name}})
	end
		
end

local function Autorank()
if RankFrame.selectedrank then
	local check = GMSettings.RankList[RankFrame.selectedrank]
	if check then
		SendAddonMessage("GMRanker", "Start", "GUILD")	
		for name, info in pairs(GMRoster) do
			CheckEligible(name, info, RankFrame.selectedrank, check)
		end
		tinsert(GMaster.Timers, {runonce = true, interval = 10, elapsed = 0, func = function() SendAddonMessage("GMRanker", "End", "GUILD") end})
	end
end
end

local function CreateRequirement(k)
	local frame = CreateFrame("Frame", nil, SettingsFrame)
	frame:SetHeight(25)
	frame:SetPoint("LEFT")
	frame:SetPoint("RIGHT")
	frame.label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	frame.label:SetSize(100, 25)
	frame.label:SetPoint("TOPLEFT",40, 0)
	frame.label:SetJustifyH("LEFT")
	frame.editbox = CreateFrame("EditBox", "GMRankReqEB"..k, frame, "InputBoxTemplate")
	frame.editbox:SetPoint("TOPLEFT", 200, 0)
	frame.editbox:SetPoint("BOTTOMRIGHT", -15, 0)
	frame.editbox:SetScript("OnEscapePressed", function(self) GuildControlUI:Hide() end)
	frame.editbox:SetNumeric(true)
	frame.editbox:SetScript("OnTextChanged", function(self) GMSettings.RankList[RankFrame.selectedrank][frame.label:GetText()] = self:GetNumber() end)
	frame.editbox:SetScript("OnShow", function(self) if tonumber(GMSettings.RankList[RankFrame.selectedrank][frame.label:GetText()]) then
				self:SetNumber(GMSettings.RankList[RankFrame.selectedrank][frame.label:GetText()])
			else self:SetNumber(0) end end)
	
	frame.remove = CreateFrame("Button", nil, frame)
	frame.remove:SetSize(15,15)
	frame.remove:SetPoint("TOPLEFT", 15, -5)
	
	frame.remove:SetNormalTexture("Interface\\Buttons\\UI-GroupLoot-Pass-Up")
	frame.remove:SetPushedTexture("Interface\\Buttons\\UI-GroupLoot-Pass-Down")
	frame.remove:SetHighlightTexture("Interface\\Buttons\\UI-GroupLoot-Pass-Highlight")
	frame.remove:SetScript("OnClick", function() GMSettings.RankList[RankFrame.selectedrank][frame.label:GetText()] = nil GMaster.ReqRefresh() end)
	
	frame:Hide()
	return frame
end

local items = {}

function GMaster.ReqRefresh()
	for k, item in pairs(items) do
		item:Hide()
	end
	local found = 0
	local i = 1
	for name, tooltip in pairs(reqs) do
		if GMSettings.RankList[RankFrame.selectedrank][name] then
			
			local button = items[i] or CreateRequirement(i)
			button:Show()
			button:SetPoint("TOP", 0, -40-(found*30))
			button.label:SetText(name)
			if tonumber(GMSettings.RankList[RankFrame.selectedrank][name]) then
				button.editbox:SetNumber(GMSettings.RankList[RankFrame.selectedrank][name])
			end
			items[i] = button
			found = found + 1
			i = i + 1
		end
	end
end

local ReqSelect = CreateFrame("Frame", "GMRankerReqSelect", RankFrame, "UIDropDownMenuTemplate") --ReqSelect showing each rank
			
			UIDropDownMenu_SetWidth(ReqSelect, 120)
			--UIDropDownMenu_SetButtonWidth(GMRankerRankSelect, 120)
	
local function DropDown_Initialize(self, level) -- the menu items, needs a cleanup
	
	local info = UIDropDownMenu_CreateInfo()
	
	for name, tooltip in pairs(reqs) do
		info.text = name
		info.value = name
		info.tooltipTitle = name
		info.tooltipText = tooltip
		info.checked = function() if RankFrame.selectedrank and GMSettings.RankList[RankFrame.selectedrank][name] then return true end end
		info.func = function() GMSettings.RankList[RankFrame.selectedrank][name] = (not GMSettings.RankList[RankFrame.selectedrank][name]) GMaster.ReqRefresh() end
		UIDropDownMenu_AddButton(info, level)
	end
end
	UIDropDownMenu_Initialize(ReqSelect, DropDown_Initialize, "MENU")	
	UIDropDownMenu_SetText(ReqSelect, "Select Rank")




local AddButton = CreateFrame("Button", nil, SettingsFrame, "UIPanelButtonTemplate")
AddButton:SetText("Add Req.")
AddButton:SetSize(100, 25)
AddButton:SetPoint("TOPLEFT", 6, 0)
AddButton:SetScript("OnClick", function(self) ToggleDropDownMenu(1, 1, ReqSelect, self, 5, 0) end)
AddButton.tooltip = "Add a new requirement for this rank"
AddButton:SetScript("OnEnter", function(self) 
																	GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
																		GameTooltip:SetText(self.tooltip);
																	end)
AddButton:SetScript("OnLeave", function(self)
																GameTooltip:Hide()
																end)

local ReqButton = CreateFrame("Button", nil, SettingsFrame, "UIPanelButtonTemplate")
ReqButton:SetText("Auto Rank!")
ReqButton:SetSize(100, 25)
ReqButton:SetPoint("BOTTOMRIGHT", -7, 10)
ReqButton:SetScript("OnClick", function(self) Autorank() end)
ReqButton.tooltip = "Automatically rank guild members based on the requirements set."
ReqButton:SetScript("OnEnter", function(self) 
																	GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
																		GameTooltip:SetText(self.tooltip);
																	end)
ReqButton:SetScript("OnLeave", function(self)
																GameTooltip:Hide()
																end)

local function RankBackup()
	for i = 1, GetNumGuildMembers(true) do --build a list of all members in the selected ranks
		local name, rank, rankIndex, level  =  GetGuildRosterInfo(i)
		if GMRoster[name] then
			GMRoster[name].oldrank = rankIndex
		end
	end
end

local function RestoreRanks()
	SendAddonMessage("GMRanker", "Start", "GUILD")
	for i = 1, GetNumGuildMembers(true) do --build a list of all members in the selected ranks
		local name, rank, rankIndex, level  =  GetGuildRosterInfo(i)
		if GMRoster[name] and GMRoster[name].oldrank and not (GMRoster[name].oldrank == rankIndex) then
			if GMRoster[name].oldrank < rankIndex then
				for k = 1, (rankIndex - GMRoster[name].oldrank) do
					tinsert(GMaster.Timers, {runonce = true, interval = 1*k, elapsed = 0, func = GuildPromote, vars = {name}})
				end
			elseif GMRoster[name].oldrank > rankIndex then
				for k = 1, (GMRoster[name].oldrank - rankIndex) do
					tinsert(GMaster.Timers, {runonce = true, interval = 1*k, elapsed = 0, func = GuildDemote, vars = {name}})
				end
			end
		end
	end
		tinsert(GMaster.Timers, {runonce = true, interval = 12, elapsed = 0, func = function() SendAddonMessage("GMRanker", "End", "GUILD") end})
end

local function RestoreAddonRanks()
	SendAddonMessage("GMRanker", "Start", "GUILD")
	for i = 1, GetNumGuildMembers(true) do --build a list of all members in the selected ranks
		local name, rank, rankIndex, level  =  GetGuildRosterInfo(i)
		local found = nil
		if GMRoster[name] and GMRoster[name].oldrank and not (GMRoster[name].oldrank == rankIndex) then
			for dated, players in pairs(GMLogs) do --clears empty and small tables
				if players[name] and players[name][2] and players[name][2] > 0 then
					found = true
				end
			end
			
			if found and (GMRoster[name].oldrank < rankIndex) then
				for k = 1, (rankIndex - GMRoster[name].oldrank) do
					tinsert(GMaster.Timers, {runonce = true, interval = 1*k, elapsed = 0, func = GuildPromote, vars = {name}})
				end
			elseif found and (GMRoster[name].oldrank > rankIndex) then
				for k = 1, (GMRoster[name].oldrank - rankIndex) do
					tinsert(GMaster.Timers, {runonce = true, interval = 1*k, elapsed = 0, func = GuildDemote, vars = {name}})
				end
			end
			
			
		end
	end
		tinsert(GMaster.Timers, {runonce = true, interval = 12, elapsed = 0, func = function() SendAddonMessage("GMRanker", "End", "GUILD") end})
end

local function Demote_All()
	SendAddonMessage("GMRanker", "Start", "GUILD")
	for i = 1, GetNumGuildMembers(true) do --build a list of all members in the selected ranks
		local name, rank, rankIndex, level  =  GetGuildRosterInfo(i)
		local found = nil
			if rankIndex > 3 then
				for k = 1, (10 - rankIndex) do
					tinsert(GMaster.Timers, {runonce = true, interval = 2*k, elapsed = 0, func = GuildDemote, vars = {name}})
				end
			end
	end
		tinsert(GMaster.Timers, {runonce = true, interval = 25, elapsed = 0, func = function() SendAddonMessage("GMRanker", "End", "GUILD") end})
end

local BackupButton = CreateFrame("Button", nil, RankFrame, "UIPanelButtonTemplate")
BackupButton:SetText("Backup")
BackupButton:SetSize(100, 25)
BackupButton:SetPoint("BOTTOMLEFT", 7, 10)
BackupButton:SetScript("OnClick", function(self) RankBackup()	 end)
BackupButton.tooltip = "Backup the current rank of each guild member"
BackupButton:SetScript("OnEnter", function(self) 
																	GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
																		GameTooltip:SetText(self.tooltip);
																	end)
BackupButton:SetScript("OnLeave", function(self)
																GameTooltip:Hide()
																end)
																
local RestoreButton = CreateFrame("Button", nil, RankFrame, "UIPanelButtonTemplate")
RestoreButton:SetText("Restore")
RestoreButton:SetSize(100, 25)
RestoreButton:SetPoint("LEFT",BackupButton, "RIGHT", 7, 0)
RestoreButton:SetScript("OnClick", function(self) RestoreRanks()	 end)
RestoreButton.tooltip = "Restore the backed up ranks"
RestoreButton:SetScript("OnEnter", function(self) 
																	GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
																		GameTooltip:SetText(self.tooltip);
																	end)
RestoreButton:SetScript("OnLeave", function(self)
																GameTooltip:Hide()
																end)
																
local RestoreWithAddonButton = CreateFrame("Button", nil, RankFrame, "UIPanelButtonTemplate")
RestoreWithAddonButton:SetText("Restore /w addon")
RestoreWithAddonButton:SetSize(150, 25)
RestoreWithAddonButton:SetPoint("LEFT",BackupButton, "RIGHT", 7, -25)
RestoreWithAddonButton:SetScript("OnClick", function(self) RestoreAddonRanks()	 end)
RestoreWithAddonButton.tooltip = "Restore the backed up ranks"
RestoreWithAddonButton:SetScript("OnEnter", function(self) 
																	GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
																		GameTooltip:SetText(self.tooltip);
																	end)
RestoreWithAddonButton:SetScript("OnLeave", function(self)
																GameTooltip:Hide()
																end)

local DemoteAll = CreateFrame("Button", nil, RankFrame, "UIPanelButtonTemplate")
DemoteAll:SetText("Demote All")
DemoteAll:SetSize(100, 25)
DemoteAll:SetPoint("LEFT",BackupButton, "LEFT", 0, -25)
DemoteAll:SetScript("OnClick", function(self) Demote_All()	 end)


local DropDown = CreateFrame("Frame", "GMRankerRankSelect", RankFrame, "UIDropDownMenuTemplate") --dropdown showing each rank
			DropDown:SetPoint("TOPRIGHT", 10, 0)
			UIDropDownMenu_SetWidth(DropDown, 120)
			--UIDropDownMenu_SetButtonWidth(GMRankerRankSelect, 120)
	
	local function DropDown_Initialize(self, level) -- the menu items, needs a cleanup
			level = level or 1
		local info = UIDropDownMenu_CreateInfo()
		for i = 2, GuildControlGetNumRanks() do
			local name = GuildControlGetRankName(i)
			info.text = name
			info.value = name
			info.notCheckable = true
			info.arg1 = i
			info.func = function(self, arg1)  
										RankFrame.selectedrank = arg1 
											if not GMSettings.RankList[RankFrame.selectedrank] then 
												GMSettings.RankList[RankFrame.selectedrank] = {} 
											end
											SettingsFrame:Show() 
											GMaster.ReqRefresh()  
											UIDropDownMenu_SetText(DropDown, name) 
										end
			UIDropDownMenu_AddButton(info, level)
		end
	end
	UIDropDownMenu_Initialize(DropDown, DropDown_Initialize)	
	UIDropDownMenu_SetText(DropDown, "Select Rank")


	
local function ShowControls(self, arg1, arg2)
	if arg1 == 4 then
		RankFrame:Show()
	else 
		RankFrame:Hide()
	end
end

function GMaster.AL.GMRanker()
	if not module.addDD then
		function module.addDD(frame)
			if frame == GuildControlUINavigationDropDown and GMSettings.modules.GMRanker.active then
					local info = UIDropDownMenu_CreateInfo();
				info.text = "Rank Requirements"
				info.arg1 = 4;
				info.arg2 = "Rank Requirements"
				info.func = GuildControlUINavigationDropDown_OnSelect;
				info.checked = GuildControlUI.selectedTab == 4;
				UIDropDownMenu_AddButton(info);
			end
		end
	end
	
	function GMaster.GFL.GMRanker()
	hooksecurefunc("UIDropDownMenu_Initialize", module.addDD)
	hooksecurefunc("GuildControlUINavigationDropDown_OnSelect", ShowControls)
	UIDropDownMenu_SetWidth( GuildControlUINavigationDropDown, 140)
	RankFrame:SetParent(GuildControlUI)
	RankFrame:SetPoint("TOPLEFT", 5, -55)
	RankFrame:SetPoint("BOTTOMRIGHT", -5, 5)	
end	
end





	local RankWaitTime
	local ChangeRank = {}
	local SysType
	local blockAll

	local Timer = CreateFrame("Frame")

	local function RankAnnounce(self, elapsed)
		if RankWaitTime and (RankWaitTime < time() -5) then
			local ranks = {}
			for member, info in pairs(ChangeRank) do
				if not ranks[info.rank] then
					ranks[info.rank] = {}
				end
				if not ranks[info.rank][info.ptype] then
					ranks[info.rank][info.ptype] = {}
				end
				tinsert(ranks[info.rank][info.ptype], member)
			end	
			for rank, types in pairs(ranks) do
				local msg = ""	
				local k = 0
				for rtype, names in pairs(types) do
					for i = 1, #names do
						if k == 0 and i == 1 then
							msg = msg..names[i]
						else
							msg = msg..", "..names[i]
						end
					end
						msg = msg.." "..rtype..": "
					k = k + 1
				end
				msg = msg.." to rank '"..rank.."'"
				DEFAULT_CHAT_FRAME:AddMessage(msg, 1, 1, 0)
			end
			Timer:SetScript("OnUpdate", nil)
			ChangeRank = {}
		end
	end

	function GMaster.CMA.ToggleRankSpam(prefix, msg, channel, player)
		if prefix == "GMRanker" then
			if msg == "Start" then
				blockAll = true
			elseif msg == "End" and blockAll then
				blockAll = false
				DEFAULT_CHAT_FRAME:AddMessage("Guild ranks have been updated. Check out the roster for more information", 1, 1, 0)
			end
		end
	end

	local ptypes = {"promoted", "demoted", "kicked"}

	local function filter(self, event, msg, ...)
		if blockAll then return true end
		for k, ptype in pairs(ptypes) do
			local officer, member, rank = msg:match("(.-) has "..ptype.." (.-) to (.+)")
			if officer then
					ChangeRank[member] = {rank = rank, ptype = ptype, officer = officer}
					RankWaitTime = time()
					Timer:SetScript("OnUpdate", RankAnnounce)
				return true
			end
		end
	end

	ChatFrame_AddMessageEventFilter("CHAT_MSG_SYSTEM", filter);






function GMaster.ModuleSettings.GMRanker()
	local parent = CreateFrame("Frame")
			parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
			parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
			parent.titleText:SetJustifyH("LEFT")
			parent.titleText:SetJustifyV("TOP")
			parent.titleText:SetText("GM-Alts tracks alts of guild members and shares them with other members, allowing you to see who's who easily in the roster."..
																"\n There are currently no settings that can be changed for this module")
		return parent
end

function GMaster.ModuleLoad.GMRanker()
	GMaster.AL.GMRanker()
	if GMaster.GUILD_FRAME_LOADED then
		GMaster.GFL.GMRanker()
	else
		LoadAddOn("Blizzard_GuildUI")
	end
end

function GMaster.ModuleRemove.GMRanker()
	module.addDD = function() end
	return true
end--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Auto announces different guild recruitment messages from different players
	in the guild.
--========================== 2. Details ===============================
	This module aims to promote your guild more and from a diverse range of players by alternating who places recruitment adds in the trade channel. 
	Upon entering a city, the module will place your advert, and then broadcast to all other addons that it has done so. Until leave the city and re-enter, it will not place any more adverts.
	Depending on the interval set by the GM or officer, any other players entering a city within the next X minutes will not place any adverts.
	After X minutes, any player entering a city will once again place an advert.
	As many adverts as you like can be added, and will be synced to other players with the addon. 
	If more than one advert is found, the advert posted will be randomly chosen form all found.
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.4
	Broadcasting alts now works.
	Recieving and recording alts now works.
--========================== 5. To do =================================
	Get the settings for the module working again.
	broadcast needs to handle longer messages
	
]]



GMaster.LoadOrder.GMRecruit = true --can change this to force disable the addon

local module = {}

function GMaster.AL.GMRecruit()

	function GMaster.GFL.GMRecruit()
		
		local save = GMSettings.modules.GMRecruit
		
		if not save.Requests then
			save.Requests = {}
		end
		
		if not save.Messages then
			save.Messages = {}
		end
			
		local function FriendList_Update()
			for i = 1, GetNumWhoResults() do
				local name = GetWhoInfo(i)
				if name == applicant then
				
				end
			end
		end
		
		local old_FreindsEvent = FriendsFrame_OnEvent(self, event, ...)
			
		FriendsFrame_OnEvent = function(self, event, ...)
			if (event == "WHO_LIST_UPDATE") and RECRUIT_WAITING then
				FriendList_Update()
			else	
				old_FreindsEvent(self, event, ...)
			end
		end
	
	
		--[[
			need to hook the buttons and provide a method of delaying the
			functions until the player comes online
			
			GuildRecruitmentInviteButton
			GuildRecruitmentMessageButton
			GuildRecruitmentDeclineButton
				local name, level, class, bQuest, bDungeon, bRaid,
				bPvP, bRP, bWeekdays, bWeekends, bTank, bHealer,
				bDamage, comment, timeSince, timeLeft = GetGuildApplicantInfo(self.index)
		
		--]]
		
		local function QueueInvite(self)
			local name = GetGuildApplicationInfo(GetGuildApplicantSelection())
			
			
			--[[
				check if the player is online
				if they are, invite them
				if they arent, queue the invite
			
			--]]
		
		end
		
		local function QueueMessage()
			local name = GetGuildApplicationInfo(GetGuildApplicantSelection())
			--[[
				--check if the player is online
				--if they are online, ChatFrame_SendTell("playername")
				--if they arent online, record the message and queue it
				
				--if mail box i open, mail the message
				--next time they are online, whisper them
				need to find a way to see if the message was delivered or not
			--]]
		end
		
		GuildRecruitmentInviteButton:HookScript("OnClick", QueueInvite)
		GuildRecruitmentMessageButton:SetScript("OnClick", QueueMessage)
	
	local function Checker(name)
		SetWhoToUI(1)
		SendWho(name)
		RECRUIT_WAITING = true
		
		GMTimer:NewTimer(3, function() RECRUIT_WAITING = nil end, 
	
	end
	--[[
		Checker:
		SetWhoToUI(1)
		set request bool
		SendWho (remember to add name prefix)
		SetWhoToUI(0)
		check who list
	--]]
	
	--character limit 255
	end

	if not module.Eventler then
		module.Eventler = CreateFrame("Frame")
	end
	
	if not GMSettings.GMRecruit then
		GMSettings.GMRecruit = {Active = true, lastsent = 0, delay = 10}
		GMSettings.GMRecruit.list = {}
	end
	
	local Eventler = module.Eventler
	
	
	Eventler.elapsed = 0
	Eventler.interval = 10 --this waits for a few seconds after entering a zone,



	local function Timer(self, elapsed)
		
		Eventler.elapsed = Eventler.elapsed + elapsed
			if Eventler.elapsed > Eventler.interval then
				Eventler.elapsed = 0
				Eventler:SetScript("OnUpdate", nil)
				local i = GetChannelName("Trade") 
				if i > 0 then
					
					SendAddonMessage("GMRecruitPing", time(), "GUILD") -- let other addons know
					if #GMSettings.GMRecruit.list > 0 then
						SendChatMessage(GMSettings.GMRecruit.list[math.random(#GMSettings.GMRecruit.list)].msg, "CHANNEL", nil, i)
					end
				end
			end
	end


	local function EventHandler(self, event, prefix, msg, channel, player)
		if event == "ZONE_CHANGED_NEW_AREA" then
			if time() - GMSettings.GMRecruit.lastsent> (GMSettings.GMRecruit.delay*60) then
				Eventler:SetScript("OnUpdate", Timer)
			end
		elseif event == "CHAT_MSG_ADDON" then
			if prefix == "GMRecruitPing" then
				GMSettings.GMRecruit.lastsent = tonumber(msg)
				
			elseif prefix == "GMRecruitNew" then
				local pos, dated, msg = msg:match("(%d+)|(%d+)|(.+)")
					if pos then
						pos = tonumber(pos)
						dated = tonumber(dated)
						if not GMSettings.GMRecruit.list[pos] then
							GMSettings.GMRecruit.list[pos] = {dated = dated, msg = msg}
						else
							local loc = GMSettings.GMRecruit.list[pos]
							if loc.dated == dated then
								--both the same, do nothing	
							elseif loc.dated < dated then
								--new values, update
								loc.dated = dated
								loc.msg = msg
							elseif loc.dated > dated then
								--it has old values, broadcast new values
								GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMRecruitNew", pos.."|"..loc.dated.."|"..loc.msg}
							end
						end
					end
			end
		
			
				
			
		elseif event == "PLAYER_ENTERING_WORLD" then
			if not GMSettings.GMRecruit then
					GMSettings.GMRecruit = {Active = true, lastsent = 0, delay = 10, list = {}}
			end
			if GMaster.LastLogin < (time() - 3600) then
				for i = 1, #GMSettings.GMRecruit.list do
				local loc = GMSettings.GMRecruit.list[i]
					GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMRecruitNew", i.."|"..loc.dated.."|"..loc.msg}
				end
			end
			GMSettings.GMRecruit.lastsent = time() --stops the first spam when logging in.
			Eventler:UnregisterEvent("PLAYER_ENTERING_WORLD")
		end
	end



	Eventler:RegisterEvent("CHAT_MSG_ADDON")
	Eventler:RegisterEvent("ZONE_CHANGED_NEW_AREA")
	Eventler:RegisterEvent("ADDON_LOADED")
	Eventler:RegisterEvent("PLAYER_ENTERING_WORLD")
	Eventler:SetScript("OnEvent", EventHandler)
end



function GMaster.ModuleSettings.GMRecruit()
	local parent = CreateFrame("Frame")
			parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
			parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
			parent.titleText:SetJustifyH("LEFT")
			parent.titleText:SetJustifyV("TOP")
			parent.titleText:SetText()
			
			--[[
				need option to choose the channel, and the update frequency.
			
			--]]
		return parent
end

function GMaster.ModuleLoad.GMRecruit()
	--enable the module
		GMaster.AL.GMRecruit()
	
end

function GMaster.ModuleRemove.GMRecruit()
	module.eventler:SetScript("OnEvent", nil)
	return true
end--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	advanced guild roster allowing searching by class,name, etc, and 
	extra player stats.
--========================== 2. Details ===============================
	This adds a new customised roster into the guild frame, where the old roster was.
	The new roster is searchable, with results showing as you type them. The searches are limited
	to the columns that are shown, for example if only level and name are shown, they will be 
	the only criteria that the searchbox uses to filter results.
	Rather than switching between different views, a custom view can be created
	by adding and removing columns, as well as repositioning and resizing them.
	The right click popup for guildmembers in the roster has been enhanced to allow
	options for promoting, demoting, and removing members.
	A new detail frame has been added which shows extra player stats recorded by the
	addon, including talents and base stats.
--========================== 3. Structure =============================
	Consists of two parts
	The roster itself:
		SearchBox - the editbox for searches
		RosterChild - the frame containing the roster buttons
		Memberdetail - 3 pages of details specific to the player clicked.
		a list of all guild members
		searchbar to filter guild members
		
	The checker
		a function to update the roster when any changes are made
		and to keep the roster up to date
--========================== 4. Changes ===============================
2.0-23
	bug fix:
		search box iis constrain by the show offline button
		resizing the roster columns no longer changes sort order
		class names in the detail frame start with a capital letter.
		added item level
2.0
	Created the new roster
	added talent sharing
1.5
	- moved the roster update functionality into this module
1.4 - CreateModule
--========================== 5. To do =================================
	-Highlight the selected player in the roster
	-add a method of request player stats if they are online
	-better syncing of player stats.
	-MemberDetail:
		Gear
		Personal Note
	Scrollbars
	
	restructure the 'list' table to neaten it up.
	
	Integrate GMStats
	
	Possible future plans:
		Record reason for kicking.
		Auto mail new members
	
]]




local module = {} -- used for adding functions

local tracker = {} --track roster changes
	tracker.names = {}
	tracker.promoted = {}
	tracker.demoted = {}
	tracker.joined = {}
	tracker.levelled = {}
	tracker.quit = {}

GMaster.LoadOrder.GMRoster = true

GMaster.AL.GMRoster = function()
GMaster.GFL.GMRoster = function()

local Settings = GMSettings.modules.GMRoster
if not Settings.TabLayout then 
	Settings.TabLayout = {}
end


--[[
	new members
	quit members
	
	new applications
	new forum posts

--]]

local SideTabList = {{OnClick = function() end, Tooltip = "New Members", color = {0, 1,0}},
										 {OnClick = function() end, Tooltip = "Members that have quit", color = {1,0,0}},
										  {OnClick = function()GuildFrame_TabClicked(GuildFrameTab5)   PanelTemplates_Tab_OnClick(GuildInfoFrameTab3, GuildInfoFrame); GuildInfoFrame_Update() end, Tooltip = "New Applicants", color = {0,0.8,0}}}
local SideTabPosition = {}

local SideTabContainer = CreateFrame("Frame", nil, GuildFrame)
			SideTabContainer:SetWidth(20)
			SideTabContainer:SetPoint("TOPLEFT", GuildFrame, "TOPRIGHT",0,-30)
			SideTabContainer:SetPoint("BOTTOMLEFT", GuildFrame, "BOTTOMRIGHT")

for i = 1, #SideTabList do --create all of the buttons
	local button = CreateFrame("Button", nil, SideTabContainer)
	button:SetSize(16, 20)
	
	button.middle = button:CreateTexture(nil, "BACKGROUND")
	button.middle:SetTexture("Interface\\SpellBook\\SpellBook-SkillLineTab")
	button.middle:SetPoint("LEFT", -2, 0)
	button.middle:SetTexCoord(0, 0.625, 0.21875, 0.640625)
	button.middle:SetSize(20, 10)
	
	button.top = button:CreateTexture(nil, "BACKGROUND")
	button.top:SetTexture("Interface\\SpellBook\\SpellBook-SkillLineTab")
	button.top:SetPoint("BOTTOM", button.middle, "TOP")
	button.top:SetTexCoord(0, 0.625, 0, 0.21875)
	button.top:SetSize(20, 11)
	
	button.bottom = button:CreateTexture(nil, "BACKGROUND")
	button.bottom:SetTexture("Interface\\SpellBook\\SpellBook-SkillLineTab")
	button.bottom:SetPoint("TOP", button.middle, "BOTTOM")
	button.bottom:SetTexCoord(0,0.625,0.640625,0.875)
	button.bottom:SetSize(20, 15)
	
	button.text = button:CreateFontString(nil, "OVERLAY", "GameFontGreenSmall")
	button.text:SetTextColor(unpack(SideTabList[i].color))
	button.text:SetAllPoints(button)
	
	button.tooltip = SideTabList[i].Tooltip
	
	button:SetScript("OnEnter", function(self) GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
												GameTooltip:SetText(self.tooltip)
								end)
	button:SetScript("OnLeave", function() GameTooltip:Hide() end)
	
	button:SetScript("OnClick", SideTabList[i].OnClick)
	
	
	
	SideTabList[i].button = button --place the button in the table
	
end 

--if #tracker.joined > 0 then
	local button = SideTabList[1].button
	button:Show()
	button:SetPoint("TOPLEFT", SideTabContainer, "TOPLEFT")
	button.text:SetText(#tracker.joined)
	tinsert(SideTabPosition, button)
--end

--if #tracker.quit > 0 then
	local button = SideTabList[2].button
	button:Show()
	if #SideTabPosition == 0 then
		button:SetPoint("TOPLEFT", SideTabContainer, "TOPLEFT")
	else
		button:SetPoint("TOPLEFT", SideTabPosition[#SideTabPosition], "BOTTOMLEFT", 0, -8)
	end
	tinsert(SideTabPosition, button)
	button.text:SetText(#tracker.quit)
--end

if GetNumGuildApplicants() > 0 then
	local button = SideTabList[3].button
	button:Show()
	if #SideTabPosition == 0 then
		button:SetPoint("TOPLEFT", SideTabContainer, "TOPLEFT")
	else
		button:SetPoint("TOPLEFT", SideTabPosition[#SideTabPosition], "BOTTOMLEFT", 0, -8)
	end
	tinsert(SideTabPosition, button)
	button.text:SetText(GetNumGuildApplicants())
end



local function Update_SideTabs()
	SideTabPosition = {}
end


local RosterCache = {}

local MAX_ROSTER_BUTTONS = 21
local TempRoster = {}
local RosterButtons = {}
local offset = 0
local list = { Donations = {Donated = false, Looted = false, Repaired = false},
							Name = false, Rank = false, Class = false, Location = false, Level = false,
							Note = false, LastSeen = false, Chat = false,
							Joined = false}
							
			list["Guild XP"] = {}
			list["Guild XP"]["Weekly XP"] = false
			list["Guild XP"]["Total XP"] = false
			list["Guild XP"]["Weekly Rank"] = false
			list["Guild XP"]["Total Rank"] = false
			
			list["Achievements"] = {}
			list["Achievements"]["Achv Points"] = false
			list["Achievements"]["Achv Rank"] = false
			
			list["Officer Note"] = false
	
				
				
							--[[
							GetGuildRosterPVPRatings doesnt exist yet?
							--]]
local RosterFrame = CreateFrame("ScrollFrame", nil, GuildFrame)
			RosterFrame:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT", 7, -58)
			RosterFrame:SetPoint("BOTTOMRIGHT", GuildFrame, "BOTTOMRIGHT", -9, 20)

local RosterChild = CreateFrame("Frame", nil, GuildFrame)
			RosterChild:SetSize(200, 1000)
			RosterFrame:SetScrollChild(RosterChild)

RosterChild.TabNames = {}
RosterChild.Tabs = {}


local SearchBox = CreateFrame("EditBox", "GMRosterSearchBox", RosterFrame, "InputBoxTemplate")
			SearchBox:SetAutoFocus(false)
			SearchBox:SetSize(160, 30)
			SearchBox:SetPoint("BOTTOMRIGHT", RosterFrame, "TOPRIGHT", -5, 5)
			
local SearchText = RosterFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			SearchText:SetSize(60, 30)
			SearchText:SetPoint("RIGHT", SearchBox, "LEFT")
			SearchText:SetText("Search:")
			---[[
RosterFrame:SetScript("OnMouseWheel", function(self, delta)
      delta = floor(delta)
      local v = self:GetVerticalScroll()
      local h = self:GetHorizontalScroll()

      v = v + delta*10
      h = h + delta*10
      
      if IsShiftKeyDown() then
         if (h > 0 )and h < self:GetHorizontalScrollRange()then
            self:SetHorizontalScroll(h)
         end
      else
				if delta < 0 and (offset+MAX_ROSTER_BUTTONS) <= #TempRoster then
					offset = offset + 1
				elseif delta > 0 and offset > 0 then
					offset = offset - 1
				end
				GMaster.UpdateRoster()
			
         if (v > 0) and (v < self:GetVerticalScrollRange())  then
            --[[
						self:SetVerticalScroll(v )
						local tab = RosterChild.Tabs[1]
						if tab then
							--this bit stops the top tabs moving
							tab:SetPoint("TOPLEFT", 0, -v)
						end
						--]]
         end
         
      end
      
      
end)--]]

--==================================================================================


local MemberDetail = CreateFrame("Frame", nil, RosterFrame)
			MemberDetail:SetSize(250, 375)
			MemberDetail:SetPoint("TOPLEFT", GuildFrame, "TOPRIGHT", 10, -30)
			
			MemberDetail:SetBackdrop({bgFile = "Interface/DialogFrame/UI-DialogBox-Background", 
										edgeFile = "Interface/DialogFrame/UI-DialogBox-Border", 
										tile = true, tileSize = 32, edgeSize = 32, 
										insets = { left = 11, right = 12, top = 12, bottom = 11}})
			MemberDetail:SetBackdropColor(0,0,0,1);
			
			MemberDetail.Pages = {}
			MemberDetail.Tabs = {}
			
			MemberDetail.PageNames = {"General", "Stats", "Talents"}
	
			MemberDetail.Selected = ""
			
			MemberDetail.close = CreateFrame("Button", nil, MemberDetail, "UIPanelCloseButton")
			MemberDetail.close:SetSize(25, 25)
			MemberDetail.close:SetPoint("TOPRIGHT", -7, -7)
			MemberDetail.close:SetScript("OnClick", function() MemberDetail:Hide() MemberDetail.Selected = "" end)
			
			MemberDetail:Hide()
			
local function MemberDetailTabClicked(self)
	for i = 1, #MemberDetail.Pages do
		if MemberDetail.Pages[i] == self.page then
			MemberDetail.CurrentPage = i
			self.page:Show()
		else
			MemberDetail.Pages[i]:Hide()
		end
	end
	GMaster.RefreshMemberDetails()
end	

		for i, name in pairs(MemberDetail.PageNames) do
			local tab = CreateFrame("Button", "GMRosterDetailFrameTab"..i, MemberDetail, "GuildRosterColumnButtonTemplate")
			tab:SetText(name)
			tab:SetSize(60, 22)
			WhoFrameColumn_SetWidth(tab, 60)
			if i == 1 then
				tab:SetPoint("TOPLEFT", MemberDetail, "TOPLEFT", 10, -10)
			else
				tab:SetPoint("LEFT", MemberDetail.Tabs[i-1], "RIGHT")
			end
			tab:SetScript("OnClick", MemberDetailTabClicked)
			tinsert(MemberDetail.Tabs, tab)
			tab.page = CreateFrame("Frame", nil, MemberDetail)
			tab.page:SetAllPoints(MemberDetail)
			tab.page:Hide()
			tab.page.name = name
			tinsert(MemberDetail.Pages, tab.page)
		end
		
	local GeneralLabels = {
												 NameLabel = {xs = 60, ys = 20, text = "Name:", xof = 15, yof = -40, color = {r = 1, g = 1, b = 0}},
												 NameText = {xs = 100, ys = 20, text = "Nametest", xof = 55, yof = -40, color = {r = 1, g = 1, b = 1}},
												 LevelLabel = {xs = 60, ys = 20, text = "Level:", xof = 15, yof = -60, color = {r = 1, g = 1, b = 0}},
												 LevelText = {xs = 60, ys = 20, text = "level", xof = 55, yof = -60, color = {r = 1, g = 1, b = 1}},
												 ClassLabel = {xs = 60, ys = 20, text = "Class:", xof = 15, yof = -80, color = {r = 1, g = 1, b = 0}},
												 ClassText = {xs = 60, ys = 20, text = "class", xof = 55, yof = -80, color = {r = 1, g = 1, b = 1}},
												 ZoneLabel = {xs = 60, ys = 20, text = "Zone:", xof = 15, yof = -100, color = {r = 1, g = 1, b = 0}},
												 ZoneText = {xs = 150, ys = 20, text = "zone", xof = 55, yof = -100, color = {r = 1, g = 1, b = 1}},
												 RankLabel = {xs = 60, ys = 20, text = "Rank:", xof = 15, yof = -120, color = {r = 1, g = 1, b = 0}},
												 NoteLabel = {xs = 130, ys = 20, text = "Public Note:", xof = 15, yof = -150, color = {r = 1, g = 1, b = 0}},
												 ONoteLabel = {xs = 130, ys = 20, text = "Officer Note:", xof = 15, yof = -230, color = {r = 1, g = 1, b = 0}},
												
													}
	local StatLabels = { RESLabel = {xs = 80, ys = 20, text = "Resilience:", xof = 15, yof = -40, color = {r = 1, g = 1, b = 0}},
											 RESText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -40, color = {r = 1, g = 1, b = 1}},
											 
											 HPLabel = {xs = 80, ys = 20, text = "Health:", xof = 15, yof = -60, color = {r = 1, g = 1, b = 0}},
											 HPText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -60, color = {r = 1, g = 1, b = 1}},
											 
											 SPLabel = {xs = 80, ys = 20, text = "Spell Power:", xof = 15, yof = -80, color = {r = 1, g = 1, b = 0}},
											 SPText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -80, color = {r = 1, g = 1, b = 1}},
											  
											 STRLabel = {xs = 80, ys = 20, text = "Strength:", xof = 15, yof = -100, color = {r = 1, g = 1, b = 0}},
											 STRText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -100, color = {r = 1, g = 1, b = 1}},
											  
											 AGILabel = {xs = 80, ys = 20, text = "Agility:", xof = 15, yof = -120, color = {r = 1, g = 1, b = 0}},
											 AGIText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -120, color = {r = 1, g = 1, b = 1}},
											  
											 STALabel = {xs = 80, ys = 20, text = "Stamina:", xof = 15, yof = -140, color = {r = 1, g = 1, b = 0}},
											 STAText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -140, color = {r = 1, g = 1, b = 1}},
											  
											 INTLabel = {xs = 80, ys = 20, text = "Intellect:", xof = 15, yof = -160, color = {r = 1, g = 1, b = 0}},
											 INTText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -160, color = {r = 1, g = 1, b = 1}},
											  
											 SPILabel = {xs = 80, ys = 20, text = "Spirit:", xof = 15, yof = -180, color = {r = 1, g = 1, b = 0}},
											 SPIText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -180, color = {r = 1, g = 1, b = 1}},
											 
											 ILVLLabel = {xs = 80, ys = 20, text = "Item Level:", xof = 15, yof = -180, color = {r = 1, g = 1, b = 0}},
											 ILVLText = {xs = 80, ys = 20, text = "Unkown", xof = 100, yof = -180, color = {r = 1, g = 1, b = 1}},
											 
											 
											}
	do -- page 1
		local tab = MemberDetail.Pages[1]
		for label, info in pairs(GeneralLabels) do
			tab[label] = tab:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			tab[label]:SetSize(info.xs, info.ys)
			tab[label]:SetText(info.text)
			tab[label]:SetJustifyH("LEFT")
			tab[label]:SetTextColor(info.color.r, info.color.g, info.color.b)
			tab[label]:SetPoint("TOPLEFT", tab, "TOPLEFT", info.xof, info.yof)
		end
		
		tab.personal = CreateFrame("Frame", nil, tab)
		tab.personal:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background", 
                                            edgeFile = "Interface/Tooltips/UI-Tooltip-Border", 
                                            tile = true, tileSize = 16, edgeSize = 16, 
                                            insets = { left = 4, right = 4, top = 4, bottom = 4 }});
		tab.personal:SetBackdropColor(0,0,0,1)
		tab.personal:SetHeight(60)
		tab.personal:SetPoint("TOP",0, -170)
		tab.personal:SetPoint("LEFT", 15,0)
		tab.personal:SetPoint("RIGHT", -15,0)
		
		tab.personalEB = CreateFrame("EditBox", "GMRosterPublicEB", tab.personal)
		tab.personalEB:SetPoint("TOPLEFT", 5, -5)
		tab.personalEB:SetPoint("BOTTOMRIGHT", -5,5)
		tab.personalEB:SetFont("Fonts\\FRIZQT__.TTF", 15)
		tab.personalEB:SetAutoFocus(false)
		tab.personalEB:SetMultiLine(true)
		tab.personalEB:SetScript("OnShow", function(self) self:SetTextColor(1,1,1) end)
		tab.personalEB:SetScript("OnEscapePressed", function(self) self:ClearFocus() end)
		tab.personalEB:SetScript("OnEnterPressed", function(self) self:SetTextColor(1,1,1) GuildRosterSetPublicNote(GMRoster[MemberDetail.Selected].index, self:GetText()) end)
		tab.personalEB:SetScript("OnChar", function(self) self:SetTextColor(0, 1, 0) end)
		tab.personalEB:SetMaxLetters(31)
		
		tab.officer = CreateFrame("Frame", nil, tab)
		tab.officer:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background", 
                                            edgeFile = "Interface/Tooltips/UI-Tooltip-Border", 
                                            tile = true, tileSize = 16, edgeSize = 16, 
                                            insets = { left = 4, right = 4, top = 4, bottom = 4 }});
		tab.officer:SetBackdropColor(0,0,0,1)
		tab.officer:SetHeight(60)
		tab.officer:SetPoint("TOP",0, -250)
		tab.officer:SetPoint("LEFT", 15,0)
		tab.officer:SetPoint("RIGHT", -15,0)
		
		
		tab.officerEB = CreateFrame("EditBox", "GMRosterPublicEB", tab.officer)
		tab.officerEB:SetPoint("TOPLEFT", 5, -5)
		tab.officerEB:SetPoint("BOTTOMRIGHT", -5,5)
		tab.officerEB:SetFont("Fonts\\FRIZQT__.TTF", 15)
		tab.officerEB:SetAutoFocus(false)
		tab.officerEB:SetMultiLine(true)
		tab.officerEB:SetScript("OnShow", function(self) self:SetTextColor(1,1,1) end)
		tab.officerEB:SetScript("OnEscapePressed", function(self) self:ClearFocus() end)
		tab.officerEB:SetScript("OnEnterPressed", function(self) self:SetTextColor(1,1,1) GuildRosterSetOfficerNote(GMRoster[MemberDetail.Selected].index, self:GetText()) end)
		tab.officerEB:SetScript("OnChar", function(self) self:SetTextColor(0, 1, 0) end)
		tab.officerEB:SetMaxLetters(31)
		
		GuildMemberRankDropdown:SetParent(tab)
		GuildMemberRankDropdown:ClearAllPoints()
		GuildMemberRankDropdown:SetPoint("TOPRIGHT", MemberDetail, "TOPRIGHT", -5, -120)
	end
	do --page 2
		local tab = MemberDetail.Pages[2]
		for label, info in pairs(StatLabels) do
			tab[label] = tab:CreateFontString(nil, "OVERLAY", "GameFontNormal")
			tab[label]:SetSize(info.xs, info.ys)
			tab[label]:SetText(info.text)
			tab[label]:SetJustifyH("LEFT")
			tab[label]:SetTextColor(info.color.r, info.color.g, info.color.b)
			tab[label]:SetPoint("TOPLEFT", tab, "TOPLEFT", info.xof, info.yof)
		end
	end
	do --page 3
		local page = MemberDetail.Pages[3]
		page.tabs = {}
		page.buttons = {}
		page.subtab = 1
			
		for i = 1, 3 do
			local tab = CreateFrame("Button", nil, page, "UIPanelButtonTemplate")
			tab:SetPoint("TOPLEFT", (i-1)*75+20, -40)
			tab:SetSize(65, 25)
			tab.i = i
			tab:SetScript("OnClick", function(self) page.subtab = self.i GMaster.RefreshMemberDetails() end)
			tinsert(page.tabs, tab)		
		end
		
			for j = 1, 4 do 
				for k = 1, 7 do
					local button = CreateFrame("Button", "GMRosterTalentButton"..j..k, page, "TalentButtonTemplate")
					button.column = j
					button.row = k
					button:SetSize(35, 35)
					button:SetPoint("TOPLEFT", page, "TOPLEFT", 40*j, -40*k - 30)
					button:SetScript("OnEnter", function(self) if self.name then GameTooltip:SetOwner(self, "ANCHOR_RIGHT") GameTooltip:SetText(self.name) end end)
					button:SetScript("OnLeave", function(self) GameTooltip:Hide() end)
				_G[button:GetName().."NormalTexture"]:ClearAllPoints()
				_G[button:GetName().."NormalTexture"]:SetAllPoints(button)
				_G[button:GetName().."NormalTexture"]:SetDesaturated(true)
				_G[button:GetName().."Slot"]:Hide()
					tinsert(page.buttons, button)
				end
			end
	end

function GMaster.RefreshMemberDetails(name)
	if name then
		MemberDetail.Selected = name
	else
		name = MemberDetail.Selected
	end
	if not MemberDetail.CurrentPage then
		MemberDetail.Pages[1]:Show()
		MemberDetail.CurrentPage = 1
	end
	

	local player = GMRoster[name]

		MemberDetail.Pages[1].NameText:SetText(name)
		MemberDetail.Pages[1].LevelText:SetText(player.level)
		MemberDetail.Pages[1].ClassText:SetText(player.classname)
		MemberDetail.Pages[1].ZoneText:SetText(player.zone)
		
		
		
		if player.Note then
			MemberDetail.Pages[1].personalEB:SetText(player.Note)
		else
			MemberDetail.Pages[1].personalEB:SetText("")
		end
		
		if player.ONote and	CanViewOfficerNote() then
			MemberDetail.Pages[1].officerEB:SetText(player.ONote)
		else
			MemberDetail.Pages[1].officerEB:SetText("")
		end
		
		if CanEditPublicNote() then
			MemberDetail.Pages[1].personalEB:Enable()
		else
			MemberDetail.Pages[1].personalEB:Disable()
		end
		
		if CanEditOfficerNote() then
			MemberDetail.Pages[1].officerEB:Enable()
		else
			MemberDetail.Pages[1].officerEB:Disable()
		end
		
		MemberDetail.Pages[1].personalEB:SetTextColor(1,1,1)
		MemberDetail.Pages[1].officerEB:SetTextColor(1,1,1)
		
		do --page 2
			local Page2 = MemberDetail.Pages[2]
			local stats = {"RES", "HP", "SP", "STR", "AGI", "STA", "INT", "SPI", "ILVL" }
			if player.Stats then
				for i, st in pairs(stats) do
					local value = player.Stats:match(st.."(%d+)|")
					if value then
						Page2[st.."Text"]:SetText(value)
					else
						Page2[st.."Text"]:SetText("Unkown")
					end
				end
			else
				for i, st in pairs(stats) do
					Page2[st.."Text"]:SetText("Unkown")
				end
			end
		end
		
		local pg = MemberDetail.Pages[3]
		local cls = GMRoster[name].classname
		local i = 0
	for i, info in pairs(GMaster.TalentDB[cls]) do
		
		pg.tabs[i]:SetText(info.name)
		if i == pg.subtab then
			
			for _, button in pairs(pg.buttons) do
				
				button:Hide()
			
				_G[button:GetName().."Rank"]:SetText("0")
				_G[button:GetName().."Rank"]:Hide()
				_G[button:GetName().."RankBorder"]:Hide()
			end
		
			for k, but in pairs(info.data) do
				for j = 1, #pg.buttons do
					local button = pg.buttons[j]
					if button.row == but[3] and button.column == but[4] then
						button:SetNormalTexture(but[2])
						
						button.name = but[1]
						button:Show()
					end
				end
			end			
		end
	end	
	
	if player.Spec then
		local i = 0
		for spec in player.Spec:gmatch("||(%d+)") do
			i = i + 1
			if pg.subtab == i then
				for set in spec:gmatch("%d%d%d") do
					for row, column, value in set:gmatch("(%d)(%d)(%d)") do
						for i = 1, #pg.buttons do
							local button = pg.buttons[i]
							if button.column == tonumber(column) and button.row == tonumber(row) then
							local tex = button:GetNormalTexture()
								_G[button:GetName().."NormalTexture"]:SetDesaturated(false)
								if tonumber(value) > 0 then
								_G[button:GetName().."Rank"]:SetText(value)
								_G[button:GetName().."Rank"]:Show()
								_G[button:GetName().."RankBorder"]:Show()
								else
									_G[button:GetName().."NormalTexture"]:SetDesaturated(true)
								end
							end
						end
					end
				end
			end			
		end
	end
	--needs converting
	for i = 1, GetNumGuildMembers(true) do
		local n = GetGuildRosterInfo(i)
		if n == name then
			SetGuildRosterSelection(i)
		end
	end	
	UIDropDownMenu_SetText(GuildMemberRankDropdown, GuildControlGetRankName(GMRoster[name].rank+1));
	MemberDetail:Show()
end

function GuildMemberRankDropdown_OnClick(self, newRankIndex)
	local name, rank, rankIndex = GetGuildRosterInfo(GetGuildRosterSelection());
	SetGuildMemberRank(GetGuildRosterSelection(), newRankIndex);
	UIDropDownMenu_SetText(GuildMemberRankDropdown, GuildControlGetRankName(newRankIndex));
end

local function RosterButton_Clicked(self, button)
	local name = self.strings.Name:GetText()
	local player = GMRoster[name]
	if button == "LeftButton" then
		if player then
			if MemberDetail:IsShown() and MemberDetail.Selected == name then
				MemberDetail.Selected = ""
				MemberDetail:Hide()
			else
				GMaster.RefreshMemberDetails(name)
			end
		end
	else
		if player then
			FriendsFrame_ShowDropdown(name, GMRoster[name].online)
		end
	end
end

local function NewButton()
--create the button
local button = CreateFrame("Button", nil, RosterChild)
	button:EnableMouse(true)
--set its properties
	button:SetHeight(15)
	
	
	button.bg = button:CreateTexture(nil, "BACKGROUND")
	button.bg:SetTexture("Interface\\GuildFrame\\GuildFrame")
	button.bg:SetTexCoord(0.36230469,0.38183594,0.95898438,0.99804688)
	button.bg:SetAllPoints(button)
	
	button.strings = {}
	
	for name, value in pairs(list) do
		if type(value) == "table" then
			for name, v in pairs(value) do
				button.strings[name] = button:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
				button.strings[name]:SetPoint("TOP", button, "TOP")
				button.strings[name]:SetPoint("BOTTOM", button, "BOTTOM")
				button.strings[name]:SetJustifyH("LEFT")
			end
		else
			button.strings[name] = button:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
			button.strings[name]:SetPoint("TOP", button, "TOP")
			button.strings[name]:SetPoint("BOTTOM", button, "BOTTOM")
			button.strings[name]:SetJustifyH("LEFT")

		end
	end
	
	button.icon = button:CreateTexture()
	button.icon:SetSize(15, 15)
	button.icon:SetTexture("Interface\\Glues\\CharacterCreate\\UI-CharacterCreate-Classes")
	button.icon:SetPoint("TOP")
	
	button:SetPoint("LEFT", RosterChild, "LEFT", 5, 0)
	button:SetPoint("RIGHT", RosterChild, "RIGHT", -5, 0)
--set its location
	if #RosterButtons < 1 then
		button:SetPoint("TOP", RosterChild, "TOP", 0, -25)
	else
		button:SetPoint("TOP", RosterButtons[#RosterButtons], "BOTTOM")
	end
	button:SetScript("OnMouseUp", RosterButton_Clicked)
	tinsert(RosterButtons, button)
	RosterChild:SetHeight(#RosterButtons*20 + 30)
	return button
end

for i = 1, MAX_ROSTER_BUTTONS do
	NewButton()
end

local function ConvertLastSeen(name)
local lastseen = GMRoster[name].LastSeen
	if lastseen then
		if tonumber(lastseen) == 0 then
			return "Online"
		elseif lastseen == 1 then
			return "< an hour"
		else
			return date("%d/%m/%y", (time() -lastseen))
		end
	end
end

local convertlist = { Donations = {Donated = false, Looted = false, Repaired = false},
							Name = function(name) return name end,
							Rank = function(name) return GuildControlGetRankName(GMRoster[name].rank+1) end,
							Class = function(name) return GMRoster[name].classname end,
							Location = function(name) return GMRoster[name].zone end,
							Level = function(name) return GMRoster[name].level end,
							Note = function(name) return GMRoster[name].Note end,
							Chat = function(name) if RosterCache[name] then return RosterCache[name][3] or "0" else return 0 end end,
							LastSeen = ConvertLastSeen,
							Joined = function(name) return date("%x", GMRoster[name].firstseen) end,
							}

convertlist["Officer Note"] = function(name) return GMRoster[name].ONote end
convertlist["Weekly XP"] = function(name) return GMRoster[name]["Weekly XP"] end
convertlist["Weekly Rank"] = function(name) return GMRoster[name]["Weekly Rank"] end
convertlist["Total XP"] = function(name) return GMRoster[name]["Total XP"] end
convertlist["Total Rank"] = function(name) return GMRoster[name]["Total Rank"] end
convertlist["Achv Rank"] = function(name) return GMRoster[name]["Achv Rank"] end
convertlist["Achv Points"] = function(name) return GMRoster[name]["Achv Total"] end




function GMaster.UpdateRoster()
		--hide all buttons and child fontstrings
		for i = 1, #RosterButtons do
			local button = RosterButtons[i]
			for name, fontstring in pairs(button.strings) do
				fontstring:Hide()
			end
			button:Hide()
			button.icon:Hide()
		end

	for i = 1, #RosterButtons do
		local button = RosterButtons[i]
		local player = GMRoster[TempRoster[i+offset]]
		if player then
		button:Show()
		for name, fontstring in pairs(button.strings) do
			if RosterChild.TabNames[name] then
				fontstring:SetPoint("LEFT", RosterChild.TabNames[name],"LEFT", 3, 0)
				fontstring:SetPoint("RIGHT", RosterChild.TabNames[name],"RIGHT", -3, 0)
			
				if name == "Name" or name == "Class" then
					local color = RAID_CLASS_COLORS[strupper(player.class)]
					if player.online then
						fontstring:SetTextColor(color.r, color.g, color.b, 1)
					else
						fontstring:SetTextColor(color.r/1.5, color.g/1.5, color.b/1.5, 1)
					end
				else
					fontstring:SetTextColor(1, 1, 1, 1)
				end
				
				fontstring:SetParent(RosterChild.TabNames[name])
				fontstring:SetText(convertlist[name](TempRoster[i+offset]))
				
				fontstring:Show()
			end
		end
		if button.strings.Class:IsVisible() then
			if button.strings.Class:GetRight() - button.strings.Class:GetLeft() < 40 then
				button.strings.Class:Hide()
				button.icon:Show()
				button.icon:SetPoint("LEFT", RosterChild.TabNames.Class, "LEFT")
				local a,b,c,d = unpack(CLASS_ICON_TCOORDS[player.class])
				button.icon:SetTexCoord(a+0.01, b-0.01, c+0.01, d-0.01)
			else
				button.icon:Hide()
				button.strings.Class:Show()
			end
			
		end
		if not RosterChild.TabNames.Class then
			button.icon:Hide()
		end
		button:Show()
		end
	end
end

local function Sorter(a, b)
	
	--special conditions
	if SortBy == "Joined" then
		return GMRoster[a].firstseen > GMRoster[b].firstseen
	elseif SortBy == "-Joined" then
		return GMRoster[a].firstseen < GMRoster[b].firstseen
	elseif SortBy == "Rank" then
		return GMRoster[a].rank < GMRoster[b].rank
	elseif SortBy == "-Rank" then
		return GMRoster[a].rank > GMRoster[b].rank
	elseif SortBy == "Chat" then
		if RosterCache[a] and RosterCache[b] then
			return RosterCache[a][3] < RosterCache[b][3]
		else
			return false
		end
	elseif SortBy == "-Chat" then
		if RosterCache[a] and RosterCache[b] then
			return RosterCache[a][3] > RosterCache[b][3]
		else
			return false
		end
	end
	
	--general conditions
	local rev, test = SortBy:match("^(%-)(.+)")
	test = test or SortBy
	if convertlist[test] then
		if rev then
			return convertlist[test](a) > convertlist[test](b)
		else
			return convertlist[test](a) < convertlist[test](b)
		end
		return
	end
end

local function FilterResults(name, info, msg)
	for label, tab in pairs(RosterChild.TabNames) do
		local str = convertlist[label](name)
		if str then
			str = tostring(str)
			str = strlower(str)
			if str:match(msg) then
				tinsert(TempRoster,name)
				return
			end
		end
	end
	
end
	
local function RefreshSelection(reset)
	if not RosterFrame:IsVisible() then 
		return 
	end
	if reset then
		offset = 0
	end
	local msg = SearchBox:GetText()
	msg = strlower(msg)
	--need to select members who match the text in the box
	--potentially make it only apply to the tabs that are shown
	TempRoster = {}
	for name, info in pairs(GMRoster) do
		if (not msg) or (msg == " ") or (msg == "") then --if the searchbox is empty
			if info.online or GetGuildRosterShowOffline() then
				tinsert(TempRoster, name)
			end
		else --filter resutls based on text
			if info.online or GetGuildRosterShowOffline() then
				FilterResults(name, info, msg)
			end
		end
	end
	--sort the list

	if SortBy then
		table.sort(TempRoster, Sorter)
	end
	-- after sorting, need to add in alts
	
	--update the roster
	
	
	GMaster.UpdateRoster()
end
GMaster.RefreshRoster = RefreshSelection
SearchBox:SetScript("OnTextChanged", function() RefreshSelection(true) end)



local function Update_Tabs()
	local totalwidth = 0 
	for i, tab in pairs(RosterChild.Tabs) do
		tab:ClearAllPoints()
		if i ==1 then
			tab:SetPoint("TOPLEFT", RosterChild, "TOPLEFT")
		else
			tab:SetPoint("LEFT", RosterChild.Tabs[i-1], "RIGHT", 0, 0)
		end
		totalwidth = totalwidth + tab:GetWidth()
		tab.position = i
	end
	RosterChild:SetWidth(totalwidth)
end

local function Tab_Dragging(self, elapsed)
self.downtime = self.downtime + elapsed
	if self.downtime > 1  then
		if not self.dragging then
			self.dragging = true
			tremove(RosterChild.Tabs, self.position)
			tremove(Settings.TabLayout, self.position)
			self.width = self:GetWidth()
			self:SetWidth(50)
			WhoFrameColumn_SetWidth(self, 50)
			Update_Tabs()
		else
			self:ClearAllPoints()
			local r, l = RosterFrame:GetRight(),  RosterFrame:GetLeft() 
			local x, y = GetCursorPosition() 
			
			x = x/UIParent:GetEffectiveScale() 
				
			if x > l and x < r then
				self:SetPoint("CENTER", UIParent, "BOTTOMLEFT", x, self.center)
			end
		end
	end	
end

local function Tab_Sizing(self)
	local r, l = self:GetRight(),  self:GetLeft() 
	local x, y = GetCursorPosition() 
	
	x = x/UIParent:GetEffectiveScale() 
		
		if x > (l+20) and x < (l+250) then
			self:SetWidth(x-l)
			WhoFrameColumn_SetWidth(self, (x-l))
			Settings.TabLayout[self.position].width = floor((x-l))
		end
end

local function Tab_MouseDown(self, button)
	if (button == "LeftButton") then
		self.downtime = 0
		self.dragging = nil
		local r, l = self:GetRight(),  self:GetLeft() 
		local x, y = GetCursorPosition() 
		_, self.center = self:GetCenter()
		x = x/UIParent:GetEffectiveScale()
		
		if x < (r) and x > (r-10) then
			self:SetScript("OnUpdate", Tab_Sizing)
			self.sizing = true
		else
			
			self:SetScript("OnUpdate", Tab_Dragging)
		end
	elseif button == "RightButton" then
		--show dropdown
		ToggleDropDownMenu(1, nil, RosterChild.Category, self, 30, 20)
	end
end

local function Tab_MouseUp(self, button)
	self:SetScript("OnUpdate", nil)
	if button == "LeftButton" then
		if self.sizing then
	
			self.sizing = nil
			self:SetScript("OnUpdate", nil)
		elseif self.dragging then
			self:SetScript("OnUpdate", nil)
			self:SetWidth(self.width)
			WhoFrameColumn_SetWidth(self, self.width)
			
			local center = self:GetCenter()
			local found 
			for i, tab in pairs(RosterChild.Tabs) do
				if tab == self then
					return
				end
				
				local tl, tr = tab:GetLeft(), tab:GetRight()
				local tc = tab:GetCenter()
				if center > tl and center < tc then
					tinsert(RosterChild.Tabs, tab.position, self)
					tinsert(Settings.TabLayout, tab.position, {label = self:GetText(), width = floor(self:GetWidth())})
					Update_Tabs()
					found = true
				elseif center > tc and center < tr then
					tinsert(RosterChild.Tabs, tab.position+1, self)
					tinsert(Settings.TabLayout, tab.position+1, {label = self:GetText(), width = floor(self:GetWidth())})
					Update_Tabs()
					found = true
				end
			end
			if not found then
				tinsert(RosterChild.Tabs, self)
				tinsert(Settings.TabLayout, {label = self:GetText(), width = floor(self:GetWidth())})
			end
		else
			if SortBy == self:GetText() then
				SortBy = "-"..self:GetText()
			else
				SortBy = self:GetText()
			end
			RefreshSelection(true)
		end
		Update_Tabs()	
	else
		self:StopMovingOrSizing()
	end
end



local TAB_HEIGHT = 20

local function NewTab(label)
	local tab = CreateFrame("Button", "GMRosterTab"..label, RosterChild, "GuildRosterColumnButtonTemplate")

	tab:SetScript("OnClick",nil) --remove the preset
	tab:SetMovable(true)
	tab:SetResizable(true)
	tab:SetScript("OnMouseDown", Tab_MouseDown) --need to add sorting by tab
	tab:SetScript("OnMouseUp", Tab_MouseUp)
	
	tab:SetSize(60, TAB_HEIGHT)
	_G[tab:GetName().."Left"]:SetHeight(TAB_HEIGHT)
	_G[tab:GetName().."Middle"]:SetHeight(TAB_HEIGHT)
	_G[tab:GetName().."Right"]:SetHeight(TAB_HEIGHT)
	WhoFrameColumn_SetWidth(tab, 60)
	local fs = tab:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
	
	fs:SetPoint("TOPLEFT", tab, "TOPLEFT", 3, 0)
	fs:SetPoint("BOTTOMRIGHT", tab, "BOTTOMRIGHT", -3, 0)
	fs:SetJustifyH("LEFT")
	fs:SetJustifyV("MIDDLE")
	tab:SetFontString(fs)
	return tab
end 




local function Roster_Shown(self)
	
end

RosterFrame:SetScript("OnShow", Roster_Shown)


local function DropDown_Clicked(self, label, value)
	local tab = RosterChild.TabNames[label]
	if value then --the tab is shown
		if tab and tab:IsShown() then
			tab:Hide()
			tremove(RosterChild.Tabs, tab.position)	
			tremove(Settings.TabLayout, tab.position)
			
		end			
	else --tab isnt shown, needs to be shown or created.
		if not tab then
			tab = NewTab(label)
			RosterChild.TabNames[label] = tab
			tab:SetText(label)
			tab:Show()
			tab.position = #RosterChild.Tabs + 1
			tinsert(RosterChild.Tabs, tab)
			if not Settings.TabLayout[tab.position] then
				tinsert(Settings.TabLayout, tab.position, {label = label, width = 60})
			end
			RefreshSelection()
		end	
		if not tab:IsShown() then
			tab:Show()
			tab.position = #RosterChild.Tabs + 1
			tinsert(RosterChild.Tabs, tab)
			if not Settings.TabLayout[tab.position] then
				tinsert(Settings.TabLayout, tab.position, {label = label, width = 60})
			end
		end
		
	end		
	Update_Tabs()
end


RosterChild.Category = CreateFrame("Frame", "GMRosterDD", AskFrame, "UIDropDownMenuTemplate")

	UIDropDownMenu_SetWidth(RosterChild.Category, 60)
	UIDropDownMenu_SetButtonWidth(RosterChild.Category, 50)

	function RosterChild.Category_Initialize(self, level)
		level = level or 1
		local info = UIDropDownMenu_CreateInfo()
		local value = UIDROPDOWNMENU_MENU_VALUE
		
		info.isNotRadio = true
		for label, v in pairs(list) do
			if not (label == "Officer Note" and not CanViewOfficerNote()) then
			
			if type(v) == "table" then
				if level == 1 then
					info = UIDropDownMenu_CreateInfo()
					info.isNotRadio = true
					info.notCheckable = true
					info.hasArrow = true
					info.text = label
					info.value = label
					info.func =  function(self) end

					UIDropDownMenu_AddButton(info, level)
				elseif level == 2 and value == label then	
									
					for label2, v2 in pairs(v) do
						info = UIDropDownMenu_CreateInfo()
						info.isNotRadio = true
						info.text = label2
						info.value = label2
						info.checked = v2
						info.func =  function(self) list[label][label2] = not v2 DropDown_Clicked(self, label2, v2) end
						UIDropDownMenu_AddButton(info, level)				
					
					end
				end
			else
				if level == 1 then
				info = UIDropDownMenu_CreateInfo()
				info.isNotRadio = true
				info.text = label
				info.value = label
				info.checked = v
				info.func =  function(self) list[label] = not v DropDown_Clicked(self, label, v) end
				UIDropDownMenu_AddButton(info, level)
				end
			end
			end
		end
	end
UIDropDownMenu_Initialize(RosterChild.Category, RosterChild.Category_Initialize, "MENU")
	--UIDropDownMenu_SetText(RosterChild.Category, 0, true)



--this needs to be made dynamic
DropDown_Clicked(nil, "Name", false)

list.Name = true


for i, info in pairs(Settings.TabLayout) do
	
	if not list[info.label] == true then
		DropDown_Clicked(nil, info.label, false)
	end
	for name, value in pairs(list) do
		if type(value) == "table" then
			if value[info.label] == false then
				list[name][info.label] = true
			end
		else
			if name == info.label then
				list[info.label] = true
			end
		end
	end
	
	RosterChild.TabNames[info.label]:SetWidth(info.width)
		WhoFrameColumn_SetWidth(RosterChild.TabNames[info.label], info.width)
end
Update_Tabs()
--===========================================================================================


		local function EditRosterDD(self)
			if self == FriendsDropDown then
					local info = UIDropDownMenu_CreateInfo();
				if CanGuildPromote() then
					info.text = "Promote"
					info.func = function() GuildPromote(self.name) end
					info.notCheckable = true
					UIDropDownMenu_AddButton(info);
					
					info.text = "Demote"
					info.func = function() GuildDemote(self.name) end
					info.notCheckable = true
					UIDropDownMenu_AddButton(info);
				end
				if CanGuildRemove() then
					info.text = "Remove"
					info.func = function() GuildUninvite(self.name) end
					info.notCheckable = true
					UIDropDownMenu_AddButton(info);
				end
			end
		end
			
	hooksecurefunc("UIDropDownMenu_Initialize", EditRosterDD)

--===========================================================================================
	
	local function GuildTabButtonClicked(self)
		local tabIndex = self:GetID();
		if tabIndex == 2 then
			if Settings.active then
				GuildRosterFrame:Hide()
				GuildFrameInset:SetPoint("TOPLEFT", 3, -78);
				GuildFrameInset:SetPoint("BOTTOMRIGHT", -5, 4);
				
				RefreshSelection(true)
				RosterFrame:Show()
				GuildRosterShowOfflineButton:SetParent(GuildFrame)
			end
		else
			GuildRosterShowOfflineButton:SetParent(GuildRosterFrame)
			RosterFrame:Hide()
		end
	end
	
	hooksecurefunc("GuildFrame_TabClicked", GuildTabButtonClicked)
	GuildRosterShowOfflineButton:HookScript("OnClick", RefreshSelection)
	
--end -- end of GFL
	
	
--if GMaster.LastLogin < (time() - 3600) then
	local msg = ""
	msg = msg.."RES"..GetCombatRating(COMBAT_RATING_RESILIENCE_PLAYER_DAMAGE_TAKEN).."|"
	msg = msg.."HP"..UnitHealthMax("player").."|"
	msg = msg.."SP"..GetSpellBonusHealing().."|"
	msg = msg.."STR"..UnitStat("player", 1).."|"
	msg = msg.."AGI"..UnitStat("player", 2).."|"
	msg = msg.."STA"..UnitStat("player", 3).."|"
	msg = msg.."INT"..UnitStat("player", 4).."|"
	msg = msg.."SPI"..UnitStat("player", 5).."|"
	msg = msg.."ILVL"..floor(GetAverageItemLevel()).."|"
	GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMRosStat", msg}
--end
	
		
--[[
	stats needed
	health - UnitHealthMax("player")
	mana - powerType, powerTypeString = UnitPowerType(UnitId);
	item level - floor(GetAverageItemLevel())
	

	
	hit chance - GetCombatRatingBonus
	
	
--]]


local function SendSpec()
	local test = ""
	for t=1, GetNumTalentTabs() do
		test = test.."||"
		 for i=1, GetNumTalents(t) do
				nameTalent, icon, row, column, currRank, maxRank= GetTalentInfo(t,i);
				test = test..row..column..currRank
		 end
	end
	GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMRosTal", test}
end

function GMaster.CMA.GMRoster(prefix, msg, channel, player)
	if prefix == "GMRosTal" then
		if GMRoster[player] then
			GMRoster[player].Spec = msg			
		end
	elseif prefix == "GMRosStat" then
		GMRoster[player].Stats = msg
	end
end

GMTimer:NewTimer(10, SendSpec)

end
end



--===========================================================================================
--===========================================================================================
--===========================================================================================
--===========================================================================================
--===========================================================================================
--===========================================================================================
--===========================================================================================




local function UpdateCache()
GMaster.Debug("Updating cache")
RosterCache = {}

	for dated,players in pairs(GMLogs) do
		for name, info in pairs(players) do
			if name ~= "LastRecord" then
				if RosterCache[name] then --if the name is already in the cache
					for i = 1, #info do
						if i > 9 and i < 16 then --if its a top score
							if RosterCache[name][i] then
								if info[i] > RosterCache[name][i] then --if its higher 
									RosterCache[name][i] = 0 + info[i] --replace it
								end
							else
								RosterCache[name][i] = 0 + info[i]
							end
						else -- add it to the previous numbers
							if RosterCache[name][i] then
								RosterCache[name][i] = RosterCache[name][i] + info[i]
							else
								RosterCache[name][i] = 0 +info[i]
							end
						end
					end
				else
					RosterCache[name]  = {unpack(info)}
				end	
			end
		end
	end
end

--===========================================================================================



	local firstrun = true
	
	local cachecount = 0
	
function GMaster.RosterUpdate() --need to merge the two parts of this function to reduce the number of calls to GetGuildRosterInfo(i)
	 --[[
		It seems that the roster event is called multiple times upon first log in, 
		sometimes when the guild roster is not yet readable
		
		new method:
		set up some temp tables to track changes
		report them once the correct number of guildies is seen
	 --]]
	 
	
	 if not GMSettings.modules.GMRoster.active then
		return
	 end
	 
	 if cachecount > 9 then
		cachecount = 1
		UpdateCache()
	 end
	 cachecount = cachecount + 1
	 
	 for i = 1, GetNumGuildMembers(true) do
			local name, rank, rankIndex, level, class, zone, note, onote, online, _, classFileName, achiPoint, achiRank=  GetGuildRosterInfo(i)
			local year, month, day, hour = GetGuildRosterLastOnline(i)
			local weeklyXP, totalXP, weeklyRank, totalRank = GetGuildRosterContribution(i);
				--ViewGuildRecipes(skillID)
				
			if name then
				tracker.names[name] = true
				local player = GMRoster[name]
				if player then -- they have already been seen 
					if rankIndex > player.rank then
						tinsert(tracker.promoted, {name = name, oldrank = player.rank, newrank = rankIndex})
					elseif rankIndex < player.rank then
						tinsert(tracker.demoted, name)
					end
					if level > player.level then
						tinsert(tracker.levelled, {name = name, oldlevel = player.level, newlevel = level})
					end
				else
					tinsert(tracker.joined, name)
					GMRoster[name] = {class = classFileName, level = level, rank = rankIndex, online = online, Alts = {}}
					player = GMRoster[name]
				end	
				
				player.online = online

				if not online then --needs removing/moving to locator b
					player.zx = nil
					player.zy = nil
					player.cx = nil
					player.cy = nil
					player.zcont = nil
					player.zzone = nil
					player.ccont = nil
					player.czone = nil
				end
				player.index = i
				player.Note = note or ""
				player.ONote = onote or ""
				player.rank = rankIndex
				player.level = level
				player.zone = zone or ""
				
				player["Achv Rank"] = achiPoint 
				player["Achv Total"] = achiRank
				
				player["Weekly XP"] = weeklyXP
				player["Total XP"] = totalXP
				player["Weekly Rank"] = weeklyRank
				player["Total Rank"] = totalRank
				
				if hour then
					local val = ((((year*12)+month)*30.5+day)*24+hour)*3600
					if val > 0 then
						player.LastSeen = val
					else
						player.LastSeen = 1
					end
				else
					player.LastSeen = 0
				end
				
				
				if not player.firstseen then
					player.firstseen = time()
				end
				
				player.class = classFileName
				player.classname = class
			end
	 end

	local function PrintChanges()
		if firstrun then
			if tracker.names ~= {} then
				for name, info in pairs(GMRoster) do --check who has left the guild
					if not tracker.names[name] then
						tinsert(tracker.quit, name)
						GMRoster[name] = nil
					end
				end
				
				local msg 
				local count = 0
				for i = 1, #tracker.joined do
					if i == 1 then
						msg = tracker.joined[i]
						count = count + 1
					elseif i == #tracker.joined then
						msg = msg.." and "..tracker.joined[i]
						count = count + 1
					else
						msg = msg..", "..tracker.joined[i]
						count = count + 1
					end
				end
					
				if	count == 1 then
					print(msg.." has joined the guild")
				elseif count > 1 then
					print(msg.." have joined the guild")
				end
					
				msg = ""
				count = 0
				
				for i = 1, #tracker.quit do
					if i == 1 then
						msg = tracker.quit[i]
						count = count + 1
					elseif i == #tracker.quit then
						msg = msg.." and "..tracker.quit[i]
						count = count+1
					else
						msg = msg..", "..tracker.quit[i]
						count = count + 1
					end
				end
					
				if count == 1 then
					print(msg.." has left the guild")
				elseif count > 1 then
					print(msg.." have left the guild")
				end
					
				firstrun = nil
			end
		end
	end
	GMTimer:NewTimer(30, PrintChanges)
	if GMaster.RefreshRoster then
			GMaster.RefreshRoster(nil)
	end
end




function GMaster.ModuleSettings.GMRoster()
	if not module.settings then

		local parent = CreateFrame("Frame")
				parent.titleText = parent:CreateFontString(nil, "OVERLAY", "GameFontNormal")
				parent.titleText:SetPoint("TOPLEFT", parent, "TOPLEFT", 30, -40)
				parent.titleText:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -30, 40)
				parent.titleText:SetJustifyH("LEFT")
				parent.titleText:SetJustifyV("TOP")
				parent.titleText:SetText("GM-Roster adds a search bar to the guild roster and adds extra stats to the guild member detail frame"..
																	", including talents and gear")
		module.settings = parent
	end
return module.settings

end

function GMaster.ModuleLoad.GMRoster()
	
	GMaster.AL.GMRoster()
	
	if GMaster.GUILD_FRAME_LOADED then
		GMaster.GFL.GMRoster()
	else
		LoadAddOn("Blizzard_GuildUI")
	end
	--create settings page
	
	
end

function GMaster.ModuleRemove.GMRoster()
	
	return true
end



--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Schedule events, message of the day announcements, etc
--========================== 2. Details ===============================
	Not yet written
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.52 Created the addon
--========================== 5. To do =================================
Everything

]]

--[[

potential ideas:
use the ingame calender
create a nerw calender











--]]



--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Interface options for the addon: control which modules are loaded, 
	and the settings for each module.
--========================== 2. Details ===============================
	Each module has its own function for loading itself, unloading itself, 
	and displaying options. This module provides a method of calling the modules
	functions, and will eventually provide a few other general options.
	
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.52:
	Each module now stores its own settings. This module loads other modules
	settings and displays them in the interface options menu.
1.40:
	Made each module properly modular, added toggling of each module.
--========================== 5. To do =================================
	Add method of removing alts if they changed guilds
	integrate the alts feature into all of the other modules that need it.
]]

--[[
1. About
2. Changes
3. To do.
4. Known Issues

--========================== 1. About ===============================

--========================== 2. Changes ==============================

--========================== 3. To do ================================
	
	Need to sync settings

]]

function RemoveInterfaceOptions(Parent, Child) --remove the interface option frame
		local bChildPanel = true;
		if (Child == nil) then -- Assume we are removing the whole panel if no child was specified
			Child = Parent;
			bChildPanel = false;
		else

		end;

		for Key,Value in pairs(INTERFACEOPTIONS_ADDONCATEGORIES) do
			if (bChildPanel and ((Value.parent == Parent) and (Value.name == Child))) then -- We are looking for a child panel and this is it...
				INTERFACEOPTIONS_ADDONCATEGORIES[Key] = nil;
			end;
			
			if (not(bChildPanel) and ((Value.parent == nil) and (Value.name == Child))) then -- We are looking for a parent and this is it...
				INTERFACEOPTIONS_ADDONCATEGORIES[Key] = nil;
			elseif (not(bChildPanel) and ((Value.parent == Parent))) then -- We are looking for a parent and this is it's child...
				INTERFACEOPTIONS_ADDONCATEGORIES[Key] = nil;
			end;
		end;

		InterfaceAddOnsList_Update();
 end;



function GMaster.GMSettings()

	local GMConfiger = CreateFrame("Frame") -- all config stuff
	GMConfiger.name = "GuildMaster"
	GMConfiger.Sync = CreateFrame("Frame")
	GMConfiger.Sync.name = "GM-Sync"
	GMConfiger.Sync.parent = "GuildMaster"
	InterfaceOptions_AddCategory(GMConfiger)

	---[[
	for name, value in pairs(GMaster.LoadOrder) do
		
		if GMSettings.modules[name] and GMSettings.modules[name].active and GMaster.ModuleSettings[name] then
			local setting = GMaster.ModuleSettings[name]()
			setting.parent = "GuildMaster"
			setting.name = name
		
			InterfaceOptions_AddCategory(setting)
		end
	end
	--]]


--========================== Main Page ==========================
	GMConfiger.titleText = GMConfiger:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	GMConfiger.titleText:SetPoint("TOPLEFT", GMConfiger, "TOPLEFT", 30, -40)
	GMConfiger.titleText:SetPoint("BOTTOMRIGHT", GMConfiger, "BOTTOMRIGHT", -30, 40)
	GMConfiger.titleText:SetJustifyH("LEFT")
	GMConfiger.titleText:SetJustifyV("TOP")


--=============== GuildMaster =============================

--enable storing data in guild info?
--[[
fonstring: while most of the data and settings can be synced between addons, some features require settings 
				to use them, you can allow the addon to use the guild information to store the settings. any text currently in the guild information can be posted
				to the forum instead.:
				
				check button: export guild info to forum
				
				settings that need to be stored server side: 
				addon version number
				oldest date of posts
				oldest date of synced data.
				
				if they enabled this setting:
				
				show options for dates.
				
				settings for which modules to use?
--]]
	do 
		local GM = GMConfiger
		GM.CheckBox = CreateFrame("CheckButton", "GMDebugCB", GM, "ChatConfigCheckButtonTemplate") -- check button
		_G[GM.CheckBox:GetName().."Text"]:SetText ("Enable Debugging")
		GM.CheckBox:SetSize(25, 25)
		GM.CheckBox:SetPoint("TOPLEFT", 30, -130)
		GM.CheckBox:SetScript("OnClick", function(self) if GMSettings.Debug then GMSettings.Debug = false else GMSettings.Debug = true end end)
		GM.CheckBox:SetScript("OnShow", function(self) if GMSettings.Debug then self:SetChecked(true) else self:SetChecked(false) end end)
		GM.CheckBox.tooltip = ("Prints information on what is being sent and received by the addon")
		
		GM.CheckBox2 = CreateFrame("CheckButton", "GMUseInfoCB", GM, "ChatConfigCheckButtonTemplate") -- check button
		_G[GM.CheckBox2:GetName().."Text"]:SetText ("Use guild info for settings")
		GM.CheckBox2:SetSize(25, 25)
		GM.CheckBox2:SetPoint("TOPLEFT", 200, -150)
		GM.CheckBox2:SetScript("OnClick", function(self) if GMSettings.Debug then GMSettings.Debug = false else GMSettings.Debug = true end end)
		GM.CheckBox2:SetScript("OnShow", function(self) if GMSettings.Debug then self:SetChecked(true) else self:SetChecked(false) end end)
		GM.CheckBox2:Hide()
		local x = 30
			local y = -180
			
			
		for name, value in pairs(GMaster.LoadOrder) do
			
			
			local button = CreateFrame("CheckButton", "GMSett"..name, GM, "ChatConfigCheckButtonTemplate") -- check button
			button:SetChecked(GMaster.loaded[name])
			button:SetHitRectInsets(0, -70, 0, 0)
			button:SetScript("OnClick", function(self) 
															if self:GetChecked() then 
																if GMaster.loaded[name]  then
																	print("Loading module "..name..".. Module already loaded")
																else
																	
																	if GMaster.ModuleSettings[name] then
																		local setting = GMaster.ModuleSettings[name]()
																			GMaster.ModuleLoad[name]()
																		
																			GMSettings.modules[name] = GMSettings.modules[name] or {}
																			GMSettings.modules[name].active = true
																			GMaster.loaded[name]  = true
																			print("Loading module "..name)
																			
																			
																			if setting then
																				setting.name = name
																				setting.parent = "GuildMaster"
																				InterfaceOptions_AddCategory(setting)
																			end
																			
																	end
																end
															else
																local removed
																if GMaster.ModuleRemove[name] then
																	removed = GMaster.ModuleRemove[name]()
																end
																
																if removed then
																	print("Module: "..name.." unloaded")
																else
																	print("Module: "..name.." unloaded, requires UI reload to take effect")
																end
																GMSettings.modules[name].active = nil 
																GMaster.loaded[name] = nil
																RemoveInterfaceOptions("GuildMaster", name)
																
																
																--GMaster.loaded["GM"..name]  = false
															end 
														end)
			_G[button:GetName().."Text"]:SetText(name)
			_G[button:GetName().."Text"]:SetWidth(110)
			button:SetSize(25, 25)
			button:SetPoint("TOPLEFT", x, y)
			x = x + 110
			if x > 345 then
				x = 30
				y = y - 50
			end
			
		end
		GM.Reload = CreateFrame("Button", nil, GM, "UIPanelButtonTemplate")
		GM.Reload:SetSize(120, 30)
		GM.Reload:SetText("Reload Interface")
		GM.Reload:SetPoint("BOTTOM", 0, 30)
		GM.Reload:SetScript("OnClick", function(self) ReloadUI() end)
		
	end




--==================== GM RECRUIT ====================
--[[
	needs: a slider to set the delay from 5 minutes - 1 hour
	a dropdown to either make a new recruitment message, or edit an old one
	an edit box to change the message (with a char limite of 250)
	
--]]
	--[[
	do
	local Rec = GMConfiger.GMRecruit



	Rec.SliderText = Rec:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	Rec.SliderText:SetHeight(20)
	Rec.SliderText:SetPoint("LEFT", Rec, "LEFT", 30, 0)
	Rec.SliderText:SetPoint("RIGHT", Rec, "RIGHT", -30, 0)
	Rec.SliderText:SetText("Frequency of guild recruitment messages:")
	Rec.SliderText:SetPoint("TOP", Rec, "TOP", 0, -20 )

	Rec.delaySlide =  CreateFrame("Slider", "GMRecSlide", Rec, "OptionsSliderTemplate")
	Rec.delaySlide:SetWidth(300)
	Rec.delaySlide:SetHeight(20)
	Rec.delaySlide:SetMinMaxValues(10, 60)
	Rec.delaySlide:SetValueStep(1)

	Rec.delaySlide:SetPoint("TOP", Rec.SliderText, "BOTTOM", 0 , -20)
	Rec.delaySlide:SetScript("OnValueChanged", function(self, value) GMSettings.GMRecruit.delay = value end)


	GMRecSlideLow:SetText("10 minutes")
	GMRecSlideHigh:SetText("1 hour")


	Rec.EditBox = CreateFrame("EditBox", "GMRecruitEB", Rec)
	Rec.EditBox:SetFont("Fonts\\FRIZQT__.TTF", 11, "OUTLINE, MONOCHROME")
	Rec.EditBox:SetTextInsets(10,10,15,15)
	Rec.EditBox:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background", 
												edgeFile = "Interface/Tooltips/UI-Tooltip-Border", 
												tile = true, tileSize = 16, edgeSize = 16, 
												insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	Rec.EditBox:SetBackdropColor(0,0,0,0.8)
	Rec.EditBox:SetMultiLine(true)
	Rec.EditBox:SetPoint("TOPLEFT", 10, -150)

	Rec.EditBox:SetPoint("BOTTOMRIGHT", Rec, "TOPRIGHT",  -10, -250)
	Rec.EditBox:SetScript("OnEscapePressed", function() InterfaceOptionsFrame:Hide() end)
	Rec:Hide()
	--ontext changed make sure its less than 250 and save

		Rec.Save = CreateFrame("Button", nil, Rec, "UIPanelButtonTemplate")
		Rec.Save:SetSize(70, 25)
		Rec.Save:SetText("Save")
		Rec.Save:SetPoint("TOPRIGHT", Rec.EditBox, "BOTTOMRIGHT", 0, -5)
		Rec.Save:SetScript("OnClick", function(self)
															--need to check the length of the message.
															--also add the duration.
															GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMRecruitNew", Rec.value.."|"..time().."|"..Rec.EditBox:GetText()}
															end)

		local GMRecruitDD = CreateFrame("Frame", "GMRecruitDD", Rec, "UIDropDownMenuTemplate")
		GMRecruitDD:SetPoint("TOP", Rec.delaySlide, "BOTTOM", 0, -30)
		GMRecruitDD:SetPoint("RIGHT", Rec, "RIGHT", -30, 0)
		UIDropDownMenu_SetWidth(GMRecruitDD, 120)
		UIDropDownMenu_SetButtonWidth(GMRecruitDD, 80)


		function GMRecruitDD_Initialize()
			level = 1
			local info = UIDropDownMenu_CreateInfo()
			
			if GMSettings.GMRecruit and GMSettings.GMRecruit.list then
				for i = 1, #GMSettings.GMRecruit.list do
					info = UIDropDownMenu_CreateInfo()
					info.notCheckable = true
					info.text =  i
					info.value = i
					info.checked = nil
					info.func = function() Rec.EditBox:SetText(GMSettings.GMRecruit.list[i].msg) UIDropDownMenu_SetText(GMRecruitDD, i) Rec.value = i end
					UIDropDownMenu_AddButton(info, level)
				end
			end
			
			info = UIDropDownMenu_CreateInfo()
			info.notCheckable = true
			info.text = "New Message"
			info.value = "New"
			info.func = function() Rec.value = #GMSettings.GMRecruit.list + 1 Rec.EditBox:SetText("")end
			UIDropDownMenu_AddButton(info, level)
		end
		
		UIDropDownMenu_Initialize(GMRecruitDD, GMRecruitDD_Initialize)
		Rec:SetScript("OnShow", function(self) self.value = #GMSettings.GMRecruit.list+ 1 UIDropDownMenu_SetText(GMRecruitDD, "New") end)

	end
	--]]
end
--[[
1. About
2. Changes
3. To do.
4. Known Issues

--========================== 1. About ===============================
	This module adds a stats frame which will eventually display all of the info that the addon collects on players. 
	Currently the stats frame shows batteground information such as the total healing done, damage done, and honor gained, as well as the highest achieved in a single battleground.
	It also shows some extra guild statistics collected by the addon such as the time spent online/instancing/raiding. 
	This information accurate to the nearest minute.
--========================== 2. Changes ==============================
	1.4
	Total donations now includes donations from looting.
	Mousewheel to scroll
	escape closes the window.
--========================== 3. To do ================================
	Get the graphs working properly.
	sort by name
	check that offline changes are working properly.
	remove players that no longer exist
	change date ranges are working.
	show the guild rep 

	Track some general guild info.
	average level, 
	etc.

	Ideally this module should be integrated into the guild roster:
		main problem is fitting the data into the roster.
]]

function GMaster.AL.GMStats()


--[[
Extra views:
donations: donated, looted, withdrawn, repair, total

--]]

















	local SortBy = 1 --which column of the table to sort by
	local offset = 0 
	local toffset = 0
	local Page = "Activity" -- which panel of the stats frame to shpw
	local duration = "Daily" -- the timescale of the data 

	local TopTabNames = {PvP ={"Name", "Killing Blows", "Deaths", "HK's", "Damage Done", "Healing Done", "Honor"},
										PvPLoc = {0, 10, 11, 12, 13, 14, 15} , --relative locations of the above values
										PvPh = {140, 90, 70, 50, 100, 100, 80}, -- widths of the columns appropriate to each name of the column
										Activity = {"Name", "Online", "BG", "Arena", "Instance", "Raiding", "Chattyness"},
										ActivityLoc = {0, 2, 4, 5, 6, 7, 3},
										Activityh = {130, 70, 80, 70, 100, 100, 80},
										Guild = {"Name", "Donated", "Withdrawn", "Repairs", "Total", "Events Started", "Events Attended"},
										Guildh = {130, 70, 70, 70, 70, 100, 110},
										GuildLoc = {0,22,23,24, 3,8,9},
										
									}

	local GMInfoFrame = CreateFrame("Frame", "GMInfoFrame", UIParent, "ButtonFrameTemplate") -- the guild stats frame
			tinsert(UISpecialFrames, "GMInfoFrame")
			
	local Scroller = CreateFrame("ScrollFrame", "GMInfoScrollFrame", GMInfoFrameInset, "FauxScrollFrameTemplate") -- the scroller for the stats frame
			Scroller:SetWidth(30)
			Scroller:SetHeight(360)
			Scroller:SetPoint("TOPRIGHT", GMInfoFrameInset, "TOPRIGHT", -5, 0)
			Scroller:Show()


	local function SecondsToClock(sSeconds) --convert the seconds into formatteed time
		local nSeconds = tonumber(sSeconds)
		if nSeconds == 0 then
		--return nil;
		return "0";
		else
			local nHours = string.format("%02.f", floor(nSeconds/3600));
			local nMins = string.format("%02.f", floor(nSeconds/60 - (nHours*60)));
			local nSecs = string.format("%02.f", floor(nSeconds - nHours*3600 - nMins *60));
			return nHours..":"..nMins..":"..nSecs
		end
	end	
			
		
	--thsi function returns the time value since the date desired, eg since last sunday for week, or since 12:00 last night for day	
	local function GetDate() 
		local TimeTable = {}
	 --{ ["hour"] = 20, ["min"] = 15, ["wday"] = 5, ["day"] = 2, ["month"] = 12, ["year"] = 2010, ["sec"] = 47, ["yday"] = 336, ["isdst"] = false }
		

		if duration:find("Daily") then
			TimeTable = date("*t", time())
			TimeTable.min = 0
			TimeTable.hour = 0
			TimeTable.sec = 0
			return time(TimeTable)
		elseif duration:find("Weekly") then
			local findtime = time() -86400
			TimeTable = date("%A", findtime)
			while TimeTable ~= "Sunday" do
				findtime = findtime - 86400
				TimeTable = date("%A", findtime)
			end
			TimeTable = date("*t", findtime)
			TimeTable.min = 59
			TimeTable.hour = 23
			TimeTable.sec = 59
			return time(TimeTable) --return the time at 1 second to midnight on the last sunday
		elseif duration:find("Monthly") then
			local month, day
			findtime = time()
			TimeTable = date("*t", findtime)
			local month, year = TimeTable.month, TimeTable.year
			while month == TimeTable.month and year == TimeTable.year do

				findtime = findtime - 86400
				TimeTable = date("*t", findtime)
			end
			TimeTable = date("*t", findtime)
			TimeTable.min = 59
			TimeTable.hour = 23
			TimeTable.sec = 59
			return time(TimeTable) --hopefully returns 1second to midnight of the last day of the last month
		end
	end


	local function GMInfoFrame_Update()
	local TopButton
	local NameList = {}
	local CheckDateStart


			for i = 1, 7 do
				TopButton = _G["GMInfoTopButton"..i]
				if TopButton then
					TopButton = _G["GMInfoTopButton"..i]
					TopButton:SetText(TopTabNames[Page][i])
					TopButton:SetWidth(TopTabNames[Page.."h"][i])
					WhoFrameColumn_SetWidth(TopButton, TopTabNames[Page.."h"][i]);
				end
			end
		
		CheckDateStart = GetDate()
			
			
		local TempTable = {}

		if not GMLogs then return end
		if CheckDateStart then
			for dated, player in pairs(GMLogs) do
				if dated > CheckDateStart then
				--add everything into the current table
					for name, info in pairs(GMLogs[dated]) do
						if name == "LastRecord" then
							--dont do anythign to it
						else
							if TempTable[name] then
								for i = 1, #info do
									if i > 9 and i < 16 then
										--check if its higher
										if TempTable[name][i] then
											if info[i] > TempTable[name][i] then --if its higher 
												TempTable[name][i] = 0 + info[i] --replace it
											end
										else
											TempTable[name][i] = 0 + info[i]
										end
									else
										if TempTable[name][i] then
											TempTable[name][i] = TempTable[name][i] + info[i]
										else
											TempTable[name][i] = 0 +info[i]
										end
									end
								end
							else
								TempTable[name]  = {unpack(info)}
							end
						end
					end
				end
			end
		end
		for name, info in pairs(TempTable) do
			local found 
			tinsert(NameList, {name = name, info = {unpack(info)}})
		end
		
		--if Page:find("PvP") then --should remove any player info for which none of the desired info is found
			for i = #NameList, 1, -1 do
				local found = false --found any data?
				local loc = TopTabNames[Page.."Loc"]
				for j = 2, #loc do
					if  NameList[i].info[loc[j]] and  NameList[i].info[loc[j]] > 0 then
						found = true -- pvp data found
					end
				end
				if not found then
					tremove(NameList, i) --remove tables for which no info is found
				end
			end
		--end
		
		if SortBy then
				table.sort(NameList, function(a, b)
													if a.info[TopTabNames[Page.."Loc"][SortBy]] and b.info[TopTabNames[Page.."Loc"][SortBy]] then
													return a.info[TopTabNames[Page.."Loc"][SortBy]] > b.info[TopTabNames[Page.."Loc"][SortBy]] 
													end end)
		end
		

		
		FauxScrollFrame_Update(Scroller, #NameList, 21, 16)
						
		offset = FauxScrollFrame_GetOffset(Scroller)
		-- if scroller iisshown then make inset smaller

		for i = 1, 30 do
			local button = _G["GMInfoFrameButton"..i]
			if button then
				button:Hide()
				
				local index = i + offset
				if NameList[index] then
					button.texts[1]:SetText(NameList[index].name)
					if GMRoster[NameList[index].name] then
						local class = GMRoster[NameList[index].name].class
						local classColor = RAID_CLASS_COLORS[class];
						if classColor then
							button.texts[1]:SetTextColor(classColor.r, classColor.g, classColor.b);
						end
					end
					for i = 2, 7 do
						if Page == "PvP" then
							button.texts[i]:SetText(NameList[index].info[TopTabNames.PvPLoc[i]+toffset] or "0")
						
						elseif Page == "Activity" then
							local text = NameList[index].info[TopTabNames.ActivityLoc[i]]
							if text then
								if TopTabNames.ActivityLoc[i] ~= 3 then
									text = SecondsToClock(text)
									button.texts[i]:SetText(text)
								else
									button.texts[i]:SetText(text)
								end
									
							else
									button.texts[i]:SetText("0")
							end
						elseif Page == "Guild" then
							local text = NameList[index].info[TopTabNames.GuildLoc[i]]
							if text then
								if i > 1 and i < 6 then
								if i == 5 then
									local loc = NameList[index].info
									text = (loc[22] or 0) - (loc[23] or 0) - (loc[24] or 0 ) + (loc[25] or 0)
								end
								local gold = floor((text/10000) )
								local silver = floor(((text- gold*10000)/100) + 0.5)
								
									button.texts[i]:SetText(gold.."g "..silver.."s")
								else
									button.texts[i]:SetText(text)
								end
							else
									button.texts[i]:SetText("0")
							end
						end
					end
					button:Show()
				else
					button:Hide()
				end
			end
		end
	end

	Scroller:SetScript("OnVerticalScroll", function(self, value) FauxScrollFrame_OnVerticalScroll(self, value, 16, GMInfoFrame_Update)  end)
			
		

	function GMaster.GFL.LoadStats()
		
			local ToggleGMInfo = CreateFrame("Button", nil, GuildFrame) --add a button to the guild emblem that toggles the stats frame
			ToggleGMInfo:SetWidth(50)
			ToggleGMInfo:SetHeight(50)
			ToggleGMInfo:SetPoint("TOPLEFT", GuildFrame, "TOPLEFT")
			ToggleGMInfo:SetScript("OnClick", function() if GMInfoFrame:IsShown() then 
																								GMInfoFrame:Hide() 
																							PlaySound("igCharacterInfoTab");
																						else 
																								GMInfoFrame:Show() 
																								PlaySound("igCharacterInfoTab");
																							end 
																						end)
					
					---[[local parent
			for i = 1, 7 do -- add the tabs allong the bottom
				local b = CreateFrame("Button", "GMInfoTopButton"..i, GMInfoFrame, "GuildRosterColumnButtonTemplate")
				b:SetWidth(50)
				b:SetHeight(24)
				b.ID= i
				if parent then
					b:SetPoint("LEFT", parent, "RIGHT", 0, 0)
					parent = b
				else
					b:SetPoint("BOTTOMLEFT", GMInfoFrameInset, "TOPLEFT", 5, 0)
					parent = b
				end
				b:SetText("test")
				b:Show()
				b:SetScript("OnClick", function(self) SortBy = self.ID GMInfoFrame_Update() end)
			end--]]
					
			for i = 1, 21 do --add the buttons to sthe stats frame
				local button = _G["GMInfoFrameButton"..i]
				for j =1, 7 do
				
					local text = button.texts[j]
						
					if text then
					text:SetPoint("TOP", button, "TOP")
					text:SetPoint("BOTTOM", button, "BOTTOM")
					text:SetPoint("LEFT", _G["GMInfoTopButton"..j], "LEFT")
					text:SetPoint("RIGHT", _G["GMInfoTopButton"..j], "RIGHT")
					text:SetText("Samples TEXT"..j)	
					else
						
					end
				end
			end
	end


	

	GMInfoFrame:SetWidth(650)
	GMInfoFrame:SetHeight(450)
	GMInfoFrame:SetPoint("CENTER")
	GMInfoFrame:SetMovable(true)
	GMInfoFrame:EnableMouse(true)
	GMInfoFrame:SetScript("OnMouseDown", function(self) self:StartMoving() end)
	GMInfoFrame:SetScript("OnMouseUp", function(self) self:StopMovingOrSizing() end)
	GMInfoFrame:SetScript("OnShow", GMInfoFrame_Update)
	GMInfoFrame.CheckButtonText = GMInfoFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")

	local ShowTotals = CreateFrame("CheckButton", "testtr", GMInfoFrame, "OptionsSmallCheckButtonTemplate")
	ShowTotals:SetWidth(20)
	ShowTotals:SetHeight(20)
	ShowTotals:SetPoint("TOPRIGHT", GMInfoFrameInset, "BOTTOMRIGHT", -5, 0)
	ShowTotals:SetChecked(false)
	ShowTotals:SetScript("OnClick", function(self) 
														if self:GetChecked()  then 
															toffset = 0
															GMInfoFrame.CheckButtonText:SetText("Show total earned")
															GMInfoFrame_Update()
														else
															toffset = 6
															GMInfoFrame.CheckButtonText:SetText("Show highest achieved in single BG")
															GMInfoFrame_Update()
														end 
													end)


	GMInfoFrame.CheckButtonText:SetHeight(25)
	GMInfoFrame.CheckButtonText:SetWidth(300)
	GMInfoFrame.CheckButtonText:SetPoint("RIGHT", ShowTotals, "LEFT")
	GMInfoFrame.CheckButtonText:SetText("Show total earned")
	GMInfoFrame.CheckButtonText:SetJustifyH("RIGHT")

	GMInfoFrameInset:ClearAllPoints()
	GMInfoFrameInset:SetPoint("TOPLEFT", 5, -55)
	GMInfoFrameInset:SetPoint("BOTTOMRIGHT", -25, 30)

	-- == creates drop down to changed the date of the info shown
	local GMCoreDurDD = CreateFrame("Frame", "GMCoreDurDD", GMInfoFrame, "UIDropDownMenuTemplate")
	GMCoreDurDD:SetPoint("TOPLEFT", GMInfoFrameInset, "BOTTOMLEFT", 0, 0)
	UIDropDownMenu_SetWidth(GMCoreDurDD, 120)
	UIDropDownMenu_SetButtonWidth(GMCoreDurDD, 80)


	function GMCoreDurDD_Initialize()
		level = 1
		local info = UIDropDownMenu_CreateInfo()
		
		
		info = UIDropDownMenu_CreateInfo()
		info.notCheckable = true
		info.text = "Today"
		info.value = "Daily"
		info.checked = nil
		info.func =  function(self) duration = self.value GMInfoFrame_Update()	UIDropDownMenu_SetText(GMCoreDurDD, "Daily")  end
		UIDropDownMenu_AddButton(info, level)
		
		info = UIDropDownMenu_CreateInfo()
		info.notCheckable = true
		info.text =  "This Week"
		info.value = "Weekly"
		info.checked = nil
		info.func = function(self) duration = self.value GMInfoFrame_Update () 	UIDropDownMenu_SetText(GMCoreDurDD, "Weekly") end
		UIDropDownMenu_AddButton(info, level)
		
		info = UIDropDownMenu_CreateInfo()
		info.notCheckable = true
		info.text =  "This Month"
		info.value = "Monthly"
		info.checked = nil
		info.func = function(self) duration = self.value GMInfoFrame_Update () 	UIDropDownMenu_SetText(GMCoreDurDD, "Monthly") end
		UIDropDownMenu_AddButton(info, level)
		
		
	end
	UIDropDownMenu_Initialize(GMCoreDurDD, GMCoreDurDD_Initialize)

	UIDropDownMenu_SetText(GMCoreDurDD, "Daily")

	--========= create tabs allong bottom ======
	local TabNames = {"Activity", "Guild", "PvP"}

	for i = 1, #TabNames do --created the tabs allong the bottom
	   local button = CreateFrame("Button", "GMInfoFrameTab"..i, GMInfoFrame, "CharacterFrameTabButtonTemplate" )
	   button:SetID(i)
	   if i == 1 then
		  button:SetPoint("TOPLEFT", GMInfoFrame, "BOTTOMLEFT", 0, 0)
	   else
		  button:SetPoint("LEFT", _G["GMInfoFrameTab"..(i-1)], "RIGHT", -16, 0)
	   end
	   
	   button:SetText(TabNames[i])
	   button:SetScript("OnClick", function(self) 
																	PanelTemplates_Tab_OnClick(self, GMInfoFrame)
																	Page = self:GetText()
																	GMInfoFrame_Update()
																end)
	   
	end

	local button = _G["GMInfoFrameTab1"]
	ButtonFrameTemplate_HidePortrait(GMInfoFrame)
	PanelTemplates_SetNumTabs(GMInfoFrame, #TabNames)
	GMInfoFrame:Hide()
	GMInfoFrame:Show()
	GMInfoFrame:Hide()
	PanelTemplates_Tab_OnClick(button, GMInfoFrame)

	
	local function GetPlayerData(name)
		local data = {}
		local minX, minY, maxY, maxX 
		for dated, players in pairs(GMLogs) do
			if not minX then
				minX = dated
			end
			if not maxX then 
				maxX = dated
			end
			if dated < minX then
				minX = dated
			end
			if dated > maxX then
				maxX = dated
			end
			if players[name] then
				for i = 1, #players[name] do
					if not minY then
						minY = players[name][i]
					end
					if not maxY then
						maxY = players[name][i]
					end
					if players[name][i] > maxY then
						maxY  = players[name][i]
					end
					if players[name][i] < minY then
						minY = players[name][i]
					end
					if not data[i] then
						data[i] = {}
					end	
					tinsert(data[i], {dated, players[name][i]})
				end
			end
		end
		
		if next(data) then
			return data, minX, maxX, minY, maxY
		end
	end
	--=======================
		--Graph Frame
		--[[
		local GraphFrame = CreateFrame("Frame", nil,  GMInfoFrame)
		GraphFrame:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background", 
												edgeFile = "Interface/Tooltips/UI-Tooltip-Border", 
												tile = true, tileSize = 16, edgeSize = 16, 
												insets = { left = 4, right = 4, top = 4, bottom = 4 }})
		GraphFrame:SetBackdropColor(0,0,0,1);
		
		GraphFrame:SetSize(200, 200)
		GraphFrame:SetPoint("TOPLEFT", GMInfoFrame, "TOPRIGHT", 10, 0)
		GraphFrame:Hide()
		
			local Graph=LibStub("LibGraph-2.0")
			local Graph=Graph:CreateGraphLine("TestLineGraph",GraphFrame,"CENTER","CENTER",90,90,180,180)
			
			Graph:SetAxisDrawing(true,true)
			Graph:SetAxisColor({1.0,1.0,1.0,1.0})
			Graph:SetAutoScale(true)

			local Data1={{0.05,0.05},{0.2,0.3},{0.4,0.2},{0.9,0.6}}
			local Data2={{0.05,0.8},{0.3,0.1},{0.5,0.4},{0.95,0.05}}

		
		local function Graph_Update(player)
			local data, minX, maxX, minY, maxY = GetPlayerData(player)
			if not data then return end
			print(data, minX, maxX, minY, maxY)
			Graph:SetXAxis(minX,maxX)
			Graph:SetYAxis(minY,maxY)
			Graph:SetGridSpacing((maxX-minX)/5,(maxY-minY)/5)
			Graph:SetGridColor({0.5,0.5,0.5,0.5})
			for i = 1, #data do
				print(unpack(data[i]))
				Graph:AddDataSeries( data[i], {1, 1, 1, 0.8})
			end
			Graph:AddDataSeries(Data1,{1.0,0.0,0.0,0.8})
			Graph:AddDataSeries(Data2,{0.0,1.0,0.0,0.8})
		end
		
		--]]
	--===================
	
	
	local parent

	for i = 1, 21 do
		local button = CreateFrame("Button", "GMInfoFrameButton"..i, GMInfoFrame, "WorldStateScoreTemplate")

		button:SetPoint("LEFT", GMInfoFrameInset, "LEFT", 4, 0)
		button:SetPoint("RIGHT", GMInfoFrameInset, "RIGHT", -4, 0)
	
		if parent then
			parent = _G["GMInfoFrameButton"..(i-1)]
			button:SetPoint("TOP", parent, "BOTTOM", 0, -1)
		else
			button:SetPoint("TOP", GMInfoFrameInset, "TOP", 0, -4)
			parent = button
		end
		local textureLeft = _G["GMInfoFrameButton"..i.."FactionLeft"]
		local textureRight = _G["GMInfoFrameButton"..i.."FactionRight"]
		textureLeft:SetAlpha(0.5)
		textureRight:SetAlpha(0.5)
		
		button.texts = {}
		button.texts[#button.texts+1] = button.name.text
		button.texts[#button.texts+1] = _G[button:GetName().."Column2Text"] 
		button.texts[#button.texts+1] = button.killlingBlows
		button.texts[#button.texts+1] = button.damage
		button.texts[#button.texts+1] = button.healing
		button.texts[#button.texts+1] = button.honorableKills
		button.texts[#button.texts+1] = _G[button:GetName().."Column1Text"]
		button.texts[#button.texts+1] = button.deaths
	
		button:SetScript("OnMouseWheel", function(self, delta) delta = delta*16 Scroller:SetVerticalScroll(Scroller:GetVerticalScroll() + delta) GMInfoFrame_Update()  end)
			
		button:SetScript("OnClick", function(self) if self:IsShown() then if GraphFrame:IsShown() then else GraphFrame:Show() GraphFrame.name = button.texts[1]:GetText() Graph_Update(GraphFrame.name) end end end)
				--button:Hide()
	end

end

GMaster.LoadOrder.GMStats = true--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
	Syncronises extra player data between guild members, such as donations,
	
--========================== 2. Details ===============================
	Upon  the player entering the game, the addon sends a ping out to check for other players with the addon. At this point any data received will be stored in a temporary table.
	If no other addons send a pong, the addon will assume that it is the only one online, and start a new session, adding any temporary data into the new session.
	If other addons are found, the oldest addon that is not currently involved with syncing to another player will also pause its own data gathering, and begin transmitting the current table to the new addon.
	Once the current session has been updated to the new addon, both the newest and oldest addons will resuming recording directly to their sessions, and add any temporary information recorded.
	The newest and oldest addons will broadcast their session ID's to all other addons, and all addons transmit any sessions that other addons are missing.
	if sessions are somehow recorded during another session, they will eventually be detected and deleted.
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.42
	-	Moved the queue function over to GMTimer.
		Added a method of blocking users whose addons are out of date.
--========================== 5. To do =================================
	Efficiency:
	Change the order of the if/elese statements to better suit how oftn ethey are called.
	
	New Method:
	10 minute blocks of data, sync every half an hour.
	
	log in, record login time, start recording.
	after 10 mins, split chunk.
	after half hour, transmit the start time, size of last chunk
	Wait 10 seconds, then decide which module is the "master"  
	Master transmits all known chunk times
		Slaves request missing chunks, transmit missing chunk labels.
		Wait 30 seconds, count requests for each chunk.
		If a chunk has multiple requests, broadcast it
		If a chunk has a single request, WHISPER it.
	
	hash value for tables:
		need to create some method of finding the total size of a table
		
	Problems:
		Players changing zones/reloading
		-may miss some data
		
	Merging continuous chunks:
		Find tables whose start and end times match
		merge the table data
		
	Merging non-comtinuous chunks:
		Non continuous chunks can be merged provided: 
		the start and end times of each chunk are recorded into the new chunk
		for example:
			- chunk 1 measures a to c
			- chunk 2 measures g to h
			chunk 1a is a merge of ac gh
			chunk 3 measures d to f
			chunk 1b is a merge of 1a and 3 consisting a through h
			
		Timescales:
			10 minute chunks
			merge after 30 mins and transmit
			merge after 1 hour
			merge 24 hour after 1 day
			merge 7 days after 1 week
			merge 4 weeks after a month
			
			Eventually merge data into the roster.
	
	Security:
	 With the limitations on obfuscation, can only be basic.
	 Masking the saved vars by conversion to ASCII?

Use GMRoster savedvar to store which members are online, and the last time they were seen, 
(any addonmessage received should be used as the last time they were seen.)
	 
]]


--[[


["PLAYER"] = {	[1] = 0, -- hash
				[2] = 0, -- online
				[3] = 0, -- chat
				[4] = 0, -- inbg
				[5] = 0, -- in arena
				[6] = 0, -- in instance
				[7] = 0, -- in raid
				[8] = 0, --started event
				[9] = 0, --joined event
				[10] = 0, -- Killing Blows
				[11] = 0, -- Deaths
				[12] = 0, -- Honorable Kills
				[13] = 0, -- Damage Done
				[14] = 0, -- Healing Done
				[15] = 0, --Honor Gained
				[16] = 0, Killing Blows total
				[17] = 0, -- Deaths total
				[18] = 0, -- HK total
				[19] = 0, - damage total
				[20] = 0, -- heal total
				[21] = 0, -- honor gained
				[22] = 0, -- money donated.
				[23] = 0 --money withdrawn
				[24] = 0, --repairs used
				[25] = 0,  --looted
				[26] = 0, -- guild rep
			 
--]]

function GMaster.AL.GMSync()

	local testframe = CreateFrame("FRAME", nil,UIParent,  WorldStateScore)
	testframe:SetWidth(300)
	testframe:SetHeight(300)
	testframe:SetPoint("CENTER", UIParent, "CENTER")
	testframe:Show()

	local LoginTime = 0
	local AddonList = {}

	local SendTo = "" --stores who it is sending stuff to
 --stores temporary info while the addon is sending or recieving
	local PlayerName = GMaster.PlayerName
	local RequestTable = {}
	local EnteredBG = false
	--stores all mesages to be sent

	local PingSent = nil
	local isBusy = 0 -- 0 isnt busy, 1 is
	local waitingToPing = 0 --if the addon is queued to ping a vacant addon (check locFrame)
	
	local ignorelist = {}
	
	--=======================================================================

	GMaster.PEW.LoadSync = function()
			LoginTime = tonumber(time())
			GMSettings.Active = nil --stop it recording anything to its current table, as the current table doesnt exist yet
			
			if (GMSettings.LastLogout > 0) and (LoginTime - GMSettings.LastLogout) < 60 then --if the addon has been run before
				GMaster:Debug("continuing with current table") --stick with the stored
				GMSettings.Active = true
			else --send a ping to see whats going on
				tinsert(GMaster.Timers, {runonce = true, interval = 20, elapsed = 0, func = function() SendAddonMessage("GMPing", LoginTime.."|"..GMSettings.Version, "GUILD") end})
				PingSent = true
			end
		GMaster.PEW.LoadSync = nil
	end

	--=================================================================

	function GMaster.AddInfo(name, dated, index, value, LastRecord) --adds the info received into the database
	if not IsInGuild() then return end
		if (GMSettings.Active == true) and not (GMSettings.StartTime == 0) then --if it hasnt receieved a start time yet, or its busy, record to temp table
		local flagged = false --flag to set the value rather than add it
		
		if dated == "current" and GMLogs[GMSettings.StartTime] and GMLogs[GMSettings.StartTime].LastRecord then 
			if date("%d", GMLogs[GMSettings.StartTime].LastRecord) ~= date("%d", GMSettings.StartTime) then --this should force creation of a new table each day
				GMSettings.StartTime = time()
			end
		end

		if (not dated) or (dated == "current") then 
				dated = GMSettings.StartTime
			end
			
			if not GMLogs[dated] then
				GMLogs[dated] = {}
			end
			
			if LastRecord then
				GMLogs[dated].LastRecord = LastRecord
			else
				GMLogs[dated].LastRecord = time()
			end
			
			GMSettings.LastLogout = time()

			if not GMLogs[dated][name] then
				GMLogs[dated][name] = {}
			end
			
			for i = 1, math.min((index + 6), 26) do
				if not GMLogs[dated][name][i] then
					GMLogs[dated][name][i] = 0
				end
			end
			
				if index > 9 and index < 16 then --top scores in bg
					if value > GMLogs[dated][name][index] then --if its a new top score
						GMLogs[dated][name][index]  = value --replace thenew top score
					end
					GMLogs[dated][name][index+6] = GMLogs[dated][name][index+6] + value -- increase the totals
				else
					GMLogs[dated][name][index] = GMLogs[dated][name][index] + value
				end
			
			local hash = 0
			for i = 2, #GMLogs[dated][name] do 
				hash = hash + GMLogs[dated][name][i]
			end
			GMLogs[dated][name][1] = hash
		else --add it to a queue to be added later
			GMaster:Debug("queing "..name..dated..index)
			
			GMaster.TempTable[#GMaster.TempTable+1] = {name,dated,index,value, LastRecord}
		end
	end





	--=========================== Checks that are sent out: =======================================================
	--=====================================================================================================
	--=====================================================================================================
	--[[

	1. Any chatting in /g
	2. Withdrawals from guild bank
	3. donations to guild bank
	4. Guild Repairs
	5. Guild loot donations
	6. Guild Rep
	7. What the player is doing
	8. Battleground scores.


	--]]

	--=================  1. Chatting in /g =================

	local function ChatCheck(self, event, msg, name) -- flags every time a player talks in /g
		GMaster.AddInfo(name, "current", 3, 1)
	end

	local Chatter = CreateFrame("FRAME")
	Chatter:RegisterEvent("CHAT_MSG_GUILD")
	Chatter:SetScript("OnEvent", ChatCheck)


	--===================== 2. Withdrawal from Guild Bank ===================

	StaticPopupDialogs["GUILDBANK_WITHDRAW"] = {
		text = GUILDBANK_WITHDRAW,
		button1 = ACCEPT,
		button2 = CANCEL,
		OnAccept = function(self)
			local moneys = MoneyInputFrame_GetCopper(self.moneyInputFrame)
			WithdrawGuildBankMoney(moneys);
				GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMWithdraw", moneys}
			end,
		OnHide = function(self)
			MoneyInputFrame_ResetMoney(self.moneyInputFrame);
		end,
		EditBoxOnEnterPressed = function(self)
			local parent = self:GetParent():GetParent();
			local moneys = MoneyInputFrame_GetCopper(parent.moneyInputFrame)
			WithdrawGuildBankMoney(moneys);
			GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMWithdraw", moneys}
			parent:Hide();
		end,
		hasMoneyInputFrame = 1,
		timeout = 0,
		hideOnEscape = 1
	};

	--===================== 3. Donations to guild bank =============

	StaticPopupDialogs["GUILDBANK_DEPOSIT"] = {
		text = GUILDBANK_DEPOSIT,
		button1 = ACCEPT,
		button2 = CANCEL,
		OnAccept = function(self)
			local moneys = MoneyInputFrame_GetCopper(self.moneyInputFrame)
			DepositGuildBankMoney(moneys)
			GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMDonate", moneys}
		end,
		OnHide = function(self)
			MoneyInputFrame_ResetMoney(self.moneyInputFrame);
		end,
		EditBoxOnEnterPressed = function(self)
			local parent = self:GetParent():GetParent();
			local moneys = MoneyInputFrame_GetCopper(parent.moneyInputFrame)
			DepositGuildBankMoney(moneys);
			GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMDonate", moneys}
			parent:Hide();
		end,
		hasMoneyInputFrame = 1,
		timeout = 0,
		hideOnEscape = 1
	};

	--====================== 4. Repair ================

		
								
								MerchantGuildBankRepairButton:SetScript("OnClick", function(self) 
										local amount = GetGuildBankWithdrawMoney();
										local guildBankMoney = GetGuildBankMoney();
										local cost = GetRepairAllCost()
										if ( amount == -1 ) then
											-- Guild leader shows full guild bank amount
											amount = min(guildBankMoney, cost)
										else
											amount = min(amount, guildBankMoney, cost);
										end
										if(CanGuildBankRepair()) then
											
											GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMRepair", amount}
											RepairAllItems(1);
											PlaySound("ITEM_REPAIR");
										end
										GameTooltip:Hide();
								end)
								
	--======================= 5. Donations from looting ==================================
	do 
	local f = CreateFrame("Frame")
	f:RegisterEvent("CHAT_MSG_MONEY")
	f:SetScript("OnEvent", function(self, event, msg)
			local Gold = msg:match("%(.-(%d+) Gold.-deposited to guild bank") or 0
			local Silver = msg:match("%(.-(%d+) Silver.-deposited to guild bank") or 0
			local Copper = msg:match("%(.-(%d+) Copper.-deposited to guild bank") or 0 


				if not GMaster.tempmoney then 
					GMaster.tempmoney = 0
				end
				GMaster.tempmoney = GMaster.tempmoney + Copper + Silver*100 + Gold *10000
			end)
	end

	--======================= 6. Guild Rep ===============================
	do
	local f = CreateFrame("Frame")
	f:RegisterEvent("COMBAT_TEXT_UPDATE")
	f:SetScript("OnEvent", function(self, event, ctype, faction, gain, ...) 
											if ctype == "FACTION" then
												if faction == "Guild Reputation" then 
													GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMUpdate", "|Rep|"..gain}
												end
											end 
								end)
	end


	--======================= 7. What is the player doing? (instance/bg/arena/raid)  =====================


	local function LocCheck()
		local inInstance, instanceType = IsInInstance()
		if IsInGuild() then
			SendAddonMessage("GMUpdate", "|Loc"..instanceType.."|int60", "GUILD")
		end
		if GMaster.tempmoney and GMaster.tempmoney > 0 then
			GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMUpdate", "|Loot|"..GMaster.tempmoney}
			GMaster.tempmoney = 0
		end
		
	end

	tinsert(GMaster.Timers, {runonce = false, interval = 60, elapsed = 0, func = LocCheck})

	--========================== 8. Battleground scores  =============================================

	local name, killingBlows, honorableKills, deaths, honorGained, faction, race, class, classToken, damageDone, healingDone, bgRating, ratingChange 

	local BGScore = CreateFrame("FRAME")
	BGScore:RegisterEvent("PLAYER_ENTERING_WORLD")
	BGScore:RegisterEvent("UPDATE_WORLD_STATES")
	BGScore:RegisterEvent("UPDATE_BATTLEFIELD_SCORE")


		
	BGScore:SetScript("OnEvent", function(self, event, msg)
														
															local inst, instype = IsInInstance()
															if inst and instype == "pvp" then
																	for i = 1, GetNumBattlefieldScores() do
																		name, killingBlows, honorableKills, deaths, honorGained, faction, race, class, classToken, damageDone, healingDone, bgRating, ratingChange = GetBattlefieldScore(i);
																		if name and name == PlayerName then
																			return
																		end
																	end
															else
																if name and killingBlows then
																	local msg = "BG|10:"..killingBlows.."|11:"..deaths.."|12:"..honorableKills.."|13:"..damageDone
																			msg = msg.."|14:"..healingDone.."|15:"..honorGained.."|"
																		GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMUpdate", msg}
																	name, killingBlows = nil, nil
																end
															end
														
													end)

	--===================================================================
	--==========================================================================

	local function PingWait()
			SendAddonMessage("GMPing", LoginTime.."|"..GMSettings.Version, "GUILD")
			PingSent = true
	end


	local function Timer()
		if GMSettings.lockout then
			return
		end
			GMaster:Debug("timer finished, sorting")
			table.sort(AddonList, function(a, b) return a.login < b.login end)
			if #AddonList == 1 then
				--its the only one online
				--if its the only one online, check the damn start time
				GMSettings.StartTime = LoginTime
				GMaster:Debug("this addon is the only one online")
				PingSent = nil
				GMSettings.Active = true			
			else
				local i = 1
				--search for the first addon that isnt busy
				while ( AddonList[i] and AddonList[i].busy == 1) do
					i = i + 1
				end
					
					GMaster:Debug(#AddonList)--if theres more than one, it wont be the oldest, so it wont send crap to itself
					GMaster:Debug(i)
					for j = 1, #AddonList do
						GMaster:Debug(j..": "..AddonList[j].player..AddonList[j].login)
					end
					
				if AddonList[i] then
					if AddonList[i].player == PlayerName then --if this addon is the one that needs to send the tables
						if PingSent then --check it isnt the one that asked for the tables
							if not i == 1 then
								GMaster:Debug("There are no free addons, queueing ping") 
								tinsert(GMaster.Timers, {runonce = true, interval = 60, elapsed = 0, func = PingWait})
							end
						else
							if isBusy < 1 and not PingSent then --its not busy
								GMaster:Debug("this addon is the oldest and will send the tables")
								GMSettings.Active = nil --stop this addon recording directly to the table
								isBusy = 1 --mark it as busy
								
								GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMCurrentStart"..SendTo, GMSettings.StartTime}
							
								--send the current table
								if GMLogs and GMLogs[GMSettings.StartTime] then
									for name, info in pairs(GMLogs[GMSettings.StartTime]) do
										if (name == "LastRecord") then
											GMaster:Debug("this value is LastRecord")
										else
											GMaster:Debug("Sending message for name: "..name)
											local msg = name.."|"
											for i = 1, #info do
												if  info[i] ~= 0 then
													msg = msg..i..":"..(info[i]).."|"
												end
											end
											GMaster:Debug(msg.." this is being sent out")
											GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMCurrent"..SendTo, msg}
										end
									end
								end
								
								isBusy = 0 --mark it as available
								GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMCurrentEnd"..SendTo, GMSettings.StartTime}
							else
								GMaster:Debug("This addon is busy")
							end
						end
					else
						if PingSent then -- there should be an addon about to send data, so wait for it.
							GMaster:Debug("this addon is waiting to receive ")
						else
							GMaster:Debug("this addon isnt the oldest, and will continue recording normally")
							GMSettings.Active = true
						end
					end
				else --the players addon is busy, as are all the  others
					GMaster:Debug("There are no free addons, queueing ping")
					tinsert(GMaster.Timers, {runonce = true, interval = 60, elapsed = 0, func = PingWait})
				end
			end
	end

	--[[
	GMWipe - Forces all online addons to wipe their data
	GMDonate - the player has donated
	GMWithdraw - the player has withdrawn money
	GMRepair - the player has used guild repair
	GMPing - only sent by new addons when they come online
	GMPong - sent by all addosn to work out who is the "leader" (oldest)
	GMUpdate --sent by all addons to tell all other addons any new info
	GMBroadcast - send out all known table Start and ned times, not their data
	GMRequest -- asks for any tables that are needed
	GMCurrentStart - sends the current table to a new addon
	GMCurrent -- the data of the current table
	GMCurrentEnd --the current table has finished sending

	--what happens if a new addon comes online while the leader is sending out the current table?
		-- it gets directed to a different addon, or queued
	--]]


	--this function needs reshuffling so the most likely events occur first


	function GMaster.CMA.SyncMsg( prefix, msg, channel, player) --only deals with checking which tables different addons have
		if GMSettings.lockout then --don't do anything
			return
		end
		if ignorelist[player] then
			return
		end
		if prefix == "GMWIPE" then
			--this should reset all addons online
			GMSettings = {}
			GMaster.QueueTable = {}
			GMSettings.Active = nil
			GMSettings.StartTime = tonumber(msg)
			GMRoster = {}
			GMLogs = {}
		elseif prefix == "GMEventNew" then
			GMaster.AddInfo(player, "current", 8, 1)
		elseif prefix == "GMEventAccept" then
			GMaster.AddInfo(player, "current", 9, 1)
		elseif prefix == "GMDonate" then
			msg = tonumber(msg)
			GMaster.AddInfo(player, "current", 22, msg)
			GMaster:Debug(player.." donated "..msg)
		elseif prefix == "GMWithdraw" then
				msg = tonumber(msg)
				GMaster:Debug(player.." withdrew "..msg.." from GB")
			GMaster.AddInfo(player, "current", 23, msg)
		elseif prefix == "GMRepair" then
			msg = tonumber(msg)
			GMaster.AddInfo(player, "current", 24, msg)
			GMaster:Debug(player.."used GB for repair, costing:"..msg)
		elseif  prefix == "GMPing" then -- listened to by all addons
			local version = tonumber(msg:match("|(%d+%p%d+)"))
				if (not version) or (version < GMSettings.Version) then
					ignorelist[player] = true
					return
				end
				if version and version > GMSettings.Version then
					GMSettings.lockout = true
					print("Guild Master is out of date. Most functionality will not work until you update")
				end
				
				GMaster:Debug("Receiving Ping from "..player)
				AddonList = {} --clear the table of stores addon start times
				SendTo = player --store who pinged, in case this addon need to send its data to the pinger
				
				GMSettings.Active = false --stop it recording to its own table
				
				tinsert(GMaster.Timers, {runonce = true, interval = 4, elapsed = 0, func = Timer})
				SendAddonMessage("GMPong", LoginTime.."|"..isBusy.."|"..GMSettings.Version, "GUILD")
				
				GMaster:Debug("sent pong, waiting to decide")
		elseif prefix == "GMPong" then --records all pongs, including itself
			GMaster:Debug(msg.." got pong")
			local dated, busy = msg:match("(%d+)|(%d+).+")
			local version = tonumber(msg:match(".+|(%d+%p+%d+)"))
				if (not version) or (version < GMSettings.Version) then
					ignorelist[player] = true
					return
				end
			busy = tonumber(busy)
			dated = tonumber(dated)
			GMaster:Debug(dated, busy)
			if dated then
				AddonList[#AddonList+1] = {login = dated, player = player, busy = busy}
			end
		elseif prefix == "GMDelete" then
			msg = tonumber(msg)
			if GMLogs[msg] then
				GMLogs[msg] = nil
			end
		elseif prefix == "GMUpdate" then
			--GMaster:Debug("received update")
			if msg:find("^|Loot") then
				local money = msg:match("|Loot|(%d+)")
				if money then
					money = tonumber(money)
					GMaster.AddInfo(player, "current", 25, money)
				end
			elseif msg:find("^|Rep") then
				local rep = msg:match("|Rep|(%d+)")
				if tonumber(rep) then
					rep = tonumber(rep)
					GMaster.AddInfo(player, "current", 26, rep)
				end
			elseif msg:find("^|Loc") then  -- if the thing to update is the zone info
				local zoneType, interval = msg:match("|Loc(%w+)|int(%d+)")
				interval = tonumber(interval)
				GMaster.AddInfo(player, "current", 2, interval) --updated the general online time

				if not GMRoster[player] then
					GMRoster[player] = {}
				end
				
				if zoneType == "pvp" then
					GMaster.AddInfo(player, "current", 4, interval)
				elseif zoneType == "arena" then
					GMaster.AddInfo(player, "current", 5, interval)
				elseif zoneType == "party" then
					GMaster.AddInfo(player, "current", 6, interval)
				elseif zoneType == "raid" then
					GMaster.AddInfo(player, "current", 7, interval)
				end
				
			elseif msg:find("^BG|") then
				GMaster:Debug("update bg")
				for i, v in msg:gmatch("|(%d+):(%d+)") do
					i = tonumber(i)
					v = tonumber(v)
					GMaster:Debug(i, v)
					GMaster.AddInfo(player, "current", i, v)
				end
				
			end
			
		elseif prefix == "GMBroadcast" then
			if not (player == PlayerName) then --make sure it doesnt listen to its own broadcasts
			GMaster:Debug(player, PlayerName)
			
				--need to check that no tables overlap
				
				
				local startTime, endTime = msg:match("|(%d+)-(%d+)|") 
				GMaster:Debug("Recieving old table start times: "..startTime.." from "..player)
				startTime = tonumber(startTime) --make sure its using numbers
				endTime = tonumber(endTime)
				-- this needs to delete any tables that started inside the duration of other tables
				for dated, info in pairs(GMLogs) do
					if  info.LastRecord then
						if startTime > dated and endTime < info.LastRecord then
								GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMDelete", startTime}
						end
					end
					return
				end
				
					if GMLogs[startTime] then --if it already has a table that started the same time
						if endTime == GMLogs[startTime].LastRecord then --its the same table (hopefully)
							GMaster:Debug("I already have this table: "..startTime)
						elseif endTime > GMLogs[startTime].LastRecord then
							if not RequestTable[startTime] then
								GMaster:Debug("requesting send of table: "..startTime)
								GMLogs[startTime] = {} -- nil mine out to prevent tainting
								GMLogs[startTime].LastRecord = endTime
								GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMRequest"..player, startTime}
								RequestTable[startTime] = true
							end
						elseif  GMLogs[startTime].LastRecord > endTime then
							--my table is bigger, broadcast its size
							GMaster:Debug("larger version of the same table found, broadcasting")
							GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMBroadcast", "|"..startTime.."-"..GMLogs[startTime].LastRecord.."|"}
						end
					else
						--i dont have that table, please send it
						if not RequestTable[startTime] then
							GMaster:Debug("Table not found, requesting: "..startTime)
							GMLogs[startTime] = {} 
							GMLogs[startTime].LastRecord = endTime
							GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMRequest"..player, startTime}
						end
					end
					--need to check for missing tables somehow
			end
			-- record the tables and see which are needed
		elseif prefix:find("^GMSend"..PlayerName)  then
			GMaster:Debug("this should be recievingg the player name: "..prefix)
			---[[
			local dated, name = msg:match("^|(%d+)|(.-)|")
			dated = tonumber(dated)
			
			GMaster:Debug("receiving table "..dated)
			for index, value in msg:gmatch("|(%d+):(%d+)") do
				value = tonumber(value)
				index = tonumber(index)
				if GMLogs[dated] then
					local lastrecord = GMLogs[dated].LastRecord -- this should hopefuly retain the original lastrecord value of the table
																						-- rather than updating it with a new lastrecord
					
					GMaster:Debug(dated, (lastrecord or "lastrecord not found"))
						GMaster.AddInfo(name, dated, index, value, lastrecord)
						GMaster:Debug("This is recievingplayer name: "..name..", positon:"..index..", and value: "..value..". Dated = "..dated)
				end
			end
			--]]
		elseif prefix:find("^GMRequest"..PlayerName) then
			GMaster:Debug("Detected Request: "..player..""..PlayerName)
			if PlayerName ~= player then
				
				msg = tonumber(msg)
				if GMLogs[msg] then --if its got the table that the other addons want
					for name, info in pairs(GMLogs[msg]) do
						if not (name == "LastRecord") then -- we dont want it to send the LastRecord value.
							GMaster:Debug("request for table "..msg.." found, Sending it ")
							local message = "|"..msg.."|"..name.."|"
							for i = 1, #info do
								if info[i] ~= 0 then
									message = message..i..":"..(info[i]).."|"
								end
									if (string.len(message) > 200) or i == #info then --if its too big or its the last data
										GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMSend"..player, message}
										message = "|"..msg.."|"..name.."|"
									end
								--end
							end
							GMaster:Debug(message.."this is being sent out in reply to a request")
						end
					end
				end
			end
		elseif prefix:find("^GMCurrentStart"..PlayerName) then
				GMaster:Debug("Recieved start from"..player)
				GMaster:Debug("setting start of table to "..msg)
				GMSettings.StartTime = tonumber(msg)
				if not GMLogs then
					GMLogs = {}
				end
				GMLogs[GMSettings.StartTime] = {}
				GMSettings.Active = nil --stop the other addon recording directly to the table
				--recieve the current table name
		elseif prefix:find("GMCurrent"..PlayerName) then
			--sort the msg and apply it directly to the table
			GMaster:Debug("Recieving current table from "..player.."msg = "..msg)
			local name = msg:match("^(.-)|")
			if not name then return end --temporary fix until i can work out why name wouldnt get sent out, or would get recorded as nothing
			GMaster:Debug("name = "..name)
			
			for index, value in msg:gmatch("|(%d+):(%d+)") do
				index = tonumber(index)
				value = tonumber(value)
				GMaster.AddInfo(name, "current", index, value)
			end
		
		
		elseif prefix:find(("^GMCurrentEnd"..PlayerName)) or (prefix:find("^GMCurrentEnd") and (player == PlayerName)) then
			--if its the oldest addon or the newest, start them recording again
			GMaster:Debug("Recieved End from"..player)
			local msg = "|"
			
			PingSent = nil
			GMSettings.Active = true
			--[[
				At this point, the master addon should have sent all of the info for 
				the current table to the new addon.
				The new addon and old addon now need to share with each other which tables they have, so that they
				can find out which tables they are missing
			--]]
			if GMLogs then
				for dated, info in pairs(GMLogs) do
					if not (dated == GMSettings.StartTime) then --dont send the current table
						if info.LastRecord then
						GMaster:Debug("info.LastRecord = "..info.LastRecord)
						msg = msg..dated.."-"..info.LastRecord.."|"
						GMaster.QueueTable[#GMaster.QueueTable + 1] = {"GMBroadcast", msg}
						msg = "|"
						GMaster:Debug("Sending old tables: "..msg)
						end
					end
				end
			end
		end
	end

	local test = CreateFrame("Frame")
	test:RegisterEvent("PLAYER_LEAVING_WORLD")
	test:SetScript("OnEvent", function() GMSettings.LastLogout = tonumber(time()) end)

end

GMaster.LoadOrder.GMSync = true--[[
1. Summary
2. Details
3. Structure
4. Changes
5. To Do

--========================== 1. Summary ===============================
A breif wizard to explain the functionality of the addon and each module.
--========================== 2. Details ===============================
	runs through each module with extra info on how the module works, 
	and the settings
--========================== 3. Structure =============================
	
--========================== 4. Changes ===============================
1.52
	Created the module.
--========================== 5. To do =================================
Everything
]]


--[[
For guild masters:
Welcome to guild master: it appears that you are in fact a guild master! Which is good because this
 addon is designed for you! This tutorial will run you through come of the functionality of the addon, 
 showing you each module and what it does. It's a bit of a read but its worth it, if you want to re read it
 any time, you can do so from the interface options.
 
 General:
 Guild master is designed to make every aspect of managing a guild easier for you. It does this by allowing
 you to automate laborious tasks such as ranking members based on their contributions, organising events,
 recruiting new members, etc.
 The addon is made up of a number of modules, which can be enabled or disabled depending on which you require them.
 
 
 The following is a breif summary of each module, and settings which will be reflected throughout the guild.
 
 GMAlts:
 This module records the alts of each player, and shares this information between guild members. 
 It is then used to group the player with their alts in the roster, to show a players total contribution 
 to the guild from all alts, and to rank the alts if you wish.
 
 Settings: Enable/disable
 
 
 GMEvent:
 This module allows you to quickly invite guild members to events based on certain requirements. It will not 
 invite anyone who is busy (in a party/battleground/instance/arena) and you can choose a minimum level, item
 level, or resilience. Any member who does not meet the requirement will not receive the invitation.
 Players that are invited choose which role they will fulfill, and players are no longer invited once each 
 role becomes full.
 Settings: Enable/disable
 
 GMForum:
 This module adds a forum to the guild frame which allows you to communicate with offline guild members.
 Each topic can be expanded/collapsed to show the replies. guild masters can delete any posts
 
 GMGuildFrame:
 This module is purely cosmetic; it rearranges the guild frame to make it more usable: the "Add Member" and "Guild Control buttons are on the first page, 
 for easier access. The perks and reputation rewards are both on the rewards page, and the MOTD, events, and news are on the main page.
 The 
 
 GMLocator:
 This module transmits location data from 


--]]
--================ GUI Stuff  =========================

local GMPages = {{x = 300, y = 150, title = "GMaster", body = "Welcome to the new improved Guild Master Suite!\nThis module provides a breif overview of what all of the other modules do."},
								 {x = 300, y = 150, title = "GM-Alts", body = "Shares data between players about whose alts are whose, so you know who your talking to. There is no graphical component."},
								 {x = 300, y = 150, title = "GM-Banker", body = "Adds filters to the guild bank so that you can auto sort all items by price/type/quality. Also allows you to view the guild bank without being near it."},
								 {x = 300, y = 150, title = "GM-Event", body = "Allows you to quickly start a guild event, only inviting players that meet your requirements (item level/resilience)/nClick 'New Event' In the guild frame to get started."},
									{x = 300, y = 150, title = "GM-GuildFrame", body = "Modifies the guild frame, relocating features to make the more useful aspects easier to access."},
									{x = 300, y = 150, title = "GM-Locator", body = "Shows guild members on the world map."},
									{x = 300, y = 150, title = "GM-MOTD", body = "Auto refreshes the guild message of the day a set intervals."},
									{x = 300, y = 150, title = "GM-Ranker", body = "Allows you to auto rank guild members based on certain criteria."},
									{x = 300, y = 150, title = "GM-Forum", body = "Adds an in-game forum to the guild frame, allowing you to communicate with offline players."},


									}
									
local Pages = {
}


GMaster.LoadOrder.GMTutorial = true

local TutFrame = CreateFrame("Frame", nil, UIParent)
TutFrame:SetBackdrop({bgFile = "Interface/Tooltips/UI-Tooltip-Background", 
                                            edgeFile = "Interface/Tooltips/UI-Tooltip-Border", 
                                            tile = true, tileSize = 16, edgeSize = 16, 
                                            insets = { left = 4, right = 4, top = 4, bottom = 4 }});
TutFrame:SetBackdropColor(0,0,0,1);


--=====================================================
TutFrame.Page = 1


TutFrame.close = CreateFrame("Button", nil, TutFrame, "UIPanelButtonTemplate")
TutFrame.close:SetText("x")
TutFrame.close:SetSize(15, 20)
TutFrame.close:SetPoint("TOPRIGHT", -5, -5)
TutFrame.close:SetScript("OnClick", function() TutFrame:Hide() end)

TutFrame.forward = CreateFrame("Button", nil, TutFrame, "UIPanelButtonTemplate")
TutFrame.forward:SetText(">")
TutFrame.forward:SetSize(15, 15)
TutFrame.forward:SetPoint("BOTTOMRIGHT", -5, 5)
TutFrame.forward:SetScript("OnClick", function() TutFrame:ShowPage(TutFrame.page+1) end)

TutFrame.back = CreateFrame("Button", nil, TutFrame, "UIPanelButtonTemplate")
TutFrame.back:SetText("<")
TutFrame.back:SetSize(15, 15)
TutFrame.back:SetPoint("BOTTOMRIGHT", -25, 5)
TutFrame.back:SetScript("OnClick", function() TutFrame:ShowPage(TutFrame.page-1) end)

TutFrame.title = TutFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
TutFrame.title:SetJustifyH("LEFT")
TutFrame.title:SetJustifyV("TOP")
TutFrame.title:SetPoint("TOPLEFT", 10, -10)
TutFrame.title:SetPoint("TOPRIGHT", 10, -30)

TutFrame.body = TutFrame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
TutFrame.body:SetJustifyH("LEFT")
TutFrame.body:SetJustifyV("TOP")
TutFrame.body:SetPoint("TOPLEFT", 10, -30)
TutFrame.body:SetPoint("BOTTOMRIGHT", -10, 10)



function TutFrame:ShowPage(page)



	if IsGuildLeader() then
		if GMPages[page] then
			TutFrame.back:Show()
			TutFrame.forward:Show()
			if page == 1 then
				TutFrame.back:Hide()
			elseif page == #GMPages then
				TutFrame.forward:Hide()
			end
			TutFrame:SetSize(GMPages[page].x, GMPages[page].y)
			TutFrame:SetPoint("Center")
			
			TutFrame.title:SetText(GMPages[page].title)
			TutFrame.body:SetText(GMPages[page].body)
		end
	else

	end
TutFrame.page = page
TutFrame:Show()
end

function GMaster.AL.GMTutorial()
	function GMaster.PEW.GMTutorial()
		if not GMSettings.modules.GMTutorial.hasrun then
			--TutFrame:ShowPage(1)
			--print("cheeeees")
		end
	end
end





















GMaster.TalentDB = {
["Warlock"] = {
								{ 
									["name"] = "Affliction", 
									["data"] = {
														
															{ "Doom and Gloom", "Interface\\Icons\\Spell_Shadow_CurseOfSargeras", 1, 1},
															{ "Improved Life Tap", "Interface\\Icons\\Spell_Shadow_BurningSpirit", 1, 2},
															{ "Improved Corruption", "Interface\\Icons\\Spell_Shadow_AbominationExplosion", 1, 3},
															{ "Jinx", "INTERFACE\\ICONS\\ability_warlock_jinx", 2, 1},
															{ "Soul Siphon", "INTERFACE\\ICONS\\ability_warlock_soulsiphon", 2, 2},
															{ "Siphon Life", "Interface\\Icons\\Spell_Shadow_Requiem", 2, 3},
															{ "Curse of Exhaustion", "Interface\\Icons\\Spell_Shadow_GrimWard", 3, 1},
															{ "Improved Fear", "Interface\\Icons\\Spell_Shadow_Possession", 3, 3},
															{ "Eradication", "Interface\\Icons\\Ability_Warlock_Eradication", 3, 4},
															{ "Improved Howl of Terror", "Interface\\Icons\\Spell_Shadow_DeathScream", 4, 1},
															{ "Soul Swap", "INTERFACE\\ICONS\\ability_warlock_soulswap", 4, 2},
															{ "Shadow Embrace", "Interface\\Icons\\Spell_Shadow_ShadowEmbrace", 4, 3},
															{ "Death's Embrace", "Interface\\Icons\\Spell_Shadow_DeathsEmbrace", 5, 1},
															{ "Nightfall", "Interface\\Icons\\Spell_Shadow_Twilight", 5, 2},
															{ "Soulburn: Seed of Corruption", "Interface\\Icons\\Spell_Shadow_SeedOfDestruction", 5, 3},
															{ "Everlasting Affliction", "Interface\\Icons\\Ability_Warlock_EverlastingAffliction", 6, 2},
															{ "Pandemic", "INTERFACE\\ICONS\\spell_shadow_lastingaffliction", 6, 3},
															{ "Haunt", "Interface\\Icons\\Ability_Warlock_Haunt", 7, 2},
														},
								},
								{
									["name"] = "Demonology", 
									["data"] = {
															{ "Demonic Embrace", "Interface\\Icons\\Spell_Shadow_Metamorphosis", 1, 1},
															{ "Dark Arts", "INTERFACE\\ICONS\\ability_warlock_darkarts", 1, 2},
															{ "Fel Synergy", "Interface\\Icons\\Spell_Shadow_FelMending", 1, 3},
															{ "Demonic Rebirth", "Interface\\Icons\\Spell_Shadow_DemonicTactics", 2, 1},
															{ "Mana Feed", "Interface\\Icons\\Spell_Shadow_ManaFeed", 2, 2},
															{ "Demonic Aegis", "Interface\\Icons\\Spell_Shadow_RagingScream", 2, 3},
															{ "Master Summoner", "Interface\\Icons\\Spell_Shadow_ImpPhaseShift", 2, 4},
															{ "Impending Doom", "Interface\\Icons\\Spell_Nature_RemoveCurse", 3, 1},
															{ "Demonic Empowerment", "Interface\\Icons\\Ability_Warlock_DemonicEmpowerment", 3, 2},
															{ "Improved Health Funnel", "Interface\\Icons\\Spell_Shadow_LifeDrain", 3, 3},
															{ "Molten Core", "Interface\\Icons\\Ability_Warlock_MoltenCore", 4, 1},
															{ "Hand of Gul'dan", "Interface\\Icons\\INV_SummerFest_FireSpirit", 4, 2},
															{ "Aura of Foreboding", "Interface\\Icons\\Spell_Shadow_SealOfKings", 4, 3},
															{ "Ancient Grimoire", "INTERFACE\\ICONS\\ability_warlock_ancientgrimoire", 5, 1},
															{ "Inferno", "INTERFACE\\ICONS\\ability_warlock_inferno", 5, 2},
															{ "Decimation", "Interface\\Icons\\Spell_Fire_Fireball02", 5, 3},
															{ "Cremation", "INTERFACE\\ICONS\\ability_warlock_cremation", 6, 2},
															{ "Demonic Pact", "Interface\\Icons\\Spell_Shadow_DemonicPact", 6, 3},
															{ "Metamorphosis", "Interface\\Icons\\Spell_Shadow_DemonForm", 7, 2},
															},
								},
								{ 
									["name"] = "Destruction", 
									["data"] = {
															{ "Bane", "Interface\\Icons\\Spell_Shadow_DeathPact", 1, 1},
															{ "Shadow and Flame", "Interface\\Icons\\Spell_Shadow_ShadowandFlame", 1, 2},
															{ "Improved Immolate", "Interface\\Icons\\Spell_Fire_Immolation", 1, 3},
															{ "Aftermath", "Interface\\Icons\\Spell_Fire_Fire", 2, 1},
															{ "Emberstorm", "Interface\\Icons\\Spell_Fire_SelfDestruct", 2, 2},
															{ "Improved Searing Pain", "Interface\\Icons\\Spell_Fire_SoulBurn", 2, 3},
															{ "Improved Soul Fire", "Interface\\Icons\\Spell_Fire_Fireball02", 3, 1},
															{ "Backdraft", "Interface\\Icons\\Ability_Warlock_Backdraft", 3, 2},
															{ "Shadowburn", "Interface\\Icons\\Spell_Shadow_ScourgeBuild", 3, 3},
															{ "Burning Embers", "INTERFACE\\ICONS\\ability_warlock_burningembers", 4, 1},
															{ "Soul Leech", "Interface\\Icons\\Spell_Shadow_SoulLeech_3", 4, 2},
															{ "Backlash", "Interface\\Icons\\Spell_Fire_PlayingWithFire", 4, 3},
															{ "Nether Ward", "Interface\\Icons\\Spell_Fire_FelFireward", 4, 4},
															{ "Fire and Brimstone", "Interface\\Icons\\Ability_Warlock_FireandBrimstone", 5, 2},
															{ "Shadowfury", "Interface\\Icons\\Spell_Shadow_Shadowfury", 5, 3},
															{ "Nether Protection", "Interface\\Icons\\Spell_Shadow_NetherProtection", 5, 4},
															{ "Empowered Imp", "Interface\\Icons\\Ability_Warlock_EmpoweredImp", 6, 1},
															{ "Bane of Havoc", "INTERFACE\\ICONS\\ability_warlock_baneofhavoc", 6, 3},
															{ "Chaos Bolt", "Interface\\Icons\\Ability_Warlock_ChaosBolt", 7, 2},
															}
								}
		},
								
["Rogue"] = {
							{
								["name"] = "Assassination", 
								["data"] = {	
															{ "Deadly Momentum", "INTERFACE\\ICONS\\ability_rogue_deadlymomentum", 1, 1},
															{ "Coup de Grace", "Interface\\Icons\\Ability_Rogue_Eviscerate", 1, 2},
															{ "Lethality", "Interface\\Icons\\Ability_CriticalStrike", 1, 3},
															{ "Ruthlessness", "Interface\\Icons\\Ability_Druid_Disembowel", 2, 1},
															{ "Quickening", "Interface\\Icons\\Ability_Rogue_QuickRecovery", 2, 2},
															{ "Puncturing Wounds", "Interface\\Icons\\Ability_BackStab", 2, 3},
															{ "Blackjack", "INTERFACE\\ICONS\\ability_rogue_blackjack", 2, 4},
															{ "Deadly Brew", "Interface\\Icons\\Ability_Rogue_DeadlyBrew", 3, 1},
															{ "Cold Blood", "Interface\\Icons\\Spell_Ice_Lament", 3, 2},
															{ "Vile Poisons", "Interface\\Icons\\Ability_Rogue_FeignDeath", 3, 3},
															{ "Deadened Nerves", "Interface\\Icons\\Ability_Rogue_DeadenedNerves", 4, 1},
															{ "Seal Fate", "Interface\\Icons\\Ability_Rogue_StayofExecution", 4, 2},
															{ "Murderous Intent", "Interface\\Icons\\Spell_Shadow_DeathScream", 5, 1},
															{ "Overkill", "Interface\\Icons\\Ability_Hunter_RapidKilling", 5, 2},
															{ "Master Poisoner", "Interface\\Icons\\Ability_Creature_Poison_06", 5, 3},
															{ "Improved Expose Armor", "Interface\\Icons\\Ability_Warrior_Riposte", 5, 4},
															{ "Cut to the Chase", "Interface\\Icons\\Ability_Rogue_CutToTheChase", 6, 2},
															{ "Venomous Wounds", "INTERFACE\\ICONS\\ability_rogue_venomouswounds", 6, 3},
															{ "Vendetta", "INTERFACE\\ICONS\\ability_rogue_deadliness", 7, 2},
														},
							},
							{ 
								["name"] = "Combat", 
								["data"] = {
															{ "Improved Recuperate", "INTERFACE\\ICONS\\ability_rogue_improvedrecuperate", 1, 1},
															{ "Improved Sinister Strike", "Interface\\Icons\\Spell_Shadow_RitualOfSacrifice", 1, 2},
															{ "Precision", "Interface\\Icons\\Ability_Marksmanship", 1, 3},
															{ "Improved Slice and Dice", "Interface\\Icons\\Ability_Rogue_SliceDice", 2, 1},
															{ "Improved Sprint", "Interface\\Icons\\Ability_Rogue_Sprint", 2, 2},
															{ "Aggression", "Interface\\Icons\\Ability_Racial_Avatar", 2, 3},
															{ "Improved Kick", "Interface\\Icons\\Ability_Kick", 2, 4},
															{ "Lightning Reflexes", "Interface\\Icons\\Spell_Nature_Invisibilty", 3, 1},
															{ "Revealing Strike", "INTERFACE\\ICONS\\inv_sword_97", 3, 2},
															{ "Reinforced Leather", "INTERFACE\\ICONS\\ability_rogue_reinforcedleather", 3, 3},
															{ "Improved Gouge", "Interface\\Icons\\Ability_Gouge", 3, 4},
															{ "Combat Potency", "Interface\\Icons\\INV_Weapon_Shortblade_38", 4, 2},
															{ "Blade Twisting", "Interface\\Icons\\Ability_Rogue_BladeTwisting", 4, 3},
															{ "Throwing Specialization", "Interface\\Icons\\Ability_Rogue_ThrowingSpecialization", 5, 1},
															{ "Adrenaline Rush", "Interface\\Icons\\Spell_Shadow_ShadowWordDominate", 5, 2},
															{ "Savage Combat", "Interface\\Icons\\Ability_Creature_Disease_03", 5, 3},
															{ "Bandit's Guile", "Interface\\Icons\\Ability_Rogue_PreyontheWeak", 6, 1},
															{ "Restless Blades", "INTERFACE\\ICONS\\ability_rogue_restlessblades", 6, 3},
															{ "Killing Spree", "Interface\\Icons\\Ability_Rogue_MurderSpree", 7, 2},
														}
							},
							{
								["name"] = "Subtlety", 
								["data"] = {
															{ "Nightstalker", "Interface\\Icons\\Ability_Stealth", 1, 1},
															{ "Improved Ambush", "Interface\\Icons\\Ability_Rogue_Ambush", 1, 2},
															{ "Relentless Strikes", "Interface\\Icons\\Ability_Warrior_DecisiveStrike", 1, 3},
															{ "Elusiveness", "Interface\\Icons\\Spell_Magic_LesserInvisibilty", 2, 1},
															{ "Waylay", "Interface\\Icons\\Ability_Rogue_Waylay", 2, 2},
															{ "Opportunity", "Interface\\Icons\\Ability_Rogue_BloodSplatter", 2, 3},
															{ "Initiative", "Interface\\Icons\\Spell_Shadow_Fumble", 2, 4},
															{ "Energetic Recovery", "INTERFACE\\ICONS\\ability_rogue_sturdyrecuperate", 3, 1},
															{ "Find Weakness", "Interface\\Icons\\Ability_Rogue_FindWeakness", 3, 2},
															{ "Hemorrhage", "Interface\\Icons\\Spell_Shadow_LifeDrain", 3, 3},
															{ "Honor Among Thieves", "Interface\\Icons\\Ability_Rogue_HonorAmongstThieves", 4, 1},
															{ "Premeditation", "Interface\\Icons\\Spell_Shadow_Possession", 4, 2},
															{ "Enveloping Shadows", "Interface\\Icons\\Ability_Rogue_EnvelopingShadows", 4, 4},
															{ "Cheat Death", "Interface\\Icons\\Ability_Rogue_CheatDeath", 5, 1},
															{ "Preparation", "INTERFACE\\ICONS\\ability_rogue_preparation", 5, 2},
															{ "Sanguinary Vein", "INTERFACE\\ICONS\\ability_rogue_sanguinaryvein", 5, 3},
															{ "Slaughter from the Shadows", "Interface\\Icons\\Ability_Rogue_SlaughterfromtheShadows", 6, 2},
															{ "Serrated Blades", "Interface\\Icons\\INV_Sword_17", 6, 3},
															{ "Shadow Dance", "Interface\\Icons\\Ability_Rogue_ShadowDance", 7, 2},
														}
							}
						},

["Druid"] = {
							{ 
								["name"] = "Balance", 
								["data"] = {
														{ "Nature's Grace", "Interface\\Icons\\Spell_Nature_NaturesBlessing", 1, 1},
														{ "Starlight Wrath", "Interface\\Icons\\Spell_Nature_AbolishMagic", 1, 2},
														{ "Nature's Majesty", "Interface\\Icons\\INV_Staff_01", 1, 3},
														{ "Genesis", "Interface\\Icons\\Spell_Arcane_Arcane03", 2, 1},
														{ "Moonglow", "Interface\\Icons\\Spell_Nature_Sentinal", 2, 2},
														{ "Balance of Power", "Interface\\Icons\\Ability_Druid_BalanceofPower", 2, 3},
														{ "Euphoria", "INTERFACE\\ICONS\\achievement_boss_valithradreamwalker", 3, 1},
														{ "Moonkin Form", "Interface\\Icons\\Spell_Nature_ForceOfNature", 3, 2},
														{ "Typhoon", "Interface\\Icons\\Ability_Druid_Typhoon", 3, 3},
														{ "Shooting Stars", "Interface\\Icons\\Ability_Mage_ArcaneBarrage", 3, 4},
														{ "Owlkin Frenzy", "Interface\\Icons\\Ability_Druid_OwlkinFrenzy", 4, 2},
														{ "Gale Winds", "Interface\\Icons\\Ability_Druid_GaleWinds", 4, 3},
														{ "Solar Beam", "Interface\\Icons\\ability_vehicle_sonicshockwave", 4, 4},
														{ "Dreamstate", "Interface\\Icons\\Ability_Druid_Dreamstate", 5, 1},
														{ "Force of Nature", "Interface\\Icons\\Ability_Druid_ForceofNature", 5, 2},
														{ "Sunfire", "Interface\\Icons\\Ability_Mage_FireStarter", 5, 3},
														{ "Earth and Moon", "Interface\\Icons\\Ability_Druid_EarthandSky", 5, 4},
														{ "Fungal Growth", "Interface\\Icons\\Creature_SporeMushroom", 6, 2},
														{ "Lunar Shower", "Interface\\Icons\\Achievement_WorldEvent_Lunar", 6, 3},
														{ "Starfall", "Interface\\Icons\\Ability_Druid_Starfall", 7, 2},
													 },
							},
							{
								["name"] = "Feral Combat", 
								["data"] = {
														{ "Feral Swiftness", "Interface\\Icons\\Spell_Nature_SpiritWolf", 1, 1},
														{ "Furor", "Interface\\Icons\\Spell_Holy_BlessingOfStamina", 1, 2},
														{ "Predatory Strikes", "Interface\\Icons\\Ability_Hunter_Pet_Cat", 1, 3},
														{ "Infected Wounds", "Interface\\Icons\\Ability_Druid_InfectedWound", 2, 1},
														{ "Fury Swipes", "Interface\\Icons\\Ability_Druid_Mangle.tga", 2, 2},
														{ "Primal Fury", "Interface\\Icons\\Ability_Racial_Cannibalize", 2, 3},
														{ "Feral Aggression", "Interface\\Icons\\Ability_Druid_DemoralizingRoar", 2, 4},
														{ "King of the Jungle", "Interface\\Icons\\Ability_Druid_KingoftheJungle", 3, 1},
														{ "Feral Charge", "Interface\\Icons\\Ability_Hunter_Pet_Bear", 3, 2},
														{ "Stampede", "Interface\\Icons\\spell_druid_feralchargecat", 3, 3},
														{ "Thick Hide", "Interface\\Icons\\INV_Misc_Pelt_Bear_03", 3, 4},
														{ "Leader of the Pack", "Interface\\Icons\\Spell_Nature_UnyeildingStamina", 4, 2},
														{ "Brutal Impact", "Interface\\Icons\\Ability_Druid_Bash", 4, 3},
														{ "Nurturing Instinct", "Interface\\Icons\\Ability_Druid_HealingInstincts", 4, 4},
														{ "Primal Madness", "Interface\\Icons\\Ability_Mount_JungleTiger", 5, 1},
														{ "Survival Instincts", "Interface\\Icons\\Ability_Druid_TigersRoar", 5, 2},
														{ "Endless Carnage", "Interface\\Icons\\Spell_DeathKnight_BloodBoil", 5, 3},
														{ "Natural Reaction", "Interface\\Icons\\Ability_BullRush", 5, 4},
														{ "Blood in the Water", "INTERFACE\\ICONS\\inv_misc_food_134_meat", 6, 1},
														{ "Rend and Tear", "Interface\\Icons\\Ability_Druid_PrimalAgression", 6, 2},
														{ "Pulverize", "Interface\\Icons\\Ability_Smash", 6, 3},
														{ "Berserk", "Interface\\Icons\\Ability_Druid_Berserk", 7, 2},
													 }
							},
							{ 
								["name"] = "Restoration", 
								["data"] = {
														{ "Blessing of the Grove", "Interface\\Icons\\Spell_Shaman_SpiritLink", 1, 1},
														{ "Natural Shapeshifter", "Interface\\Icons\\Spell_Nature_WispSplode", 1, 2},
														{ "Naturalist", "Interface\\Icons\\Spell_Nature_HealingTouch", 1, 3},
														{ "Heart of the Wild", "Interface\\Icons\\Spell_Holy_BlessingOfAgility", 1, 4},
														{ "Perseverance", "Interface\\Icons\\Achievement_Zone_Darnassus", 2, 1},
														{ "Master Shapeshifter", "Interface\\Icons\\Ability_Druid_MasterShapeshifter", 2, 2},
														{ "Improved Rejuvenation", "Interface\\Icons\\Spell_Nature_Rejuvenation", 2, 3},
														{ "Living Seed", "Interface\\Icons\\Ability_Druid_GiftoftheEarthmother", 3, 1},
														{ "Revitalize", "Interface\\Icons\\Ability_Druid_Replenish", 3, 2},
														{ "Nature's Swiftness", "Interface\\Icons\\Spell_Nature_RavenForm", 3, 3},
														{ "Fury of Stormrage", "INTERFACE\\ICONS\\inv_staff_90", 3, 4},
														{ "Nature's Bounty", "Interface\\Icons\\Spell_Nature_ResistNature", 4, 2},
														{ "Empowered Touch", "Interface\\Icons\\Ability_Druid_EmpoweredTouch", 4, 3},
														{ "Malfurion's Gift", "Interface\\Icons\\Spell_Shaman_GiftEarthmother", 4, 4},
														{ "Efflorescence", "Interface\\Icons\\INV_Misc_Herb_TalandrasRose", 5, 1},
														{ "Wild Growth", "Interface\\Icons\\Ability_Druid_Flourish", 5, 2},
														{ "Nature's Cure", "Interface\\Icons\\Ability_Shaman_CleanseSpirit", 5, 3},
														{ "Nature's Ward", "Interface\\Icons\\Ability_Druid_NaturalPerfection", 5, 4},
														{ "Gift of the Earthmother", "Interface\\Icons\\Ability_Druid_ManaTree", 6, 1},
														{ "Swift Rejuvenation", "Interface\\Icons\\Ability_Druid_EmpoweredRejuvination", 6, 3},
														{ "Tree of Life", "Interface\\Icons\\Ability_Druid_TreeofLife", 7, 2},
												   }
							}
			},

["Hunter"] = {
							{ 
								["name"] = "Beast Mastery", 
								["data"] = {
														{ "Improved Kill Command", "Interface\\Icons\\Ability_Hunter_SilentHunter", 1, 1},
														{ "One with Nature", "INTERFACE\\ICONS\\ability_hunter_onewithnature", 1, 2},
														{ "Bestial Discipline", "INTERFACE\\ICONS\\ability_hunter_bestialdiscipline", 1, 3},
														{ "Pathfinding", "INTERFACE\\ICONS\\ability_hunter_pathfinding2", 2, 1},
														{ "Spirit Bond", "Interface\\Icons\\Ability_Druid_DemoralizingRoar", 2, 2},
														{ "Frenzy", "Interface\\Icons\\INV_Misc_MonsterClaw_03", 2, 3},
														{ "Improved Mend Pet", "Interface\\Icons\\Ability_Hunter_MendPet", 2, 4},
														{ "Cobra Strikes", "Interface\\Icons\\Ability_Hunter_CobraStrikes", 3, 1},
														{ "Fervor", "Interface\\Icons\\Ability_Hunter_AspectoftheViper", 3, 2},
														{ "Focus Fire", "INTERFACE\\ICONS\\ability_hunter_focusfire", 3, 3},
														{ "Longevity", "Interface\\Icons\\Ability_Hunter_Longevity", 4, 1},
														{ "Killing Streak", "INTERFACE\\ICONS\\achievement_bg_kill_carrier_opposing_flagroom", 4, 3},
														{ "Crouching Tiger, Hidden Chimera", "INTERFACE\\ICONS\\ability_hunter_pet_chimera", 5, 1},
														{ "Bestial Wrath", "Interface\\Icons\\Ability_Druid_FerociousBite", 5, 2},
														{ "Ferocious Inspiration", "Interface\\Icons\\Ability_Hunter_FerociousInspiration", 5, 3},
														{ "Kindred Spirits", "Interface\\Icons\\Ability_Hunter_SeparationAnxiety", 6, 1},
														{ "The Beast Within", "Interface\\Icons\\Ability_Hunter_BeastWithin", 6, 2},
														{ "Invigoration", "Interface\\Icons\\Ability_Hunter_Invigeration", 6, 3},
														{ "Beast Mastery", "Interface\\Icons\\Ability_Hunter_BeastMastery", 7, 2},
													 }
							},
							{ 
								["name"] = "Marksmanship", 
								["data"] = {
														{ "Go for the Throat", "Interface\\Icons\\Ability_Hunter_GoForTheThroat", 1, 1},
														{ "Efficiency", "Interface\\Icons\\Ability_Hunter_FocusedAim", 1, 2},
														{ "Rapid Killing", "Interface\\Icons\\Ability_Hunter_RapidKilling", 1, 3},
														{ "Sic 'Em!", "INTERFACE\\ICONS\\ability_hunter_sickem", 2, 1},
														{ "Improved Steady Shot", "Interface\\Icons\\Ability_Hunter_ImprovedSteadyShot", 2, 2},
														{ "Careful Aim", "Interface\\Icons\\Ability_Hunter_ZenArchery", 2, 3},
														{ "Silencing Shot", "Interface\\Icons\\Ability_TheBlackArrow", 3, 1},
														{ "Concussive Barrage", "INTERFACE\\ICONS\\ability_hunter_efficiency", 3, 2},
														{ "Piercing Shots", "Interface\\Icons\\Ability_Hunter_PiercingShots", 3, 3},
														{ "Bombardment", "Interface\\Icons\\Ability_Marksmanship", 4, 1},
														{ "Trueshot Aura", "Interface\\Icons\\Ability_TrueShot", 4, 2},
														{ "Termination", "Interface\\Icons\\Ability_Warrior_FocusedRage", 4, 3},
														{ "Resistance is Futile", "INTERFACE\\ICONS\\ability_hunter_resistanceisfutile", 4, 4},
														{ "Rapid Recuperation", "Interface\\Icons\\Ability_Hunter_RapidRegeneration", 5, 1},
														{ "Master Marksman", "Interface\\Icons\\Ability_Hunter_MasterMarksman", 5, 2},
														{ "Readiness", "Interface\\Icons\\Ability_Hunter_Readiness", 5, 4},
														{ "Posthaste", "INTERFACE\\ICONS\\ability_hunter_posthaste", 6, 1},
														{ "Marked for Death", "Interface\\Icons\\Ability_Hunter_Assassinate", 6, 3},
														{ "Chimera Shot", "Interface\\Icons\\Ability_Hunter_ChimeraShot2", 7, 2},
													 }
							},
							{
								["name"] = "Survival", 
								["data"] = {
														{ "Hunter vs. Wild", "Interface\\Icons\\Ability_Hunter_HunterVsWild", 1, 1},
														{ "Pathing", "Interface\\Icons\\Ability_Hunter_ImprovedTracking", 1, 2},
														{ "Improved Serpent Sting", "Interface\\Icons\\Ability_Hunter_Quickshot", 1, 3},
														{ "Survival Tactics", "Interface\\Icons\\Ability_Rogue_FeignDeath", 2, 1},
														{ "Trap Mastery", "Interface\\Icons\\Ability_Ensnare", 2, 2},
														{ "Entrapment", "Interface\\Icons\\Spell_Nature_StrangleVines", 2, 3},
														{ "Point of No Escape", "Interface\\Icons\\Ability_Hunter_PointofNoEscape", 2, 4},
														{ "Thrill of the Hunt", "Interface\\Icons\\Ability_Hunter_ThrilloftheHunt", 3, 1},
														{ "Counterattack", "Interface\\Icons\\Ability_Warrior_Challange", 3, 2},
														{ "Lock and Load", "Interface\\Icons\\Ability_Hunter_LockAndLoad", 3, 3},
														{ "Resourcefulness", "Interface\\Icons\\Ability_Hunter_Resourcefulness", 4, 1},
														{ "Mirrored Blades", "INTERFACE\\ICONS\\inv_weapon_shortblade_99", 4, 2},
														{ "T.N.T.", "Interface\\Icons\\INV_Misc_Bomb_05", 4, 3},
														{ "Toxicology", "INTERFACE\\ICONS\\inv_alchemy_enchantedvial", 5, 1},
														{ "Wyvern Sting", "Interface\\Icons\\INV_Spear_02", 5, 2},
														{ "Noxious Stings", "Interface\\Icons\\Ability_Hunter_PotentVenom", 5, 3},
														{ "Hunting Party", "Interface\\Icons\\Ability_Hunter_HuntingParty", 5, 4},
														{ "Sniper Training", "Interface\\Icons\\Ability_Hunter_LongShots", 6, 1},
														{ "Serpent Spread", "Interface\\Icons\\Ability_Hunter_SerpentSwiftness", 6, 3},
														{ "Black Arrow", "Interface\\Icons\\Spell_Shadow_PainSpike", 7, 2},
													 }
							},
						 },
						 
["Mage"] = {
							{
								["name"] = "Arcane", 
								["data"] = {
														{ "Arcane Concentration", "Interface\\Icons\\Spell_Shadow_ManaBurn", 1, 1},
														{ "Improved Counterspell", "Interface\\Icons\\Spell_Frost_IceShock", 1, 2},
														{ "Netherwind Presence", "Interface\\Icons\\Ability_Mage_NetherWindPresence", 1, 3},
														{ "Torment the Weak", "Interface\\Icons\\Spell_Arcane_FocusedPower", 2, 1},
														{ "Invocation", "INTERFACE\\ICONS\\spell_arcane_invocation", 2, 2},
														{ "Improved Arcane Missiles", "Interface\\Icons\\Spell_Nature_StarFall", 2, 3},
														{ "Improved Blink", "Interface\\Icons\\Spell_Arcane_Blink", 2, 4},
														{ "Arcane Flows", "Interface\\Icons\\Ability_Mage_PotentSpirit", 3, 1},
														{ "Presence of Mind", "Interface\\Icons\\Spell_Nature_EnchantArmor", 3, 2},
														{ "Missile Barrage", "Interface\\Icons\\Ability_Mage_MissileBarrage", 3, 3},
														{ "Prismatic Cloak", "Interface\\Icons\\Spell_Arcane_PrismaticCloak", 3, 4},
														{ "Improved Polymorph", "Interface\\Icons\\Spell_Nature_Polymorph", 4, 1},
														{ "Arcane Tactics", "INTERFACE\\ICONS\\spell_arcane_arcanetactics", 4, 2},
														{ "Incanter's Absorption", "Interface\\Icons\\Ability_Mage_IncantersAbsorbtion", 4, 3},
														{ "test", "test", 1, 1},
														{ "Improved Arcane Explosion", "Interface\\Icons\\Spell_Nature_WispSplode", 4, 4},
														{ "Arcane Potency", "Interface\\Icons\\Spell_Arcane_ArcanePotency", 5, 1},
														{ "Slow", "Interface\\Icons\\Spell_Nature_Slow", 5, 2},
														{ "Nether Vortex", "Interface\\Icons\\Spell_Arcane_Blast", 5, 3},
														{ "Focus Magic", "Interface\\Icons\\Spell_Arcane_StudentOfMagic", 6, 1},
														{ "Improved Mana Gem", "Interface\\Icons\\INV_Misc_Gem_Emerald_01", 6, 3},
														{ "Arcane Power", "Interface\\Icons\\Spell_Nature_Lightning", 7, 2},
													 }
							},
							{
								["name"] = "Fire", 
								["data"] = {
														{ "Master of Elements", "Interface\\Icons\\Spell_Fire_MasterOfElements", 1, 1},
														{ "Burning Soul", "INTERFACE\\ICONS\\spell_burningsoul", 1, 2},
														{ "Improved Fire Blast", "Interface\\Icons\\Spell_Fire_Fireball", 1, 3},
														{ "Ignite", "Interface\\Icons\\Spell_Fire_Incinerate", 2, 1},
														{ "Fire Power", "Interface\\Icons\\Spell_Fire_Immolation", 2, 2},
														{ "Blazing Speed", "Interface\\Icons\\Spell_Fire_BurningSpeed", 2, 3},
														{ "Impact", "Interface\\Icons\\Spell_Fire_MeteorStorm", 2, 4},
														{ "Cauterize", "Interface\\Icons\\spell_fire_rune", 3, 1},
														{ "Blast Wave", "Interface\\Icons\\Spell_Holy_Excorcism_02", 3, 2},
														{ "Hot Streak", "Interface\\Icons\\Ability_Mage_HotStreak", 3, 3},
														{ "Improved Scorch", "Interface\\Icons\\Spell_Fire_SoulBurn", 3, 4},
														{ "Molten Shields", "Interface\\Icons\\Spell_Fire_FireArmor", 4, 1},
														{ "Combustion", "Interface\\Icons\\Spell_Fire_SealOfFire", 4, 2},
														{ "Improved Hot Streak", "Interface\\Icons\\Ability_Mage_HotStreak", 4, 3},
														{ "Firestarter", "Interface\\Icons\\Ability_Mage_FireStarter", 4, 4},
														{ "Improved Flamestrike", "Interface\\Icons\\Spell_Fire_SelfDestruct", 5, 1},
														{ "Dragon's Breath", "Interface\\Icons\\INV_Misc_Head_Dragon_01", 5, 2},
														{ "Molten Fury", "Interface\\Icons\\Spell_Fire_MoltenBlood", 5, 3},
														{ "Pyromaniac", "Interface\\Icons\\Spell_Fire_Burnout", 6, 1},
														{ "Critical Mass", "Interface\\Icons\\Spell_Nature_WispHeal", 6, 3},
														{ "Living Bomb", "Interface\\Icons\\Ability_Mage_LivingBomb", 7, 2},
													 }
							},
							{ 
								["name"] = "Frost", 
								["data"] = {
														{ "Early Frost", "Interface\\Icons\\Spell_Frost_ChillingBolt", 1, 1},
														{ "Piercing Ice", "Interface\\Icons\\Spell_Frost_Frostbolt", 1, 2},
														{ "Shatter", "Interface\\Icons\\Spell_Frost_FrostShock", 1, 3},
														{ "Ice Floes", "Interface\\Icons\\Spell_Frost_IceFloes", 2, 1},
														{ "Improved Cone of Cold", "Interface\\Icons\\Spell_Frost_Glacier", 2, 2},
														{ "Piercing Chill", "INTERFACE\\ICONS\\spell_frost_piercing chill", 2, 3},
														{ "Permafrost", "Interface\\Icons\\Spell_Frost_Wisp", 2, 4},
														{ "Ice Shards", "INTERFACE\\ICONS\\spell_frost_ice shards", 3, 1},
														{ "Icy Veins", "Interface\\Icons\\Spell_Frost_ColdHearted", 3, 2},
														{ "Fingers of Frost", "Interface\\Icons\\Ability_Mage_WintersGrasp", 3, 3},
														{ "Improved Freeze", "Interface\\Icons\\Spell_Frost_SummonWaterElemental", 3, 4},
														{ "Enduring Winter", "Interface\\Icons\\Spell_Frost_ArcticWinds", 4, 1},
														{ "Cold Snap", "Interface\\Icons\\Spell_Frost_WizardMark", 4, 2},
														{ "Brain Freeze", "Interface\\Icons\\Ability_Mage_BrainFreeze", 4, 3},
														{ "Shattered Barrier", "Interface\\Icons\\Ability_Mage_ColdAsIce", 5, 1},
														{ "Ice Barrier", "Interface\\Icons\\Spell_Ice_Lament", 5, 2},
														{ "Reactive Barrier", "Interface\\Icons\\Spell_Frost_ManaRecharge", 5, 3},
														{ "Frostfire Orb", "INTERFACE\\ICONS\\spell_firefrost orb", 6, 3},
														{ "Deep Freeze", "Interface\\Icons\\Ability_Mage_DeepFreeze", 7, 2},
													 }
							}
					},
					
["Death Knight"] = {
										{ 
											["name"] = "Blood", 
											["data"] = {
																	{ "Butchery", "Interface\\Icons\\INV_Axe_68", 1, 1},
																	{ "Blade Barrier", "Interface\\Icons\\Ability_UpgradeMoonGlaive", 1, 2},
																	{ "Bladed Armor", "Interface\\Icons\\INV_Shoulder_36", 1, 3},
																	{ "Improved Blood Tap", "Interface\\Icons\\Spell_DeathKnight_BloodTap", 2, 1},
																	{ "Scent of Blood", "Interface\\Icons\\Ability_Rogue_BloodyEye", 2, 2},
																	{ "Scarlet Fever", "INTERFACE\\ICONS\\ability_rogue_vendetta", 2, 3},
																	{ "Hand of Doom", "INTERFACE\\ICONS\\ability_deathknight_desolation", 2, 4},
																	{ "Blood-Caked Blade", "Interface\\Icons\\Ability_CriticalStrike", 3, 1},
																	{ "Bone Shield", "INTERFACE\\ICONS\\ability_deathknight_boneshield", 3, 2},
																	{ "Toughness", "Interface\\Icons\\Spell_Holy_Devotion", 3, 3},
																	{ "Abomination's Might", "Interface\\Icons\\Ability_Warrior_IntensifyRage", 3, 4},
																	{ "Sanguine Fortitude", "INTERFACE\\ICONS\\ability_deathknight_sanguinfortitude", 4, 1},
																	{ "Blood Parasite", "Interface\\Icons\\Spell_Shadow_SoulLeech", 4, 2},
																	{ "Improved Blood Presence", "Interface\\Icons\\Spell_Deathknight_BloodPresence", 4, 3},
																	{ "Will of the Necropolis", "Interface\\Icons\\Ability_Creature_Cursed_02", 5, 1},
																	{ "Rune Tap", "Interface\\Icons\\Spell_DeathKnight_RuneTap", 5, 2},
																	{ "Vampiric Blood", "Interface\\Icons\\Spell_Shadow_LifeDrain", 5, 3},
																	{ "Improved Death Strike", "Interface\\Icons\\Spell_DeathKnight_Butcher2", 6, 2},
																	{ "Crimson Scourge", "Interface\\Icons\\Spell_DeathKnight_BloodBoil", 6, 3},
																	{ "Dancing Rune Weapon", "Interface\\Icons\\INV_Sword_07", 7, 2},
																 }
										},
										{
											["name"] = "Frost", 
											["data"] = {
																	{ "Runic Power Mastery", "Interface\\Icons\\Spell_Arcane_Arcane01", 1, 1},
																	{ "Icy Reach", "Interface\\Icons\\Spell_Frost_ManaRecharge", 1, 2},
																	{ "Nerves of Cold Steel", "Interface\\Icons\\Ability_DualWield", 1, 3},
																	{ "Annihilation", "Interface\\Icons\\INV_Weapon_Hand_18", 2, 1},
																	{ "Lichborne", "Interface\\Icons\\Spell_Shadow_RaiseDead", 2, 2},
																	{ "On a Pale Horse", "Interface\\Icons\\Ability_Mount_Undeadhorse", 2, 3},
																	{ "Endless Winter", "Interface\\Icons\\Spell_Shadow_Twilight", 2, 4},
																	{ "Merciless Combat", "Interface\\Icons\\INV_Sword_112", 3, 1},
																	{ "Chill of the Grave", "Interface\\Icons\\Spell_Frost_FrostShock", 3, 2},
																	{ "Killing Machine", "Interface\\Icons\\INV_Sword_122", 3, 3},
																	{ "Rime", "Interface\\Icons\\Spell_Frost_FreezingBreath", 4, 1},
																	{ "Pillar of Frost", "INTERFACE\\ICONS\\ability_deathknight_pillaroffrost", 4, 2},
																	{ "Improved Icy Talons", "Interface\\Icons\\Spell_Deathknight_IcyTalons", 4, 3},
																	{ "Brittle Bones", "INTERFACE\\ICONS\\ability_deathknight_brittlebones", 4, 4},
																	{ "Chilblains", "Interface\\Icons\\Spell_Frost_Wisp", 5, 1},
																	{ "Hungering Cold", "Interface\\Icons\\INV_Staff_15", 5, 2},
																	{ "Improved Frost Presence", "Interface\\Icons\\Spell_Deathknight_FrostPresence", 5, 3},
																	{ "Threat of Thassarian", "Interface\\Icons\\Ability_DualWieldSpecialization", 6, 1},
																	{ "Might of the Frozen Wastes", "INTERFACE\\ICONS\\inv_sword_120", 6, 3},
																	{ "Howling Blast", "Interface\\Icons\\Spell_Frost_ArcticWinds", 7, 2},
																 }
										}
									},
										
["Warrior"] = {
								{
									["name"] = "Arms", 
									["data"] = {
															{ "War Academy", "Interface\\Icons\\Ability_Warrior_UnrelentingAssault", 1, 1},
															{ "Field Dressing", "Interface\\Icons\\INV_Misc_Bandage_05", 1, 2},
															{ "Blitz", "INTERFACE\\ICONS\\warrior_talent_icon_blitz", 1, 3},
															{ "Tactical Mastery", "Interface\\Icons\\Spell_Nature_EnchantArmor", 2, 1},
															{ "Second Wind", "Interface\\Icons\\Ability_Hunter_Harass", 2, 2},
															{ "Deep Wounds", "Interface\\Icons\\Ability_BackStab", 2, 3},
															{ "Drums of War", "Interface\\Icons\\Achievement_BG_winWSG_3-0", 2, 4},
															{ "Taste for Blood", "Interface\\Icons\\Ability_Rogue_HungerforBlood", 3, 1},
															{ "Sweeping Strikes", "Interface\\Icons\\Ability_Rogue_SliceDice", 3, 2},
															{ "Impale", "Interface\\Icons\\Ability_SearingArrow", 3, 3},
															{ "Improved Hamstring", "Interface\\Icons\\Ability_ShockWave", 3, 4},
															{ "Improved Slam", "Interface\\Icons\\Ability_Warrior_DecisiveStrike", 4, 1},
															{ "Deadly Calm", "INTERFACE\\ICONS\\achievement_boss_kingymiron", 4, 2},
															{ "Blood Frenzy", "Interface\\Icons\\Ability_Warrior_BloodFrenzy", 4, 3},
															{ "Lambs to the Slaughter", "INTERFACE\\ICONS\\warrior_talent_icon_lambstotheslaughter", 5, 1},
															{ "Juggernaut", "Interface\\Icons\\Ability_Warrior_BullRush", 5, 2},
															{ "Sudden Death", "Interface\\Icons\\Ability_Warrior_ImprovedDisciplines", 5, 4},
															{ "Wrecking Crew", "Interface\\Icons\\Ability_Warrior_Trauma", 6, 1},
															{ "Throwdown", "INTERFACE\\ICONS\\inv_mace_62", 6, 3},
															{ "Bladestorm", "Interface\\Icons\\Ability_Warrior_Bladestorm", 7, 2},
														 }
								},
								{
									["name"] = "Fury", 
									["data"] = {
															{ "Blood Craze", "Interface\\Icons\\Spell_Shadow_SummonImp", 1, 1},
															{ "Battle Trance", "Interface\\Icons\\INV_Helmet_06", 1, 2},
															{ "Cruelty", "Interface\\Icons\\Ability_Rogue_Eviscerate", 1, 3},
															{ "Executioner", "Interface\\Icons\\INV_Sword_48", 2, 1},
															{ "Booming Voice", "Interface\\Icons\\Spell_Nature_Purge", 2, 2},
															{ "Rude Interruption", "Interface\\Icons\\Ability_Warrior_CommandingShout", 2, 3},
															{ "Piercing Howl", "Interface\\Icons\\Spell_Shadow_DeathScream", 2, 4},
															{ "Flurry", "Interface\\Icons\\Ability_GhoulFrenzy", 3, 1},
															{ "Death Wish", "Interface\\Icons\\Spell_Shadow_DeathPact", 3, 2},
															{ "Enrage", "Interface\\Icons\\Spell_Shadow_UnholyFrenzy", 3, 3},
															{ "Die by the Sword", "INTERFACE\\ICONS\\inv_sword_86", 4, 1},
															{ "Raging Blow", "Interface\\Icons\\Ability_Hunter_SwiftStrike", 4, 2},
															{ "Rampage", "Interface\\Icons\\Ability_Warrior_Rampage", 4, 3},
															{ "Heroic Fury", "INTERFACE\\ICONS\\warrior_talent_icon_deadlycalm", 4, 4},
															{ "Furious Attacks", "Interface\\Icons\\Ability_Warrior_FuriousResolve", 5, 1},
															{ "Meat Cleaver", "INTERFACE\\ICONS\\warrior_talent_icon_mastercleaver", 5, 3},
															{ "Intensify Rage", "INTERFACE\\ICONS\\warrior_talent_icon_furyintheblood", 5, 4},
															{ "Bloodsurge", "Interface\\Icons\\Ability_Warrior_Bloodsurge", 6, 2},
															{ "Skirmisher", "INTERFACE\\ICONS\\warrior_talent_icon_skirmisher", 6, 3},
															{ "Titan's Grip", "Interface\\Icons\\Ability_Warrior_TitansGrip", 7, 2},
															{ "Single-Minded Fury", "INTERFACE\\ICONS\\warrior_talent_icon_singlemindedfury", 7, 3},
														 }
								},
								{ 
									["name"] = "Protection", 
									["data"] = {
															{ "Incite", "Interface\\Icons\\Ability_Warrior_Incite", 1, 1},
															{ "Toughness", "Interface\\Icons\\Spell_Holy_Devotion", 1, 2},
															{ "Blood and Thunder", "INTERFACE\\ICONS\\warrior_talent_icon_bloodandthunder", 1, 3},
															{ "Shield Specialization", "Interface\\Icons\\INV_Shield_06", 2, 1},
															{ "Shield Mastery", "Interface\\Icons\\Ability_Warrior_ShieldGuard", 2, 2},
															{ "Hold the Line", "Interface\\Icons\\Achievement_BG_DefendXtowers_AV", 2, 3},
															{ "Gag Order", "Interface\\Icons\\INV_Axe_66", 2, 4},
															{ "Last Stand", "Interface\\Icons\\Spell_Holy_AshesToAshes", 3, 1},
															{ "Concussion Blow", "Interface\\Icons\\Ability_ThunderBolt", 3, 2},
															{ "Bastion of Defense", "Interface\\Icons\\Ability_Defend", 3, 3},
															{ "Warbringer", "Interface\\Icons\\Ability_Warrior_Warbringer", 3, 4},
															{ "Improved Revenge", "Interface\\Icons\\Ability_Warrior_Revenge", 4, 1},
															{ "Devastate", "Interface\\Icons\\INV_Sword_11", 4, 3},
															{ "Impending Victory", "Interface\\Icons\\Ability_Warrior_Devastate", 4, 4},
															{ "Thunderstruck", "INTERFACE\\ICONS\\warrior_talent_icon_thunderstruck", 5, 1},
															{ "Vigilance", "Interface\\Icons\\Ability_Warrior_Vigilance", 5, 2},
															{ "Heavy Repercussions", "Interface\\Icons\\INV_Shield_01", 5, 4},
															{ "Safeguard", "Interface\\Icons\\Ability_Warrior_Safeguard", 6, 2},
															{ "Sword and Board", "Interface\\Icons\\Ability_Warrior_SwordandBoard", 6, 3},
															{ "Shockwave", "Interface\\Icons\\Ability_Warrior_Shockwave", 7, 2},
														}
								}
				},
["Shaman"] = {
								{ 
								["name"] = "Elemental", 
								["data"] = {
															{ "Acuity", "Interface\\Icons\\Spell_Nature_AstralRecalGroup", 1, 1},
															{ "Convection", "INTERFACE\\ICONS\\spell_shaman_convection", 1, 2},
															{ "Concussion", "Interface\\Icons\\Spell_Fire_Fireball", 1, 3},
															{ "Call of Flame", "Interface\\Icons\\Spell_Fire_Immolation", 2, 1},
															{ "Elemental Warding", "Interface\\Icons\\Spell_Nature_SpiritArmor", 2, 2},
															{ "Reverberation", "Interface\\Icons\\Spell_Frost_FrostWard", 2, 3},
															{ "Elemental Precision", "Interface\\Icons\\Spell_Nature_ElementalPrecision_1", 2, 4},
															{ "Rolling Thunder", "Interface\\Icons\\Spell_Nature_CallStorm", 3, 1},
															{ "Elemental Focus", "Interface\\Icons\\Spell_Shadow_ManaBurn", 3, 2},
															{ "Elemental Reach", "Interface\\Icons\\Spell_Nature_StormReach", 3, 3},
															{ "Elemental Oath", "Interface\\Icons\\Spell_Shaman_ElementalOath", 4, 2},
															{ "Lava Flows", "Interface\\Icons\\Spell_Shaman_LavaFlow", 4, 3},
															{ "Fulmination", "Interface\\Icons\\Spell_Nature_UnrelentingStorm", 5, 1},
															{ "Elemental Mastery", "Interface\\Icons\\Spell_Nature_WispHeal", 5, 2},
															{ "Earth's Grasp", "Interface\\Icons\\Spell_Nature_StrangleVines", 5, 3},
															{ "Totemic Wrath", "Interface\\Icons\\Spell_Fire_TotemOfWrath", 5, 4},
															{ "Feedback", "INTERFACE\\ICONS\\ability_vehicle_electrocharge", 6, 2},
															{ "Lava Surge", "INTERFACE\\ICONS\\spell_shaman_lavasurge", 6, 3},
															{ "Earthquake", "INTERFACE\\ICONS\\spell_shaman_earthquake", 7, 2},
														}
									},
									{
										["name"] = "Enhancement", 
										["data"] = {
																{ "Elemental Weapons", "Interface\\Icons\\Spell_Fire_FlameTounge", 1, 1},
																{ "Focused Strikes", "INTERFACE\\ICONS\\spell_shaman_focusedstrikes", 1, 2},
																{ "Improved Shields", "Interface\\Icons\\Spell_Nature_LightningShield", 1, 3},
																{ "Elemental Devastation", "Interface\\Icons\\Spell_Fire_ElementalDevastation", 2, 1},
																{ "Flurry", "Interface\\Icons\\Ability_GhoulFrenzy", 2, 2},
																{ "Ancestral Swiftness", "INTERFACE\\ICONS\\spell_lifegivingspeed", 2, 3},
																{ "Totemic Reach", "Interface\\Icons\\Spell_Nature_AgitatingTotem", 2, 4},
																{ "Toughness", "Interface\\Icons\\Spell_Holy_Devotion", 3, 1},
																{ "Stormstrike", "Interface\\Icons\\Ability_Shaman_Stormstrike", 3, 2},
																{ "Static Shock", "Interface\\Icons\\Spell_Shaman_StaticShock", 3, 3},
																{ "Frozen Power", "Interface\\Icons\\Spell_Fire_BlueCano", 4, 1},
																{ "Seasoned Winds", "Interface\\Icons\\Spell_Nature_ElementalAbsorption", 4, 2},
																{ "Searing Flames", "Interface\\Icons\\Spell_Fire_SearingTotem", 4, 3},
																{ "Earthen Power", "Interface\\Icons\\Spell_Nature_EarthElemental_Totem", 5, 1},
																{ "Shamanistic Rage", "Interface\\Icons\\Spell_Nature_ShamanRage", 5, 2},
																{ "Unleashed Rage", "Interface\\Icons\\Spell_Nature_UnleashedRage", 5, 4},
																{ "Maelstrom Weapon", "Interface\\Icons\\Spell_Shaman_MaelstromWeapon", 6, 2},
																{ "Improved Lava Lash", "INTERFACE\\ICONS\\spell_shaman_improvelavalash", 6, 3},
																{ "Feral Spirit", "Interface\\Icons\\Spell_Shaman_FeralSpirit", 7, 2},
															 }
									},
									{ 
										["name"] = "Restoration", 
										["data"] = {
																{ "Ancestral Resolve", "Interface\\Icons\\spell_nature_rune", 1, 1},
																{ "Tidal Focus", "Interface\\Icons\\Spell_Frost_ManaRecharge", 1, 2},
																{ "Spark of Life", "Interface\\Icons\\Spell_Nature_WispSplodeGreen", 1, 3},
																{ "Improved Water Shield", "Interface\\Icons\\Ability_Shaman_WaterShield", 2, 1},
																{ "Totemic Focus", "Interface\\Icons\\Spell_Nature_MoonGlow", 2, 2},
																{ "Focused Insight", "INTERFACE\\ICONS\\spell_shaman_measuredinsight", 2, 3},
																{ "Nature's Guardian", "Interface\\Icons\\Spell_Nature_NatureGuardian", 2, 4},
																{ "Ancestral Healing", "Interface\\Icons\\Spell_Nature_UndyingStrength", 3, 1},
																{ "Nature's Swiftness", "Interface\\Icons\\Spell_Nature_RavenForm", 3, 2},
																{ "Nature's Blessing", "Interface\\Icons\\Spell_Nature_NatureBlessing", 3, 3},
																{ "Soothing Rains", "Interface\\Icons\\Spell_Nature_GiftoftheWaterSpirit", 4, 2},
																{ "Improved Cleanse Spirit", "Interface\\Icons\\Ability_Shaman_CleanseSpirit", 4, 3},
																{ "Cleansing Waters", "Interface\\Icons\\Spell_Nature_Regeneration_02", 4, 4},
																{ "Ancestral Awakening", "Interface\\Icons\\Spell_Shaman_AncestralAwakening", 5, 1},
																{ "Mana Tide Totem", "Interface\\Icons\\Spell_Frost_SummonWaterElemental", 5, 2},
																{ "Telluric Currents", "Interface\\Icons\\Spell_Lightning_LightningBolt01", 5, 3},
																{ "Spirit Link Totem", "Interface\\Icons\\Spell_Shaman_SpiritLink", 5, 4},
																{ "Tidal Waves", "Interface\\Icons\\Spell_Shaman_TidalWaves", 6, 2},
																{ "Blessing of the Eternals", "Interface\\Icons\\Spell_Shaman_BlessingOfEternals", 6, 3},
																{ "Riptide", "Interface\\Icons\\spell_nature_riptide", 7, 2},
															 }
									}
						},
["Paladin"] = {
								{ 
									["name"] = "Holy", 
									["data"] = {
															{ "Arbiter of the Light", "Interface\\Icons\\Spell_Holy_HealingAura", 1, 1},
															{ "Protector of the Innocent", "INTERFACE\\ICONS\\ability_paladin_protectoroftheinnocent", 1, 2},
															{ "Judgements of the Pure", "Interface\\Icons\\Ability_Paladin_JudgementofthePure", 1, 3},
															{ "Clarity of Purpose", "INTERFACE\\ICONS\\spell_paladin_clarityofpurpose", 2, 1},
															{ "Last Word", "Interface\\Icons\\Spell_Holy_HolyGuidance", 2, 2},
															{ "Blazing Light", "Interface\\Icons\\Spell_Holy_HolyBolt", 2, 3},
															{ "Denounce", "Interface\\Icons\\Spell_Holy_Excorcism_02", 3, 1},
															{ "Divine Favor", "Interface\\Icons\\Spell_Holy_DivineIllumination", 3, 2},
															{ "Infusion of Light", "Interface\\Icons\\Ability_Paladin_InfusionofLight", 3, 3},
															{ "Daybreak", "Interface\\Icons\\INV_QirajIdol_Sun", 3, 4},
															{ "Enlightened Judgements", "Interface\\Icons\\Ability_Paladin_EnlightenedJudgements", 4, 1},
															{ "Beacon of Light", "Interface\\Icons\\Ability_Paladin_BeaconofLight", 4, 2},
															{ "Speed of Light", "INTERFACE\\ICONS\\paladin_icon_speedoflight", 4, 3},
															{ "Sacred Cleansing", "Interface\\Icons\\Ability_Paladin_SacredCleansing", 4, 4},
															{ "Conviction", "INTERFACE\\ICONS\\ability_paladin_conviction", 5, 1},
															{ "Aura Mastery", "Interface\\Icons\\Spell_Holy_AuraMastery", 5, 3},
															{ "Paragon of Virtue", "Interface\\Icons\\Spell_Holy_AvengineWrath", 5, 4},
															{ "Tower of Radiance", "Interface\\Icons\\Achievement_BG_winSOA", 6, 2},
															{ "Blessed Life", "Interface\\Icons\\Spell_Holy_BlessedLife", 6, 3},
															{ "Light of Dawn", "INTERFACE\\ICONS\\spell_paladin_lightofdawn", 7, 2},
														 }
								},
								{ 
									["name"] = "Protection", 
									["data"] = {
															{ "Divinity", "Interface\\Icons\\Spell_Holy_BlindingHeal", 1, 1},
															{ "Seals of the Pure", "Interface\\Icons\\INV_Mace_46", 1, 2},
															{ "Eternal Glory", "Interface\\Icons\\INV_Torch_Thrown", 1, 3},
															{ "Judgements of the Just", "Interface\\Icons\\Ability_Paladin_JudgementsoftheJust", 2, 1},
															{ "Toughness", "Interface\\Icons\\Spell_Holy_Devotion", 2, 2},
															{ "Improved Hammer of Justice", "Interface\\Icons\\Spell_Holy_SealOfMight", 2, 3},
															{ "Hallowed Ground", "Interface\\Icons\\Spell_Holy_InnerFire", 3, 1},
															{ "Sanctuary", "Interface\\Icons\\Spell_Nature_LightningShield", 3, 2},
															{ "Hammer of the Righteous", "Interface\\Icons\\Ability_Paladin_HammeroftheRighteous", 3, 3},
															{ "Wrath of the Lightbringer", "INTERFACE\\ICONS\\inv_mace_82", 3, 4},
															{ "Reckoning", "Interface\\Icons\\Spell_Holy_BlessingOfStrength", 4, 1},
															{ "Shield of the Righteous", "Interface\\Icons\\Ability_Paladin_ShieldofVengeance", 4, 2},
															{ "Grand Crusader", "Interface\\Icons\\INV_Helmet_74", 4, 3},
															{ "Vindication", "Interface\\Icons\\Spell_Holy_Vindication", 5, 1},
															{ "Holy Shield", "Interface\\Icons\\Spell_Holy_BlessingOfProtection", 5, 2},
															{ "Guarded by the Light", "Interface\\Icons\\Ability_Paladin_GaurdedbytheLight", 5, 3},
															{ "Divine Guardian", "Interface\\Icons\\spell_holy_powerwordbarrier", 5, 4},
															{ "Sacred Duty", "Interface\\Icons\\Spell_Holy_DivineIntervention", 6, 2},
															{ "Shield of the Templar", "Interface\\Icons\\Ability_Paladin_ShieldoftheTemplar", 6, 3},
															{ "Ardent Defender", "Interface\\Icons\\Spell_Holy_ArdentDefender", 7, 2},
														 }
								},
								{
									["name"] = "Retribution", 
									["data"] = {
															{ "Eye for an Eye", "Interface\\Icons\\Spell_Holy_EyeforanEye", 1, 1},
															{ "Crusade", "Interface\\Icons\\Spell_Holy_Crusade", 1, 2},
															{ "Improved Judgement", "Interface\\Icons\\Ability_Paladin_JudgementBlue", 1, 3},
															{ "Guardian's Favor", "Interface\\Icons\\Spell_Holy_SealOfProtection", 2, 1},
															{ "Rule of Law", "Interface\\Icons\\INV_Relics_LibramofHope", 2, 2},
															{ "Pursuit of Justice", "Interface\\Icons\\Spell_Holy_PersuitofJustice", 2, 4},
															{ "Communion", "Interface\\Icons\\Ability_Paladin_JudgementoftheWise", 3, 1},
															{ "The Art of War", "Interface\\Icons\\Ability_Paladin_ArtofWar", 3, 2},
															{ "Long Arm of the Law", "Interface\\Icons\\Ability_Paladin_JudgementRed", 3, 3},
															{ "Divine Storm", "Interface\\Icons\\Ability_Paladin_DivineStorm", 3, 4},
															{ "Sacred Shield", "Interface\\Icons\\Ability_Paladin_BlessedMending", 4, 1},
															{ "Sanctity of Battle", "INTERFACE\\ICONS\\inv_sword_136", 4, 2},
															{ "Seals of Command", "Interface\\Icons\\Ability_Warrior_InnerRage", 4, 3},
															{ "Sanctified Wrath", "Interface\\Icons\\Ability_Paladin_SanctifiedWrath", 4, 4},
															{ "Selfless Healer", "Interface\\Icons\\spell_holy_rune", 5, 1},
															{ "Repentance", "Interface\\Icons\\Spell_Holy_PrayerOfHealing", 5, 2},
															{ "Divine Purpose", "Interface\\Icons\\Spell_Holy_DivinePurpose", 5, 3},
															{ "Inquiry of Faith", "Interface\\Icons\\Ability_Paladin_RighteousVengeance", 6, 2},
															{ "Acts of Sacrifice", "Interface\\Icons\\Ability_Paladin_BlessedHands", 6, 3},
															{ "Zealotry", "Interface\\Icons\\Spell_Holy_ProclaimChampion_02", 7, 2},
														 }
								},
					},
						
["Priest"] = {
								{ 
									["name"] = "Discipline", 
									["data"] = {
															{ "Improved Power Word: Shield", "Interface\\Icons\\Spell_Holy_PowerWordShield", 1, 1},
															{ "Twin Disciplines", "Interface\\Icons\\Spell_Holy_SealOfVengeance", 1, 2},
															{ "Mental Agility", "Interface\\Icons\\Ability_Hibernation", 1, 3},
															{ "Evangelism", "Interface\\Icons\\Spell_Holy_DivineIllumination", 2, 1},
															{ "Archangel", "INTERFACE\\ICONS\\ability_priest_archangel", 2, 2},
															{ "Inner Sanctum", "Interface\\Icons\\Spell_Holy_InnerFire", 2, 3},
															{ "Soul Warding", "INTERFACE\\ICONS\\ability_priest_soulwarding", 2, 4},
															{ "Renewed Hope", "Interface\\Icons\\Spell_Holy_HolyProtection", 3, 1},
															{ "Power Infusion", "Interface\\Icons\\Spell_Holy_PowerInfusion", 3, 2},
															{ "Atonement", "INTERFACE\\ICONS\\ability_priest_atonement", 3, 3},
															{ "Inner Focus", "Interface\\Icons\\Spell_Frost_WindWalkOn", 3, 4},
															{ "Rapture", "Interface\\Icons\\Spell_Holy_Rapture", 4, 2},
															{ "Borrowed Time", "Interface\\Icons\\Spell_Holy_BorrowedTime", 4, 3},
															{ "Reflective Shield", "INTERFACE\\ICONS\\ability_priest_reflectiveshield", 4, 4},
															{ "Strength of Soul", "Interface\\Icons\\Spell_Holy_AshesToAshes", 5, 1},
															{ "Divine Aegis", "Interface\\Icons\\Spell_Holy_DevineAegis", 5, 2},
															{ "Pain Suppression", "Interface\\Icons\\Spell_Holy_PainSupression", 5, 3},
															{ "Train of Thought", "Interface\\Icons\\Ability_Mage_StudentOfTheMind", 5, 4},
															{ "Focused Will", "INTERFACE\\ICONS\\ability_priest_focusedwill", 6, 1},
															{ "Grace", "Interface\\Icons\\Spell_Holy_HopeAndGrace", 6, 3},
															{ "Power Word: Barrier", "Interface\\Icons\\spell_holy_powerwordbarrier", 7, 2},
														 }
								},
								{ 
									["name"] = "Holy", 
									["data"] = {
															{ "Improved Renew", "Interface\\Icons\\Spell_Holy_Renew", 1, 1},
															{ "Empowered Healing", "Interface\\Icons\\Spell_Holy_GreaterHeal", 1, 2},
															{ "Divine Fury", "Interface\\Icons\\Spell_Holy_SealOfWrath", 1, 3},
															{ "Desperate Prayer", "Interface\\Icons\\Spell_Holy_Restoration", 2, 2},
															{ "Surge of Light", "Interface\\Icons\\Spell_Holy_SurgeOfLight", 2, 3},
															{ "Inspiration", "Interface\\Icons\\Spell_Holy_LayOnHands", 2, 4},
															{ "Divine Touch", "Interface\\Icons\\Ability_Paladin_InfusionofLight", 3, 1},
															{ "Holy Concentration", "Interface\\Icons\\Spell_Holy_Fanaticism", 3, 2},
															{ "Lightwell", "Interface\\Icons\\Spell_Holy_SummonLightwell", 3, 3},
															{ "Tome of Light", "Interface\\Icons\\INV_Misc_Book_07", 3, 4},
															{ "Rapid Renewal", "Interface\\Icons\\Ability_Paladin_BlessedMending", 4, 1},
															{ "Spirit of Redemption", "Interface\\Icons\\INV_Enchant_EssenceEternalLarge", 4, 3},
															{ "Serendipity", "Interface\\Icons\\Spell_Holy_Serendipity", 4, 4},
															{ "Body and Soul", "Interface\\Icons\\Spell_Holy_SymbolOfHope", 5, 1},
															{ "Chakra", "INTERFACE\\ICONS\\priest_icon_chakra", 5, 2},
															{ "Revelations", "INTERFACE\\ICONS\\ability_priest_bindingprayers", 5, 3},
															{ "Blessed Resilience", "Interface\\Icons\\Spell_Holy_BlessedResillience", 5, 4},
															{ "Test of Faith", "Interface\\Icons\\Spell_Holy_TestOfFaith", 6, 1},
															{ "State of Mind", "Interface\\Icons\\Spell_Arcane_MindMastery", 6, 2},
															{ "Circle of Healing", "Interface\\Icons\\Spell_Holy_CircleOfRenewal", 6, 3},
															{ "Guardian Spirit", "Interface\\Icons\\Spell_Holy_GuardianSpirit", 7, 2},
														 }
							}
				},
}
				